diff --git a/rosen/modules/composer/hdi_backend/include/hdi_layer.h b/rosen/modules/composer/hdi_backend/include/hdi_layer.h
index 898cc42999..0909b5db44 100644
--- a/rosen/modules/composer/hdi_backend/include/hdi_layer.h
+++ b/rosen/modules/composer/hdi_backend/include/hdi_layer.h
@@ -37,7 +37,7 @@ public:
     explicit HdiLayer(uint32_t screenId);
     virtual ~HdiLayer();
 
-    static constexpr int FRAME_RECORDS_NUM = 256;
+    static constexpr int FRAME_RECORDS_NUM = 384;
 
     /* output create and set layer info */
     static std::shared_ptr<HdiLayer> CreateHdiLayer(uint32_t screenId);
diff --git a/rosen/modules/composer/hdi_backend/src/hdi_layer.cpp b/rosen/modules/composer/hdi_backend/src/hdi_layer.cpp
index d33ef95c2e..0d8c9698ab 100644
--- a/rosen/modules/composer/hdi_backend/src/hdi_layer.cpp
+++ b/rosen/modules/composer/hdi_backend/src/hdi_layer.cpp
@@ -646,7 +646,7 @@ void HdiLayer::SelectHitchsInfo(std::string windowName, std::string &result)
         std::unique_lock<std::mutex> lock(mutex_);
         const uint32_t offset = count_;
         for (uint32_t i = 0; i < FRAME_RECORDS_NUM; i++) {
-            uint32_t order = (offset + i) % FRAME_RECORDS_NUM;
+            uint32_t order = (offset + FRAME_RECORDS_NUM - i - 1) % FRAME_RECORDS_NUM;
             auto windowsName = presentTimeRecords_[order].windowsName;
             auto iter = std::find(windowsName.begin(), windowsName.end(), windowName);
             int64_t lastFlushTimestamp = 0;
@@ -730,7 +730,7 @@ void HdiLayer::Dump(std::string &result)
     std::unique_lock<std::mutex> lock(mutex_);
     const uint32_t offset = count_;
     for (uint32_t i = 0; i < FRAME_RECORDS_NUM; i++) {
-        uint32_t order = (offset + i) % FRAME_RECORDS_NUM;
+        uint32_t order = (offset + FRAME_RECORDS_NUM - i - 1) % FRAME_RECORDS_NUM;
         result += std::to_string(presentTimeRecords_[order].presentTime) + "\n";
     }
 }
@@ -740,7 +740,7 @@ void HdiLayer::DumpByName(std::string windowName, std::string &result)
     std::unique_lock<std::mutex> lock(mutex_);
     const uint32_t offset = count_;
     for (uint32_t i = 0; i < FRAME_RECORDS_NUM; i++) {
-        uint32_t order = (offset + i) % FRAME_RECORDS_NUM;
+        uint32_t order = (offset + FRAME_RECORDS_NUM - i - 1) % FRAME_RECORDS_NUM;
         auto windowsName = presentTimeRecords_[order].windowsName;
         auto iter = std::find(windowsName.begin(), windowsName.end(), windowName);
         if (iter != windowsName.end()) {
@@ -754,7 +754,7 @@ void HdiLayer::DumpMergedResult(std::string &result)
     std::unique_lock<std::mutex> lock(mutex_);
     const uint32_t offset = mergedCount_;
     for (uint32_t i = 0; i < FRAME_RECORDS_NUM; i++) {
-        uint32_t order = (offset + i) % FRAME_RECORDS_NUM;
+        uint32_t order = (offset + FRAME_RECORDS_NUM - i - 1) % FRAME_RECORDS_NUM;
         result += std::to_string(mergedPresentTimeRecords_[order]) + "\n";
     }
 }
diff --git a/rosen/modules/composer/hdi_backend/src/hdi_output.cpp b/rosen/modules/composer/hdi_backend/src/hdi_output.cpp
index 26666f4457..1b5906a9bc 100644
--- a/rosen/modules/composer/hdi_backend/src/hdi_output.cpp
+++ b/rosen/modules/composer/hdi_backend/src/hdi_output.cpp
@@ -757,7 +757,7 @@ void HdiOutput::DumpFps(std::string &result, const std::string &arg) const
         result += "The fps of screen [Id:" + std::to_string(screenId_) + "] is:\n";
         const int32_t offset = compTimeRcdIndex_;
         for (uint32_t i = 0; i < COMPOSITION_RECORDS_NUM; i++) {
-            uint32_t order = (offset + i) % COMPOSITION_RECORDS_NUM;
+            uint32_t order = (offset + COMPOSITION_RECORDS_NUM - i - 1) % COMPOSITION_RECORDS_NUM;
             result += std::to_string(compositionTimeRecords_[order]) + "\n";
         }
         return;
diff --git a/rosen/modules/render_service/core/drawable/rs_surface_render_node_drawable.cpp b/rosen/modules/render_service/core/drawable/rs_surface_render_node_drawable.cpp
index ca1d06bdc7..304ade47ae 100644
--- a/rosen/modules/render_service/core/drawable/rs_surface_render_node_drawable.cpp
+++ b/rosen/modules/render_service/core/drawable/rs_surface_render_node_drawable.cpp
@@ -35,6 +35,7 @@
 #ifdef OHOS_BUILD_ENABLE_MAGICCURSOR
 #include "pipeline/magic_pointer_render/rs_magic_pointer_render_manager.h"
 #endif
+#include "gfx_info/rs_surface_fps_manager.h"
 
 #include "platform/common/rs_log.h"
 #include "platform/ohos/rs_node_stats.h"
@@ -973,6 +974,14 @@ void RSSurfaceRenderNodeDrawable::DrawBufferForRotationFixed(RSPaintFilterCanvas
 void RSSurfaceRenderNodeDrawable::DrawSelfDrawingNodeBuffer(
     RSPaintFilterCanvas& canvas, const RSSurfaceRenderParams& surfaceParams, BufferDrawParam& params)
 {
+    uint64_t currentTime = std::chrono::duration_cast<std::chrono::nanoseconds>(
+        std::chrono::steady_clock::now().time_since_epoch()).count();
+    const auto& surfaceFpsManager = RSSurfaceFpsManager::GetInstance();
+    if (params.buffer == nullptr) {
+        RS_LOGE("RSSurfaceRenderNodeDrawable::DrawSelfDrawingNodeBuffer params.buffer is nullptr");
+    } else {
+        surfaceFpsManager.RecordPresentTime(surfaceParams.GetId(), currentTime, params.buffer->GetSeqNum());
+    }
     auto bgColor = surfaceParams.GetBackgroundColor();
     auto renderEngine = RSUniRenderThread::Instance().GetRenderEngine();
     if ((surfaceParams.GetSelfDrawingNodeType() != SelfDrawingNodeType::VIDEO) &&
diff --git a/rosen/modules/render_service/core/pipeline/rs_hardware_thread.cpp b/rosen/modules/render_service/core/pipeline/rs_hardware_thread.cpp
index 9b4528e36b..99e0cafb10 100644
--- a/rosen/modules/render_service/core/pipeline/rs_hardware_thread.cpp
+++ b/rosen/modules/render_service/core/pipeline/rs_hardware_thread.cpp
@@ -40,6 +40,7 @@
 #include "platform/ohos/backend/rs_surface_ohos_gl.h"
 #include "platform/ohos/backend/rs_surface_ohos_raster.h"
 #include "screen_manager/rs_screen_manager.h"
+#include "gfx_info/rs_surface_fps_manager.h"
 
 #ifdef RS_ENABLE_EGLIMAGE
 #include "src/gpu/gl/GrGLDefines.h"
@@ -220,6 +221,7 @@ void RSHardwareThread::CommitAndReleaseLayers(OutputPtr output, const std::vecto
         output->SetLayerInfo(layers);
         if (output->IsDeviceValid()) {
             hdiBackend_->Repaint(output);
+            RecordTimestamp(layers);
         }
         output->ReleaseLayers(releaseFence_);
         RSBaseRenderUtil::DecAcquiredBufferCount();
@@ -281,6 +283,23 @@ void RSHardwareThread::CommitAndReleaseLayers(OutputPtr output, const std::vecto
     PostDelayTask(task, delayTime_);
 }
 
+void RSHardwareThread::RecordTimestamp(const std::vector<LayerInfoPtr>& layers)
+{
+    uint64_t currentTime = std::chrono::duration_cast<std::chrono::nanoseconds>(
+        std::chrono::steady_clock::now().time_since_epoch()).count();
+    for (auto& layer : layers) {
+        if (layer == nullptr ||
+            layer->GetUniRenderFlag() ||
+            layer->GetSurface()->GetName().find("RCDBottomSurfaceNode") != std::string::npos ||
+            layer->GetSurface()->GetName().find("RCDTopSurfaceNode") != std::string::npos) {
+                continue;
+            }
+            uint64_t id = layer->GetNodeId();
+            const auto& surfaceFpsManager = RSSurfaceFpsManager::GetInstance();
+            surfaceFpsManager.RecordPresentTime(id, currentTime, layer->GetBuffer()->GetSeqNum());
+    }
+}
+
 bool RSHardwareThread::IsDelayRequired(OHOS::Rosen::HgmCore& hgmCore, RefreshRateParam param,
     const OutputPtr& output, bool hasGameScene)
 {
diff --git a/rosen/modules/render_service/core/pipeline/rs_hardware_thread.h b/rosen/modules/render_service/core/pipeline/rs_hardware_thread.h
index 1acd6f020a..f7df4afc74 100644
--- a/rosen/modules/render_service/core/pipeline/rs_hardware_thread.h
+++ b/rosen/modules/render_service/core/pipeline/rs_hardware_thread.h
@@ -80,6 +80,7 @@ private:
     void PerformSetActiveMode(OutputPtr output, uint64_t timestamp, uint64_t constraintRelativeTime);
     void ExecuteSwitchRefreshRate(const OutputPtr& output, uint32_t refreshRate);
     void AddRefreshRateCount(const OutputPtr& output);
+    void RecordTimestamp(const std::vector<LayerInfoPtr>& layers);
     int64_t GetCurTimeCount();
     bool IsInAdaptiveMode(const OutputPtr &output);
 
diff --git a/rosen/modules/render_service/core/pipeline/rs_render_service.cpp b/rosen/modules/render_service/core/pipeline/rs_render_service.cpp
index 4109c35548..fa1b3e8c16 100644
--- a/rosen/modules/render_service/core/pipeline/rs_render_service.cpp
+++ b/rosen/modules/render_service/core/pipeline/rs_render_service.cpp
@@ -30,6 +30,7 @@
 #include "rs_profiler.h"
 #include "rs_render_service_connection.h"
 #include "vsync_generator.h"
+#include "rs_trace.h"
 
 #include "common/rs_singleton.h"
 #include "graphic_2d_configure.h"
@@ -43,6 +44,8 @@
 #include "pipeline/rs_uni_render_judgement.h"
 #include "system/rs_system_parameters.h"
 
+#include "gfx_info/rs_surface_fps_manager.h"
+
 #include "text/font_mgr.h"
 
 #ifdef TP_FEATURE_ENABLE
@@ -365,53 +368,94 @@ void RSRenderService::FPSDUMPProcess(std::unordered_set<std::u16string>& argSets
     std::string& dumpString, const std::u16string& arg) const
 {
     auto iter = argSets.find(arg);
-    if (iter != argSets.end()) {
-        std::string layerArg;
-        argSets.erase(iter);
-        if (!argSets.empty()) {
-            layerArg = std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> {}.to_bytes(*argSets.begin());
-        }
-        auto renderType = RSUniRenderJudgement::GetUniRenderEnabledType();
-        if (renderType == UniRenderEnabledType::UNI_RENDER_ENABLED_FOR_ALL) {
+    if (iter == argSets.end()) {
+        return ;
+    }
+    argSets.erase(iter);
+    if (argSets.empty()) {
+        RS_LOGE("RSRenderService::FPSDUMPProcess layer name is not specified");
+        return ;
+    }
+    RS_TRACE_NAME("RSRenderService::FPSDUMPProcess");
+    std::string fpsArg = std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> {}
+        .to_bytes(*argSets.begin());
+    std::unordered_set<std::string> args{"DisplayNode", "composer", "UniRender"};
+    if (args.find(fpsArg) != args.end()) {
+        DumpFps(dumpString, fpsArg);
+    } else {
+        DumpSurfaceNodeFps(dumpString, fpsArg);
+    }
+}
+
+void RSRenderService::DumpFps(std::string& dumpString, std::string& fpsArg) const
+{
+    auto renderType = RSUniRenderJudgement::GetUniRenderEnabledType();
+    if (renderType == UniRenderEnabledType::UNI_RENDER_ENABLED_FOR_ALL) {
 #ifdef RS_ENABLE_GPU
-            RSHardwareThread::Instance().ScheduleTask(
-                [this, &dumpString, &layerArg]() { return screenManager_->FpsDump(dumpString, layerArg); }).wait();
+        RSHardwareThread::Instance().ScheduleTask(
+            [this, &dumpString, &fpsArg]() { return screenManager_->FpsDump(dumpString, fpsArg); }).wait();
 #endif
-        } else {
-            mainThread_->ScheduleTask(
-                [this, &dumpString, &layerArg]() { return screenManager_->FpsDump(dumpString, layerArg); }).wait();
-        }
+    } else {
+        mainThread_->ScheduleTask(
+            [this, &dumpString, &fpsArg]() { return screenManager_->FpsDump(dumpString, fpsArg); }).wait();
     }
 }
 
+void RSRenderService::DumpSurfaceNodeFps(std::string& dumpString, std::string& fpsArg) const
+{
+    dumpString += "\n-- The recently fps records info of screens:\n";
+    const auto& surfaceFpsManager = RSSurfaceFpsManager::GetInstance();
+    surfaceFpsManager.Dump(dumpString, fpsArg);
+}
+
 void RSRenderService::FPSDUMPClearProcess(std::unordered_set<std::u16string>& argSets,
     std::string& dumpString, const std::u16string& arg) const
 {
     auto iter = argSets.find(arg);
-    if (iter != argSets.end()) {
-        std::string layerArg;
-        argSets.erase(iter);
-        if (!argSets.empty()) {
-            layerArg = std::wstring_convert<
-            std::codecvt_utf8_utf16<char16_t>, char16_t> {}.to_bytes(*argSets.begin());
-        }
-        auto renderType = RSUniRenderJudgement::GetUniRenderEnabledType();
-        if (renderType == UniRenderEnabledType::UNI_RENDER_ENABLED_FOR_ALL) {
+    if (iter == argSets.end()) {
+        return ;
+    }
+    argSets.erase(iter);
+    if (argSets.empty()) {
+        RS_LOGE("RSRenderService::FPSDUMPClearProcess layer name is not specified");
+        return ;
+    }
+    RS_TRACE_NAME("RSRenderService::FPSDUMPClearProcess");
+    std::string fpsArg = std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> {}
+        .to_bytes(*argSets.begin());
+    std::unordered_set<std::string> args{"DisplayNode", "composer"};
+    if (args.find(fpsArg) != args.end()) {
+        ClearFps(dumpString, fpsArg);
+    } else {
+        ClearSurfaceNodeFps(dumpString, fpsArg);
+    }
+}
+
+void RSRenderService::ClearFps(std::string& dumpString, std::string& fpsArg) const
+{
+    auto renderType = RSUniRenderJudgement::GetUniRenderEnabledType();
+    if (renderType == UniRenderEnabledType::UNI_RENDER_ENABLED_FOR_ALL) {
 #ifdef RS_ENABLE_GPU
-            RSHardwareThread::Instance().ScheduleTask(
-                [this, &dumpString, &layerArg]() {
-                    return screenManager_->ClearFpsDump(dumpString, layerArg);
-                }).wait();
+        RSHardwareThread::Instance().ScheduleTask(
+            [this, &dumpString, &fpsArg]() {
+                return screenManager_->ClearFpsDump(dumpString, fpsArg);
+            }).wait();
 #endif
-        } else {
-            mainThread_->ScheduleTask(
-                [this, &dumpString, &layerArg]() {
-                    return screenManager_->ClearFpsDump(dumpString, layerArg);
-                }).wait();
-        }
+    } else {
+        mainThread_->ScheduleTask(
+            [this, &dumpString, &fpsArg]() {
+                return screenManager_->ClearFpsDump(dumpString, fpsArg);
+            }).wait();
     }
 }
 
+void RSRenderService::ClearSurfaceNodeFps(std::string& dumpString, std::string& fpsArg) const
+{
+    dumpString += "\n-- Clear fps records info of screens:\n";
+    const auto& surfaceFpsManager = RSSurfaceFpsManager::GetInstance();
+    surfaceFpsManager.ClearDump(fpsArg);
+}
+
 void RSRenderService::DumpRSEvenParam(std::string& dumpString) const
 {
     dumpString.append("\n");
diff --git a/rosen/modules/render_service/core/pipeline/rs_render_service.h b/rosen/modules/render_service/core/pipeline/rs_render_service.h
index 6c88bd9601..b1b6b2a437 100644
--- a/rosen/modules/render_service/core/pipeline/rs_render_service.h
+++ b/rosen/modules/render_service/core/pipeline/rs_render_service.h
@@ -61,8 +61,12 @@ private:
     void DumpNode(std::unordered_set<std::u16string>& argSets, std::string& dumpString) const;
     void FPSDUMPProcess(std::unordered_set<std::u16string>& argSets, std::string& dumpString,
         const std::u16string& arg) const;
+    void DumpFps(std::string& dumpString, std::string& fpsArg) const;
+    void DumpSurfaceNodeFps(std::string& dumpString, std::string& fpsArg) const;
     void FPSDUMPClearProcess(std::unordered_set<std::u16string>& argSets,
         std::string& dumpString, const std::u16string& arg) const;
+    void ClearFps(std::string& dumpString, std::string& fpsArg) const;
+    void ClearSurfaceNodeFps(std::string& dumpString, std::string& fpsArg) const;
 
     sptr<RSIRenderServiceConnection> CreateConnection(const sptr<RSIConnectionToken>& token) override;
     void RemoveConnection(sptr<IRemoteObject> token);
diff --git a/rosen/modules/render_service_base/BUILD.gn b/rosen/modules/render_service_base/BUILD.gn
index 2b4f8822b6..597443dd02 100644
--- a/rosen/modules/render_service_base/BUILD.gn
+++ b/rosen/modules/render_service_base/BUILD.gn
@@ -275,6 +275,10 @@ ohos_source_set("render_service_base_src") {
     "src/transaction/rs_transaction_proxy.cpp",
     "src/transaction/rs_uiextension_data.cpp",
 
+    #gfx_info
+    "src/gfx_info/rs_surface_fps.cpp",
+    "src/gfx_info/rs_surface_fps_manager.cpp",
+
     #screen_manager
     "src/screen_manager/rs_screen_capability.cpp",
     "src/screen_manager/rs_screen_data.cpp",
diff --git a/rosen/modules/render_service_base/include/gfx_info/rs_surface_fps.h b/rosen/modules/render_service_base/include/gfx_info/rs_surface_fps.h
new file mode 100644
index 0000000000..d19a2f424e
--- /dev/null
+++ b/rosen/modules/render_service_base/include/gfx_info/rs_surface_fps.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RENDER_SERVICE_BASE_GFX_INFO_RS_SURFACE_FPS_H
+#define RENDER_SERVICE_BASE_GFX_INFO_RS_SURFACE_FPS_H
+
+#include <string>
+#include <mutex>
+
+#include "common/rs_common_def.h"
+
+namespace OHOS::Rosen {
+
+struct FPSStat {
+    uint64_t presentTime;
+    uint32_t seqNum;
+};
+
+class RSB_EXPORT RSSurfaceFps {
+public:
+    RSSurfaceFps(std::string name) : name_(name) {};
+    bool RecordPresentTime(uint64_t timestamp, uint32_t seqNum);
+    void Dump(std::string& result);
+    void ClearDump();
+    std::string GetName() {
+        return name_;
+    }
+
+private:
+    static constexpr int FRAME_RECORDS_NUM = 384;
+    std::array<FPSStat, FRAME_RECORDS_NUM> presentTimeRecords_ {};
+    uint32_t count_ = 0;
+    std::mutex mutex_;
+    std::string name_;
+};
+}
+#endif
\ No newline at end of file
diff --git a/rosen/modules/render_service_base/include/gfx_info/rs_surface_fps_manager.h b/rosen/modules/render_service_base/include/gfx_info/rs_surface_fps_manager.h
new file mode 100644
index 0000000000..0377ed7f22
--- /dev/null
+++ b/rosen/modules/render_service_base/include/gfx_info/rs_surface_fps_manager.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RENDER_SERVICE_BASE_GFX_INFO_RS_SURFACE_FPS_MANAGER_H
+#define RENDER_SERVICE_BASE_GFX_INFO_RS_SURFACE_FPS_MANAGER_H
+
+#include "gfx_info/rs_surface_fps.h"
+#include "common/rs_common_def.h"
+
+namespace OHOS::Rosen {
+class RSB_EXPORT RSSurfaceFpsManager {
+public:
+    static RSSurfaceFpsManager &GetInstance();
+    bool Register(NodeId id, std::string name);
+    bool Unregister(NodeId id);
+    bool RecordPresentTime(NodeId id, uint64_t timestamp, int32_t seqNum) const;
+    void Dump(std::string& result, std::string name) const;
+    void ClearDump(std::string& result, std::string name) const;
+private:
+    std::shared_ptr<RSSurfaceFps> GetSurfaceFps(NodeId id) const;
+    std::shared_ptr<RSSurfaceFps> GetSurfaceFps(std::string name) const;
+    std::unordered_map<NodeId, std::shared_ptr<RSSurfaceFps>> surfaceFpsMap_;
+};
+}
+#endif
\ No newline at end of file
diff --git a/rosen/modules/render_service_base/include/pipeline/rs_surface_render_node.h b/rosen/modules/render_service_base/include/pipeline/rs_surface_render_node.h
index 287e0f91e6..d0108c3b68 100644
--- a/rosen/modules/render_service_base/include/pipeline/rs_surface_render_node.h
+++ b/rosen/modules/render_service_base/include/pipeline/rs_surface_render_node.h
@@ -51,6 +51,7 @@ namespace Rosen {
 class RSCommand;
 class RSDirtyRegionManager;
 class RSSurfaceHandler;
+
 class RSB_EXPORT RSSurfaceRenderNode : public RSRenderNode {
 public:
     using WeakPtr = std::weak_ptr<RSSurfaceRenderNode>;
diff --git a/rosen/modules/render_service_base/src/gfx_info/rs_surface_fps.cpp b/rosen/modules/render_service_base/src/gfx_info/rs_surface_fps.cpp
new file mode 100644
index 0000000000..74f1a8d0f5
--- /dev/null
+++ b/rosen/modules/render_service_base/src/gfx_info/rs_surface_fps.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "gfx_info/rs_surface_fps.h"
+#include "rs_trace.h"
+
+namespace OHOS::Rosen {
+bool RSSurfaceFps::RecordPresentTime(uint64_t timestamp, uint32_t seqNum)
+{
+    std::unique_lock<std::mutex> lock(mutex_);
+    if (seqNum == presentTimeRecords_[(count_ - 1 + FRAME_RECORDS_NUM) % FRAME_RECORDS_NUM].seqNum) {
+        return false;
+    }
+    RS_TRACE_NAME_FMT("RSSurfaceFps::RecordPresentTime timestamp:%llu", timestamp);
+    presentTimeRecords_[count_].presentTime = timestamp;
+    presentTimeRecords_[count_].seqNum = seqNum;
+    count_ = (count_ + 1) % FRAME_RECORDS_NUM;
+    return true;
+}
+void RSSurfaceFps::Dump(std::string& result)
+{
+    std::unique_lock<std::mutex> lock(mutex_);
+    const uint32_t offset = count_;
+    for (uint32_t i = 0; i < FRAME_RECORDS_NUM; i++) {
+        uint32_t order = (offset + FRAME_RECORDS_NUM - i - 1) % FRAME_RECORDS_NUM;
+        result += std::to_string(presentTimeRecords_[order].presentTime) + "\n";
+    }
+}
+void RSSurfaceFps::ClearDump()
+{
+    std::unique_lock<std::mutex> lock(mutex_);
+    FPSStat defaultFPSStat = {0, 0};
+    presentTimeRecords_.fill(defaultFPSStat);
+}
+}
\ No newline at end of file
diff --git a/rosen/modules/render_service_base/src/gfx_info/rs_surface_fps_manager.cpp b/rosen/modules/render_service_base/src/gfx_info/rs_surface_fps_manager.cpp
new file mode 100644
index 0000000000..c22d987384
--- /dev/null
+++ b/rosen/modules/render_service_base/src/gfx_info/rs_surface_fps_manager.cpp
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <memory>
+
+#include "gfx_info/rs_surface_fps_manager.h"
+#include "platform/common/rs_log.h"
+
+namespace OHOS::Rosen {
+RSSurfaceFpsManager& RSSurfaceFpsManager::GetInstance()
+{
+    static RSSurfaceFpsManager instance;
+    return instance;
+}
+
+bool RSSurfaceFpsManager::Register(NodeId id, std::string name)
+{
+    if (surfaceFpsMap_.find(id) != surfaceFpsMap_.end()) {
+        RS_LOGE("RSSurfaceFpsManager::Register node:%{public}" PRIu64 "already existed.", id);
+        return false;
+    }
+    surfaceFpsMap_[id] = std::make_shared<RSSurfaceFps>(name);
+    return true;
+}
+bool RSSurfaceFpsManager::Unregister(NodeId id)
+{
+    if (surfaceFpsMap_.find(id) == surfaceFpsMap_.end()) {
+        RS_LOGE("RSSurfaceFpsManager::Unregister node:%{public}" PRIu64 "not exist.", id);
+        return false;
+    }
+    surfaceFpsMap_.erase(id);
+    return true;
+}
+std::shared_ptr<RSSurfaceFps> RSSurfaceFpsManager::GetSurfaceFps(NodeId id) const
+{
+    auto iter = surfaceFpsMap_.find(id);
+    if (iter == surfaceFpsMap_.end()) {
+        return nullptr;
+    }
+    return iter->second;
+}
+std::shared_ptr<RSSurfaceFps> RSSurfaceFpsManager::GetSurfaceFps(std::string name) const
+{
+    for (auto [id, surfaceFps] : surfaceFpsMap_) {
+        if (surfaceFps->GetName() == name) {
+            return surfaceFps;
+        }
+    }
+    return nullptr;
+}
+bool RSSurfaceFpsManager::RecordPresentTime(NodeId id, uint64_t timestamp, int32_t seqNum) const
+{
+    const auto& surfaceFps = GetSurfaceFps(id);
+    if (surfaceFps == nullptr) {
+        RS_LOGE("RSSurfaceFpsManager::RecordPresentTime surfaceFps is nullptr.");
+        return false;
+    }
+    surfaceFps->RecordPresentTime(timestamp, seqNum);
+    return true;
+}
+void RSSurfaceFpsManager::Dump(std::string& result, std::string name) const
+{
+    const auto& surfaceFps = GetSurfaceFps(name);
+    if (surfaceFps == nullptr) {
+        return ;
+    }
+    result += "\n surface [" + name + "]:\n";
+    surfaceFps->Dump(result);
+}
+void RSSurfaceFpsManager::ClearDump(std::string& result, std::string name) const
+{
+    const auto& surfaceFps = GetSurfaceFps(name);
+    if (surfaceFps == nullptr) {
+        return ;
+    }
+    result += "\n The fps info of surface [" + name + "] is cleared.\n";
+    surfaceFps->ClearDump();
+}
+}
\ No newline at end of file
diff --git a/rosen/modules/render_service_base/src/pipeline/rs_render_node_map.cpp b/rosen/modules/render_service_base/src/pipeline/rs_render_node_map.cpp
index 62b0574f05..53afe1ff58 100644
--- a/rosen/modules/render_service_base/src/pipeline/rs_render_node_map.cpp
+++ b/rosen/modules/render_service_base/src/pipeline/rs_render_node_map.cpp
@@ -21,6 +21,7 @@
 #include "pipeline/rs_render_node_gc.h"
 #include "pipeline/rs_surface_render_node.h"
 #include "platform/common/rs_log.h"
+#include "gfx_info/rs_surface_fps_manager.h"
 
 namespace OHOS {
 namespace Rosen {
@@ -166,6 +167,7 @@ bool RSRenderNodeMap::RegisterRenderNode(const std::shared_ptr<RSBaseRenderNode>
         AddUIExtensionSurfaceNode(surfaceNode);
         ObtainLauncherNodeId(surfaceNode);
         ObtainScreenLockWindowNodeId(surfaceNode);
+        RSSurfaceFpsManager::GetInstance().Register(id, surfaceNode->GetName());
     } else if (nodePtr->GetType() == RSRenderNodeType::CANVAS_DRAWING_NODE) {
         auto canvasDrawingNode = nodePtr->ReinterpretCastTo<RSCanvasDrawingRenderNode>();
         canvasDrawingNodeMap_.emplace(id, canvasDrawingNode);
@@ -201,6 +203,7 @@ void RSRenderNodeMap::UnregisterRenderNode(NodeId id)
     if (it != surfaceNodeMap_.end()) {
         RemoveUIExtensionSurfaceNode(it->second);
         surfaceNodeMap_.erase(id);
+        RSSurfaceFpsManager::GetInstance().Unregister(id);
     }
     residentSurfaceNodeMap_.erase(id);
     displayNodeMap_.erase(id);
@@ -221,6 +224,9 @@ void RSRenderNodeMap::MoveRenderNodeMap(
         for (auto subIter = subMap.begin(); subIter != subMap.end();) {
             subIter->second->RemoveFromTree(false);
             subRenderNodeMap->emplace(subIter->first, subIter->second);
+            if (subIter->second->GetType() == RSRenderNodeType::SURFACE_NODE) {
+                RSSurfaceFpsManager::GetInstance().Unregister(subIter->first);
+            }
             subIter = subMap.erase(subIter);
         }
         renderNodeMap_.erase(iter);
@@ -258,6 +264,7 @@ void RSRenderNodeMap::FilterNodeByPid(pid_t pid)
     EraseIf(surfaceNodeMap_, [pid, useBatchRemoving, this](const auto& pair) -> bool {
         bool shouldErase = (ExtractPid(pair.first) == pid);
         if (shouldErase) {
+            RSSurfaceFpsManager::GetInstance().Unregister(pair.first);
             RemoveUIExtensionSurfaceNode(pair.second);
         }
         if (shouldErase && pair.second && useBatchRemoving) {
