diff --git a/interfaces/kits/ani/drawing/ani_drawing_cache_utils.cpp b/interfaces/kits/ani/drawing/ani_drawing_cache_utils.cpp
index bec7be2f69..ccba3b99cb 100644
--- a/interfaces/kits/ani/drawing/ani_drawing_cache_utils.cpp
+++ b/interfaces/kits/ani/drawing/ani_drawing_cache_utils.cpp
@@ -22,20 +22,42 @@ namespace Rosen {
 namespace Drawing {
 
 namespace {
+constexpr DescriptorConfig INT_CTOR{ "<ctor>", "i:" };
+constexpr DescriptorConfig DOUBLE_CTOR{ "<ctor>", "d:" };
+// constexpr DescriptorConfig STRING_CTOR{ "<ctor>", "d:" };
+constexpr DescriptorConfig CANVAS_CTOR{ "<ctor>", "C{@ohos.multimedia.image.image.PixelMap}:"};
+constexpr DescriptorConfig COLOR_FILTER_CTOR{ "<ctor>", ":" };
+constexpr DescriptorConfig MATRIX_CTOR{ "<ctor>", ":" };
+constexpr DescriptorConfig PATH_CTOR{ "<ctor>", ":" };
+constexpr DescriptorConfig PATH_ITERATOR_CTOR{ "<ctor>", "C{@ohos.graphics.drawing.drawing.Path}:" };
+constexpr DescriptorConfig ROUND_RECT_CTOR{ "<ctor>", ":"};
+constexpr DescriptorConfig TYPEFACE_CTOR{ "<ctor>", ":"};
 constexpr DescriptorConfig FONT_METRICS_CTOR{ "<ctor>", "iddddddddddddddd:" };
 constexpr DescriptorConfig POINT_CTOR{ "<ctor>", "dd:" };
 constexpr DescriptorConfig RECT_CTOR{ "<ctor>", "dddd:" };
 constexpr DescriptorConfig COLOR_CTOR{ "<ctor>", "iiii:" };
-constexpr DescriptorConfig COLOR_GET_ALPHA{ "%%get-alpha", ":i" };
-constexpr DescriptorConfig COLOR_GET_RED{ "%%get-red", ":i" };
-constexpr DescriptorConfig COLOR_GET_GREEN{ "%%get-green", ":i" };
-constexpr DescriptorConfig COLOR_GET_BLUE{ "%%get-blue", ":i" };
-constexpr DescriptorConfig RECT_GET_LEFT{ "%%get-left", ":d" };
-constexpr DescriptorConfig RECT_GET_TOP{ "%%get-top", ":d" };
-constexpr DescriptorConfig RECT_GET_RIGHT{ "%%get-right", ":d" };
-constexpr DescriptorConfig RECT_GET_BOTTOM{ "%%get-bottom", ":d" };
-constexpr DescriptorConfig POINT_GET_X{ "%%get-x", ":d" };
-constexpr DescriptorConfig POINT_GET_Y{ "%%get-y", ":d" };
+constexpr DescriptorConfig INT_GET{ "toInt", ":i"};
+constexpr DescriptorConfig DOUBLE_GET{ "toDouble", ":d"};
+constexpr DescriptorConfig ARRAY_GET{ "$_set", "iY:"};
+constexpr DescriptorConfig RESOURCE_GET_ID{ "<get>id", ":l"};
+constexpr DescriptorConfig RESOURCE_GET_PARAMS{ "<get>params", ":C{escompat.Array}"};
+constexpr DescriptorConfig RESOURCE_GET_TYPE{ "<get>type", ":C{std.core.Int}"};
+constexpr DescriptorConfig COLOR_GET_ALPHA{ "<get>alpha", ":i" };
+constexpr DescriptorConfig COLOR_GET_RED{ "<get>red", ":i" };
+constexpr DescriptorConfig COLOR_GET_GREEN{ "<get>green", ":i" };
+constexpr DescriptorConfig COLOR_GET_BLUE{ "<get>blue", ":i" };
+constexpr DescriptorConfig RECT_GET_LEFT{ "<get>left", ":d" };
+constexpr DescriptorConfig RECT_GET_TOP{ "<get>top", ":d" };
+constexpr DescriptorConfig RECT_GET_RIGHT{ "<get>right", ":d" };
+constexpr DescriptorConfig RECT_GET_BOTTOM{ "<get>bottom", ":d" };
+constexpr DescriptorConfig POINT_GET_X{ "<get>x", ":d" };
+constexpr DescriptorConfig POINT_GET_Y{ "<get>y", ":d" };
+constexpr DescriptorConfig POINT3D_GET_X{ "<get>x", ":d"};
+constexpr DescriptorConfig POINT3D_GET_Y{ "<get>y", ":d"};
+constexpr DescriptorConfig POINT3D_GET_Z{ "<get>z", ":d"};
+constexpr DescriptorConfig RUN_BUFFER_GET_GLYPH{ "<get>glyph", ":i" };
+constexpr DescriptorConfig RUN_BUFFER_GET_POSITION_X{ "<get>positionX", ":d" };
+constexpr DescriptorConfig RUN_BUFFER_GET_POSITION_Y{ "<get>positionY", ":d" };
 }
 ani_class AniFindClass(ani_env* env, const char* descriptor)
 {
@@ -55,6 +77,23 @@ ani_class AniFindClass(ani_env* env, const char* descriptor)
     return static_cast<ani_class>(ref);
 }
 
+ani_enum AniFindEnum(ani_env* env, const char* descriptor)
+{
+    ani_enum enumType = nullptr;
+    ani_status status = env->FindEnum(descriptor, &enumType);
+    if (status != ANI_OK) {
+        ROSEN_LOGE("Failed to find enum: %{public}s, status %{public}d", descriptor, status);
+        return nullptr;
+    }
+    ani_ref ref = nullptr;
+    status = env->GlobalReference_Create(enumType, &ref);
+    if (status != ANI_OK) {
+        ROSEN_LOGE("Failed to create global reference for enum: %{public}s, status %{public}d", descriptor, status);
+        return nullptr;
+    }
+    return static_cast<ani_enum>(ref);
+}
+
 ani_method AniFindMethod(ani_env* env, ani_class cls, const DescriptorConfig& config)
 {
     if (cls == nullptr) {
@@ -62,18 +101,60 @@ ani_method AniFindMethod(ani_env* env, ani_class cls, const DescriptorConfig& co
         return nullptr;
     }
     ani_method method = nullptr;
-    ani_status status = env->Class_FindMethod(cls, std::string(config.methodDes).c_str(),
-        std::string(config.paramDes).c_str(), &method);
+    ani_status status = env->Class_FindMethod(cls, config.methodDes.data(), config.paramDes.data(), &method);
     if (status != ANI_OK) {
         ROSEN_LOGE("Failed to find method: %{public}s %{public}s, status %{public}d",
-            std::string(config.methodDes).c_str(), std::string(config.paramDes).c_str(), status);
+            config.methodDes.data(), config.paramDes.data(), status);
         return nullptr;
     }
     return method;
 }
 
+ani_field AniFindField(ani_env* env, ani_class cls)
+{
+    if (cls == nullptr) {
+        ROSEN_LOGE("Failed to find method: cls is null");
+        return nullptr;
+    }
+    ani_field field = nullptr;
+    ani_status status = env->Class_FindField(cls, NATIVE_OBJ, &field);
+    if (status != ANI_OK) {
+        ROSEN_LOGE("AniFindField  failed: findFiled nativeObj failed");
+        return nullptr;
+    }
+    return field;
+}
+
 void AniGlobalClass::Init(ani_env* env)
 {
+    intCls = AniFindClass(env, ANI_INT_STRING);
+    doubleCls = AniFindClass(env, ANI_DOUBLE_STRING);
+    strCls = AniFindClass(env, ANI_STRING_STRING);
+    arrayCls = AniFindClass(env, ANI_ARRAY_STRING);
+    businessErrorCls = AniFindClass(env, ANI_BUSINESS_ERROR_STRING);
+    resourceCls = AniFindClass(env, ANI_GLOBAL_RESOURCE_STRING);
+    brush = AniFindClass(env, ANI_CLASS_BRUSH_NAME);
+    samplingOptions = AniFindClass(env, ANI_CLASS_SAMPLING_OPTIONS_NAME);
+    canvas = AniFindClass(env, ANI_CLASS_CANVAS_NAME);
+    colorFilter = AniFindClass(env, ANI_CLASS_COLORFILTER_NAME);
+    pen = AniFindClass(env, ANI_CLASS_PEN_NAME);
+    typeface = AniFindClass(env, ANI_CLASS_TYPEFACE_NAME);
+    font = AniFindClass(env, ANI_CLASS_FONT_NAME);
+    lattice = AniFindClass(env, ANI_CLASS_ANI_LATTICE_NAME);
+    matrix = AniFindClass(env, ANI_CLASS_MATRIX_NAME);
+    maskFilter = AniFindClass(env, ANI_CLASS_MASKFILTER_NAME);
+    pathEffect = AniFindClass(env, ANI_CLASS_PATHEFFECT_NAME);
+    imageFilter = AniFindClass(env, ANI_CLASS_IMAGEFILTER_NAME);
+    pathIterator = AniFindClass(env, ANI_CLASS_PATH_ITERATOR_NAME);
+    path = AniFindClass(env, ANI_CLASS_PATH_NAME);
+    shaderEffect = AniFindClass(env, ANI_CLASS_SHADER_EFFECT_NAME);
+    shadowLayer = AniFindClass(env, ANI_CLASS_SHADOW_LAYER_NAME);
+    textBlob = AniFindClass(env, ANI_CLASS_TEXT_BLOB_NAME);
+    rectUtils = AniFindClass(env, ANI_CLASS_RECT_UTILS_NAME);
+    region = AniFindClass(env, ANI_CLASS_REGION_NAME);
+    roundRect = AniFindClass(env, ANI_CLASS_ROUND_RECT_NAME);
+    tool = AniFindClass(env, ANI_CLASS_TOOL_NAME);
+    typefaceArguments = AniFindClass(env, ANI_CLASS_TYPEFACE_ARGUMENTS_NAME);
     color = AniFindClass(env, ANI_CLASS_COLOR_NAME);
     fontMetrics = AniFindClass(env, ANI_CLASS_FONT_METRICS_NAME);
     point = AniFindClass(env, ANI_CLASS_POINT_NAME);
@@ -81,15 +162,43 @@ void AniGlobalClass::Init(ani_env* env)
     colorInterface = AniFindClass(env, ANI_INTERFACE_COLOR_NAME);
     pointInterface = AniFindClass(env, ANI_INTERFACE_POINT_NAME);
     rectInterface = AniFindClass(env, ANI_INTERFACE_RECT_NAME);
+    point3dInterface = AniFindClass(env, ANI_INTERFACE_POINT3D_NAME);
+    runBufferInterface = AniFindClass(env, ANI_INTERFACE_TEXT_BLOB_RUN_BUFFER_NAME);
+}
+
+void AniGlobalEnum::Init(ani_env* env)
+{
+    pathIteratorVerb = AniFindEnum(env, ANI_ENUM_PATH_ITERATOR_VERB);
+    fontHinting = AniFindEnum(env, ANI_FONT_HINTING_NAME);
+    fontEdging = AniFindEnum(env, ANI_FONT_EDGING_NAME);
+    capStyle = AniFindEnum(env, ANI_CLASS_CAP_STYLE_NAME);
+    joinStyle = AniFindEnum(env, ANI_CLASS_JOIN_STYLE_NAME);
+    colorEnum = AniFindEnum(env, ANI_COLOR_ENUM_STRING);
 }
 
 void AniGlobalMethod::Init(ani_env* env)
 {
+    intCtor = AniFindMethod(env, AniGlobalClass::GetInstance().intCls, INT_CTOR);
+    doubleCtor = AniFindMethod(env, AniGlobalClass::GetInstance().doubleCls, DOUBLE_CTOR);
+    canvasCtor = AniFindMethod(env, AniGlobalClass::GetInstance().canvas, CANVAS_CTOR);
+    colorFilterCtor = AniFindMethod(env, AniGlobalClass::GetInstance().colorFilter, COLOR_FILTER_CTOR);
+    matrixCtor = AniFindMethod(env, AniGlobalClass::GetInstance().matrix, MATRIX_CTOR);
+    pathCtor = AniFindMethod(env, AniGlobalClass::GetInstance().path, PATH_CTOR);
+    pathIteratorCtor = AniFindMethod(env, AniGlobalClass::GetInstance().pathIterator, PATH_ITERATOR_CTOR);
+    roundRectCtor = AniFindMethod(env, AniGlobalClass::GetInstance().roundRect, ROUND_RECT_CTOR);
+    typefaceCtor = AniFindMethod(env, AniGlobalClass::GetInstance().typeface, TYPEFACE_CTOR);
     colorCtor = AniFindMethod(env, AniGlobalClass::GetInstance().color, COLOR_CTOR);
     fontMetricsCtor = AniFindMethod(env, AniGlobalClass::GetInstance().fontMetrics, FONT_METRICS_CTOR);
     pointCtor = AniFindMethod(env, AniGlobalClass::GetInstance().point, POINT_CTOR);
     rectCtor = AniFindMethod(env, AniGlobalClass::GetInstance().rect, RECT_CTOR);
 
+    intGet = AniFindMethod(env, AniGlobalClass::GetInstance().intCls, INT_GET);
+    doubleGet = AniFindMethod(env, AniGlobalClass::GetInstance().doubleCls, DOUBLE_GET);
+    arraySet = AniFindMethod(env, AniGlobalClass::GetInstance().arrayCls, ARRAY_GET);
+    resourceGetId = AniFindMethod(env, AniGlobalClass::GetInstance().resourceCls, RESOURCE_GET_ID);
+    resourceGetParams = AniFindMethod(env, AniGlobalClass::GetInstance().resourceCls, RESOURCE_GET_PARAMS);
+    resourceGetType = AniFindMethod(env, AniGlobalClass::GetInstance().resourceCls, RESOURCE_GET_TYPE);
+
     colorGetAlpha = AniFindMethod(env, AniGlobalClass::GetInstance().colorInterface, COLOR_GET_ALPHA);
     colorGetRed = AniFindMethod(env, AniGlobalClass::GetInstance().colorInterface, COLOR_GET_RED);
     colorGetGreen = AniFindMethod(env, AniGlobalClass::GetInstance().colorInterface, COLOR_GET_GREEN);
@@ -100,14 +209,50 @@ void AniGlobalMethod::Init(ani_env* env)
     rectGetBottom = AniFindMethod(env, AniGlobalClass::GetInstance().rectInterface, RECT_GET_BOTTOM);
     pointGetX = AniFindMethod(env, AniGlobalClass::GetInstance().pointInterface, POINT_GET_X);
     pointGetY = AniFindMethod(env, AniGlobalClass::GetInstance().pointInterface, POINT_GET_Y);
+    point3dGetX = AniFindMethod(env, AniGlobalClass::GetInstance().point3dInterface, POINT3D_GET_X);
+    point3dGetY = AniFindMethod(env, AniGlobalClass::GetInstance().point3dInterface, POINT3D_GET_Y);
+    point3dGetZ = AniFindMethod(env, AniGlobalClass::GetInstance().point3dInterface, POINT3D_GET_Z);
+    runBufferGetGlyph = AniFindMethod(env,  AniGlobalClass::GetInstance().runBufferInterface, RUN_BUFFER_GET_GLYPH);
+    runBufferGetPositionX = AniFindMethod(
+        env, AniGlobalClass::GetInstance().runBufferInterface, RUN_BUFFER_GET_POSITION_X);
+    runBufferGetPositionY = AniFindMethod(
+        env, AniGlobalClass::GetInstance().runBufferInterface, RUN_BUFFER_GET_POSITION_Y);
+}
+
+void AniGlobalField::Init(ani_env* env)
+{
+    brushNativeObj = AniFindField(env, AniGlobalClass::GetInstance().brush);
+    samplingOptionsNativeObj = AniFindField(env, AniGlobalClass::GetInstance().samplingOptions);
+    canvasNativeObj = AniFindField(env, AniGlobalClass::GetInstance().canvas);
+    colorFilterNativeObj = AniFindField(env, AniGlobalClass::GetInstance().colorFilter);
+    penNativeObj = AniFindField(env, AniGlobalClass::GetInstance().pen);
+    typefaceNativeObj = AniFindField(env, AniGlobalClass::GetInstance().typeface);
+    fontNativeObj = AniFindField(env, AniGlobalClass::GetInstance().font);
+    latticeNativeObj = AniFindField(env, AniGlobalClass::GetInstance().lattice);
+    matrixNativeObj = AniFindField(env, AniGlobalClass::GetInstance().matrix);
+    maskFilterNativeObj = AniFindField(env, AniGlobalClass::GetInstance().maskFilter);
+    pathEffectNativeObj = AniFindField(env, AniGlobalClass::GetInstance().pathEffect);
+    imageFilterNativeObj = AniFindField(env, AniGlobalClass::GetInstance().imageFilter);
+    pathIteratorNativeObj = AniFindField(env, AniGlobalClass::GetInstance().pathIterator);
+    pathNativeObj = AniFindField(env, AniGlobalClass::GetInstance().path);
+    shaderEffectNativeObj = AniFindField(env, AniGlobalClass::GetInstance().shaderEffect);
+    shadowLayerNativeObj = AniFindField(env, AniGlobalClass::GetInstance().shadowLayer);
+    textBlobNativeObj = AniFindField(env, AniGlobalClass::GetInstance().textBlob);
+    rectUtilsNativeObj = AniFindField(env, AniGlobalClass::GetInstance().rectUtils);
+    regionNativeObj = AniFindField(env, AniGlobalClass::GetInstance().region);
+    roundRectNativeObj = AniFindField(env, AniGlobalClass::GetInstance().roundRect);
+    toolNativeObj = AniFindField(env, AniGlobalClass::GetInstance().tool);
+    typefaceArgumentsNativeObj = AniFindField(env, AniGlobalClass::GetInstance().typefaceArguments);
 }
 
 ani_status InitAniGlobalRef(ani_env* env)
 {
     AniGlobalClass::GetInstance().Init(env);
+    AniGlobalEnum::GetInstance().Init(env);
     AniGlobalMethod::GetInstance().Init(env);
+    AniGlobalField::GetInstance().Init(env);
     return ANI_OK;
 }
 } // namespace Drawing
 } // namespace Rosen
-} // namespace OHOS
\ No newline at end of file
+} // namespace OHOSfailed
\ No newline at end of file
diff --git a/interfaces/kits/ani/drawing/ani_drawing_cache_utils.h b/interfaces/kits/ani/drawing/ani_drawing_cache_utils.h
index 235a64cd70..120527d336 100644
--- a/interfaces/kits/ani/drawing/ani_drawing_cache_utils.h
+++ b/interfaces/kits/ani/drawing/ani_drawing_cache_utils.h
@@ -35,6 +35,8 @@ ani_class AniFindClass(ani_env* env, const char* descriptor);
 
 ani_method AniFindMethod(ani_env* env, ani_class cls, const DescriptorConfig& config);
 
+ani_enum AniFindEnum(ani_env* env, const char* descriptor);
+
 class AniGlobalClass {
 public:
     static AniGlobalClass& GetInstance()
@@ -44,7 +46,35 @@ public:
     }
 
     void Init(ani_env* env);
-
+    ani_class intCls;
+    ani_class doubleCls;
+    ani_class strCls;
+    ani_class arrayCls;
+    ani_class businessErrorCls;
+    ani_class resourceCls;
+
+    ani_class brush;
+    ani_class samplingOptions;
+    ani_class canvas;
+    ani_class colorFilter;
+    ani_class pen;
+    ani_class typeface;
+    ani_class font;
+    ani_class lattice;
+    ani_class matrix;
+    ani_class maskFilter;
+    ani_class pathEffect;
+    ani_class imageFilter;
+    ani_class pathIterator;
+    ani_class path;
+    ani_class shaderEffect;
+    ani_class shadowLayer;
+    ani_class textBlob;
+    ani_class rectUtils;
+    ani_class region;
+    ani_class roundRect;
+    ani_class tool;
+    ani_class typefaceArguments;
     ani_class fontMetrics;
     ani_class point;
     ani_class rect;
@@ -52,6 +82,9 @@ public:
     ani_class colorInterface;
     ani_class pointInterface;
     ani_class rectInterface;
+    ani_class point3dInterface;
+    ani_class runBufferInterface;
+
 
 private:
     AniGlobalClass() = default;
@@ -62,6 +95,32 @@ private:
     AniGlobalClass& operator=(AniGlobalClass&&) = delete;
 };
 
+class AniGlobalEnum {
+public:
+    static AniGlobalEnum& GetInstance()
+    {
+        static AniGlobalEnum instance;
+        return instance;
+    }
+
+    void Init(ani_env* env);
+
+    ani_enum pathIteratorVerb;
+    ani_enum fontHinting;
+    ani_enum fontEdging;
+    ani_enum capStyle;
+    ani_enum joinStyle;
+    ani_enum colorEnum;
+
+private:
+    AniGlobalEnum() = default;
+    ~AniGlobalEnum() = default;
+    AniGlobalEnum(const AniGlobalEnum&) = delete;
+    AniGlobalEnum& operator=(const AniGlobalEnum&) = delete;
+    AniGlobalEnum(AniGlobalEnum&&) = delete;
+    AniGlobalEnum& operator=(AniGlobalEnum&&) = delete;
+};
+
 class AniGlobalMethod {
 public:
     static AniGlobalMethod& GetInstance()
@@ -72,11 +131,27 @@ public:
 
     void Init(ani_env* env);
 
+    ani_method intCtor;
+    ani_method doubleCtor;
+    ani_method canvasCtor;
+    ani_method colorFilterCtor;
+    ani_method matrixCtor;
+    ani_method pathCtor;
+    ani_method pathIteratorCtor;
+    ani_method roundRectCtor;
+    ani_method typefaceCtor;
     ani_method fontMetricsCtor;
     ani_method pointCtor;
     ani_method rectCtor;
     ani_method colorCtor;
 
+    ani_method intGet;
+    ani_method doubleGet;
+    ani_method arraySet;
+    ani_method resourceGetId;
+    ani_method resourceGetParams;
+    ani_method resourceGetType;
+
     ani_method colorGetAlpha;
     ani_method colorGetRed;
     ani_method colorGetGreen;
@@ -87,6 +162,12 @@ public:
     ani_method rectGetBottom;
     ani_method pointGetX;
     ani_method pointGetY;
+    ani_method point3dGetX;
+    ani_method point3dGetY;
+    ani_method point3dGetZ;
+    ani_method runBufferGetGlyph;
+    ani_method runBufferGetPositionX;
+    ani_method runBufferGetPositionY;
 
 private:
     AniGlobalMethod() = default;
@@ -97,6 +178,48 @@ private:
     AniGlobalMethod& operator=(AniGlobalMethod&&) = delete;
 };
 
+class AniGlobalField {
+public:
+    static AniGlobalField& GetInstance()
+    {
+        static AniGlobalField instance;
+        return instance;
+    }
+
+    void Init(ani_env* env);
+
+    ani_field brushNativeObj;
+    ani_field samplingOptionsNativeObj;
+    ani_field canvasNativeObj;
+    ani_field colorFilterNativeObj;
+    ani_field penNativeObj;
+    ani_field typefaceNativeObj;
+    ani_field fontNativeObj;
+    ani_field latticeNativeObj;
+    ani_field matrixNativeObj;
+    ani_field maskFilterNativeObj;
+    ani_field pathEffectNativeObj;
+    ani_field imageFilterNativeObj;
+    ani_field pathIteratorNativeObj;
+    ani_field pathNativeObj;
+    ani_field shaderEffectNativeObj;
+    ani_field shadowLayerNativeObj;
+    ani_field textBlobNativeObj;
+    ani_field rectUtilsNativeObj;
+    ani_field regionNativeObj;
+    ani_field roundRectNativeObj;
+    ani_field toolNativeObj;
+    ani_field typefaceArgumentsNativeObj;
+
+private:
+    AniGlobalField() = default;
+    ~AniGlobalField() = default;
+    AniGlobalField(const AniGlobalField&) = delete;
+    AniGlobalField& operator=(const AniGlobalField&) = delete;
+    AniGlobalField(AniGlobalField&&) = delete;
+    AniGlobalField& operator=(AniGlobalField&&) = delete;
+};
+
 } // namespace Drawing
 } // namespace Rosen
 } // namespace OHOS
diff --git a/interfaces/kits/ani/drawing/ani_drawing_common.h b/interfaces/kits/ani/drawing/ani_drawing_common.h
index 9b505d7d56..5df5a11ab8 100644
--- a/interfaces/kits/ani/drawing/ani_drawing_common.h
+++ b/interfaces/kits/ani/drawing/ani_drawing_common.h
@@ -16,22 +16,52 @@
 #ifndef OHOS_ANI_DRAWING_COMMON_H
 #define OHOS_ANI_DRAWING_COMMON_H
 
+constexpr const char* NATIVE_OBJ = "nativeObj";
+
 constexpr const char* ANI_STRING_STRING = "std.core.String";
 constexpr const char* ANI_DOUBLE_STRING = "std.core.Double";
 constexpr const char* ANI_INT_STRING = "std.core.Int";
 constexpr const char* ANI_BUSINESS_ERROR_STRING = "@ohos.base.BusinessError";
+constexpr const char* ANI_ARRAY_STRING = "escompat.Array";
+constexpr const char* ANI_GLOBAL_RESOURCE_STRING = "global.resource.Resource";
+constexpr const char* ANI_COLOR_ENUM_STRING = "arkui.component.enums.Color";
 
 constexpr const char* ANI_CLASS_MATRIX_NAME = "@ohos.graphics.drawing.drawing.Matrix";
 constexpr const char* ANI_CLASS_COLORFILTER_NAME = "@ohos.graphics.drawing.drawing.ColorFilter";
 constexpr const char* ANI_CLASS_PATH_NAME = "@ohos.graphics.drawing.drawing.Path";
+constexpr const char* ANI_CLASS_BRUSH_NAME = "@ohos.graphics.drawing.drawing.Brush";
+constexpr const char* ANI_CLASS_CANVAS_NAME = "@ohos.graphics.drawing.drawing.Canvas";
+constexpr const char* ANI_CLASS_FONT_NAME = "@ohos.graphics.drawing.drawing.Font";
+constexpr const char* ANI_FONT_HINTING_NAME = "@ohos.graphics.drawing.drawing.FontHinting";
+constexpr const char* ANI_FONT_EDGING_NAME = "@ohos.graphics.drawing.drawing.FontEdging";
+constexpr const char* ANI_CLASS_IMAGEFILTER_NAME = "@ohos.graphics.drawing.drawing.ImageFilter";
+constexpr const char* ANI_CLASS_ANI_LATTICE_NAME = "@ohos.graphics.drawing.drawing.Lattice";
+constexpr const char* ANI_CLASS_MASKFILTER_NAME = "@ohos.graphics.drawing.drawing.MaskFilter";
+constexpr const char* ANI_CLASS_PATHEFFECT_NAME = "@ohos.graphics.drawing.drawing.PathEffect";
+constexpr const char* ANI_CLASS_PATH_ITERATOR_NAME = "@ohos.graphics.drawing.drawing.PathIterator";
+constexpr const char* ANI_ENUM_PATH_ITERATOR_VERB = "@ohos.graphics.drawing.drawing.PathIteratorVerb";
+constexpr const char* ANI_CLASS_PEN_NAME = "@ohos.graphics.drawing.drawing.Pen";
+constexpr const char* ANI_CLASS_JOIN_STYLE_NAME = "@ohos.graphics.drawing.drawing.JoinStyle";
+constexpr const char* ANI_CLASS_CAP_STYLE_NAME = "@ohos.graphics.drawing.drawing.CapStyle";
+constexpr const char* ANI_CLASS_REGION_NAME = "@ohos.graphics.drawing.drawing.Region";
+constexpr const char* ANI_CLASS_ROUND_RECT_NAME = "@ohos.graphics.drawing.drawing.RoundRect";
+constexpr const char* ANI_CLASS_SAMPLING_OPTIONS_NAME = "@ohos.graphics.drawing.drawing.SamplingOptions";
+constexpr const char* ANI_CLASS_SHADER_EFFECT_NAME = "@ohos.graphics.drawing.drawing.ShaderEffect";
+constexpr const char* ANI_CLASS_SHADOW_LAYER_NAME = "@ohos.graphics.drawing.drawing.ShadowLayer";
+constexpr const char* ANI_CLASS_TEXT_BLOB_NAME = "@ohos.graphics.drawing.drawing.TextBlob";
+constexpr const char* ANI_CLASS_TYPEFACE_NAME = "@ohos.graphics.drawing.drawing.Typeface";
+constexpr const char* ANI_CLASS_TYPEFACE_ARGUMENTS_NAME = "@ohos.graphics.drawing.drawing.TypefaceArguments";
 constexpr const char* ANI_CLASS_COLOR_NAME = "@ohos.graphics.common2D.common2D.ColorInternal";
 constexpr const char* ANI_CLASS_FONT_METRICS_NAME = "@ohos.graphics.drawing.drawing.FontMetricsInner";
 constexpr const char* ANI_CLASS_POINT_NAME = "@ohos.graphics.common2D.common2D.PointInternal";
 constexpr const char* ANI_CLASS_RECT_NAME = "@ohos.graphics.common2D.common2D.RectInternal";
+constexpr const char* ANI_CLASS_RECT_UTILS_NAME = "@ohos.graphics.drawing.drawing.RectUtils";
+constexpr const char* ANI_CLASS_TOOL_NAME = "@ohos.graphics.drawing.drawing.Tool";
 
 constexpr const char* ANI_INTERFACE_COLOR_NAME = "@ohos.graphics.common2D.common2D.Color";
 constexpr const char* ANI_INTERFACE_POINT_NAME = "@ohos.graphics.common2D.common2D.Point";
 constexpr const char* ANI_INTERFACE_RECT_NAME = "@ohos.graphics.common2D.common2D.Rect";
 constexpr const char* ANI_INTERFACE_FONT_METRICS_NAME = "@ohos.graphics.drawing.drawing.FontMetrics";
-
+constexpr const char* ANI_INTERFACE_POINT3D_NAME = "@ohos.graphics.common2D.common2D.Point3d";
+constexpr const char* ANI_INTERFACE_TEXT_BLOB_RUN_BUFFER_NAME = "@ohos.graphics.drawing.drawing.TextBlobRunBuffer";
 #endif // OHOS_ANI_DRAWING_COMMON_H
\ No newline at end of file
diff --git a/interfaces/kits/ani/drawing/ani_drawing_utils.cpp b/interfaces/kits/ani/drawing/ani_drawing_utils.cpp
index aa04fc4f81..2ce0d670b3 100644
--- a/interfaces/kits/ani/drawing/ani_drawing_utils.cpp
+++ b/interfaces/kits/ani/drawing/ani_drawing_utils.cpp
@@ -89,14 +89,13 @@ ani_status CreateStdStringUtf16(ani_env* env, const ani_string& str, std::u16str
 
 ani_status CreateBusinessError(ani_env* env, int32_t error, const char* message, ani_object& err)
 {
-    ani_class aniClass;
-    ani_status status = env->FindClass("@ohos.base.BusinessError", &aniClass);
-    if (status != ANI_OK) {
-        ROSEN_LOGE("Failed to find class, status:%{public}d", static_cast<int32_t>(status));
-        return status;
+    ani_class aniClass = AniGlobalClass::GetInstance().businessErrorCls;
+    if (aniClass == nullptr) {
+        ROSEN_LOGE("Failed to find class %{public}s", ANI_BUSINESS_ERROR_STRING);
+        return ANI_NOT_FOUND;
     }
     ani_method aniCtor;
-    status = env->Class_FindMethod(aniClass, "<ctor>", "C{std.core.String}C{escompat.ErrorOptions}:", &aniCtor);
+    ani_status status = env->Class_FindMethod(aniClass, "<ctor>", "C{std.core.String}C{escompat.ErrorOptions}:", &aniCtor);
     if (status != ANI_OK) {
         ROSEN_LOGE("Failed to find ctor, status:%{public}d", static_cast<int32_t>(status));
         return status;
@@ -167,17 +166,16 @@ bool GetColorQuadFromColorObj(ani_env* env, ani_object obj, Drawing::ColorQuad &
 
 bool GetColorQuadFromParam(ani_env* env, ani_object obj, Drawing::ColorQuad &color)
 {
-    ani_class intClass;
-    ani_status status = env->FindClass(ANI_INT_STRING, &intClass);
-    if (status != ANI_OK) {
-        ROSEN_LOGE("Failed to find class, status:%{public}d", static_cast<int32_t>(status));
+    ani_class intClass = AniGlobalClass::GetInstance().intCls;
+    if (intClass == nullptr) {
+        ROSEN_LOGE("Failed to find class %{public}s", ANI_INT_STRING);
         return false;
     }
     ani_boolean isInt;
     env->Object_InstanceOf(obj, intClass, &isInt);
     if (isInt) {
         ani_int aniColor;
-        if (ANI_OK != env->Object_CallMethodByName_Int(obj, "toInt", nullptr, &aniColor)) {
+        if (ANI_OK != env->Object_CallMethod_Int(obj, AniGlobalMethod::GetInstance().intGet, &aniColor)) {
             ROSEN_LOGE("GetColorQuadFromParam failed by int value");
             return false;
         }
@@ -190,7 +188,7 @@ bool GetColorQuadFromParam(ani_env* env, ani_object obj, Drawing::ColorQuad &col
 
 ani_status CreateColorObj(ani_env* env, const Drawing::Color& color, ani_object& obj)
 {
-    obj = CreateAniObjectWithCls(env, AniGlobalClass::GetInstance().color, AniGlobalMethod::GetInstance().colorCtor,
+    obj = CreateAniObject(env, AniGlobalClass::GetInstance().color, AniGlobalMethod::GetInstance().colorCtor,
         ani_int(color.GetAlpha()),
         ani_int(color.GetRed()),
         ani_int(color.GetGreen()),
@@ -199,15 +197,6 @@ ani_status CreateColorObj(ani_env* env, const Drawing::Color& color, ani_object&
     return ANI_OK;
 }
 
-ani_status GetRectPropertyValue(ani_env* env, ani_object obj, ani_class rectClass, const RectPropertyConfig& config)
-{
-    if ((config.method || env->Class_FindMethod(rectClass, config.methodName, ":d", &config.method) == ANI_OK) &&
-        env->Object_CallMethod_Double(obj, config.method, &config.result) == ANI_OK) {
-        return ANI_OK;
-    }
-    return env->Object_GetPropertyByName_Double(obj, config.propertyName, &config.result);
-}
-
 bool GetRectFromAniRectObj(ani_env* env, ani_object obj, Drawing::Rect& rect)
 {
     ani_class rectCls = AniGlobalClass::GetInstance().rectInterface;
@@ -251,7 +240,7 @@ bool GetRectFromAniRectObj(ani_env* env, ani_object obj, Drawing::Rect& rect)
 
 ani_status CreateRectObj(ani_env* env, const Drawing::Rect& rect, ani_object& obj)
 {
-    obj = CreateAniObjectWithCls(env, AniGlobalClass::GetInstance().rect, AniGlobalMethod::GetInstance().rectCtor,
+    obj = CreateAniObject(env, AniGlobalClass::GetInstance().rect, AniGlobalMethod::GetInstance().rectCtor,
         ani_double(rect.left_),
         ani_double(rect.top_),
         ani_double(rect.right_),
@@ -262,15 +251,33 @@ ani_status CreateRectObj(ani_env* env, const Drawing::Rect& rect, ani_object& ob
 
 ani_status GetPointFromPointObj(ani_env* env, ani_object obj, Drawing::Point& point)
 {
+    ani_class pointCls  = AniGlobalClass::GetInstance().pointInterface;
+    if (pointCls == nullptr) {
+        ROSEN_LOGE("Failed to find class %{public}s", ANI_INTERFACE_POINT_NAME);
+        return ANI_NOT_FOUND;
+    }
+    ani_boolean isPoint;
+    env->Object_InstanceOf(obj, pointCls, &isPoint);
+    if (!isPoint) {
+        return ANI_ERROR;
+    }
+
+    ani_method pointGetX = AniGlobalMethod::GetInstance().pointGetX;
+    ani_method pointGetY = AniGlobalMethod::GetInstance().pointGetY;
+    if (pointGetX == nullptr || pointGetY == nullptr) {
+        ROSEN_LOGE("GetPointFromPointObj failed by cls method is null");
+        return ANI_ERROR;
+    }
+
     ani_double x = 0;
-    ani_status ret = env->Object_CallMethod_Double(obj, AniGlobalMethod::GetInstance().pointGetX, &x);
+    ani_status ret = env->Object_CallMethod_Double(obj, pointGetX, &x);
     if (ret != ANI_OK) {
         ROSEN_LOGE("Param x is invalid, ret %{public}d", ret);
         return ret;
     }
 
     ani_double y = 0;
-    ret = env->Object_CallMethod_Double(obj, AniGlobalMethod::GetInstance().pointGetY, &y);
+    ret = env->Object_CallMethod_Double(obj, pointGetY, &y);
     if (ret != ANI_OK) {
         ROSEN_LOGE("Param y is invalid, ret %{public}d", ret);
         return ret;
@@ -282,7 +289,7 @@ ani_status GetPointFromPointObj(ani_env* env, ani_object obj, Drawing::Point& po
 
 ani_status CreatePointObj(ani_env* env, const Drawing::Point& point, ani_object& obj)
 {
-    obj = CreateAniObjectWithCls(env, AniGlobalClass::GetInstance().point, AniGlobalMethod::GetInstance().pointCtor,
+    obj = CreateAniObject(env, AniGlobalClass::GetInstance().point, AniGlobalMethod::GetInstance().pointCtor,
         ani_double(point.GetX()),
         ani_double(point.GetY())
     );
@@ -291,7 +298,7 @@ ani_status CreatePointObj(ani_env* env, const Drawing::Point& point, ani_object&
 
 bool CreatePointObjAndCheck(ani_env* env, const Drawing::Point& point, ani_object& obj)
 {
-    obj = CreateAniObjectWithCls(env, AniGlobalClass::GetInstance().point, AniGlobalMethod::GetInstance().pointCtor,
+    obj = CreateAniObject(env, AniGlobalClass::GetInstance().point, AniGlobalMethod::GetInstance().pointCtor,
         ani_double(point.GetX()),
         ani_double(point.GetY())
     );
@@ -300,17 +307,16 @@ bool CreatePointObjAndCheck(ani_env* env, const Drawing::Point& point, ani_objec
     return !isUndefined;
 }
 
-bool ConvertFromAniPointsArray(ani_env* env, ani_object aniPointArray, Drawing::Point* points, uint32_t pointSize)
+bool ConvertFromAniPointsArray(ani_env* env, ani_array aniPointArray, Drawing::Point* points, uint32_t pointSize)
 {
     for (uint32_t i = 0; i < pointSize; i++) {
         ani_ref pointRef;
         Drawing::Point point;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(
-            aniPointArray, "$_get", "i:Y", &pointRef, (ani_int)i)) {
+        if (ANI_OK != env->Array_Get(aniPointArray, (ani_int)i, &pointRef)) {
             ROSEN_LOGE("aniPointArray get pointRef failed.");
             return false;
         }
-        if (!GetPointFromAniPointObj(env, static_cast<ani_object>(pointRef), point)) {
+        if (GetPointFromPointObj(env, static_cast<ani_object>(pointRef), point) != ANI_OK) {
             ROSEN_LOGE("pointRef is invalid");
             return false;
         }
@@ -321,11 +327,9 @@ bool ConvertFromAniPointsArray(ani_env* env, ani_object aniPointArray, Drawing::
 
 bool GetPoint3FromPoint3dObj(ani_env* env, ani_object obj, Drawing::Point3& point3d)
 {
-    ani_class point3dClass;
-    ani_status status = env->FindClass("@ohos.graphics.common2D.common2D.Point3d", &point3dClass);
-    if (status != ANI_OK) {
-        ROSEN_LOGE("[ANI] can't find class @ohos.graphics.common2D.common2D.Point3d, status = %{public}d",
-            static_cast<int>(status));
+    ani_class point3dClass = AniGlobalClass::GetInstance().point3dInterface;
+    if (point3dClass == nullptr) {
+        ROSEN_LOGE("[ANI] can't find class %{public}s", ANI_INTERFACE_POINT3D_NAME);
         return false;
     }
     ani_boolean isPoint3dClass;
@@ -334,23 +338,31 @@ bool GetPoint3FromPoint3dObj(ani_env* env, ani_object obj, Drawing::Point3& poin
         ROSEN_LOGE("Get point3d object failed");
         return false;
     }
+    ani_method point3dGetX = AniGlobalMethod::GetInstance().point3dGetX;
+    ani_method point3dGetY = AniGlobalMethod::GetInstance().point3dGetY;
+    ani_method point3dGetZ = AniGlobalMethod::GetInstance().point3dGetZ;
+
+    if (point3dGetX == nullptr || point3dGetY == nullptr || point3dGetZ == nullptr) {
+        ROSEN_LOGE("GetPoint3FromPoint3dObj failed by cls method is null");
+        return ANI_ERROR;
+    }
 
     ani_double x = 0;
-    ani_status ret = env->Object_GetPropertyByName_Double(obj, "x", &x);
+    ani_status ret = env->Object_CallMethod_Double(obj, point3dGetX, &x);
     if (ret != ANI_OK) {
         ROSEN_LOGE("Param x is invalid, ret %{public}d", ret);
         return false;
     }
 
     ani_double y = 0;
-    ret = env->Object_GetPropertyByName_Double(obj, "y", &y);
+    ret = env->Object_CallMethod_Double(obj, point3dGetY, &y);
     if (ret != ANI_OK) {
         ROSEN_LOGE("Param y is invalid, ret %{public}d", ret);
         return false;
     }
 
     ani_double z = 0;
-    ret = env->Object_GetPropertyByName_Double(obj, "z", &z);
+    ret = env->Object_CallMethod_Double(obj, point3dGetZ, &z);
     if (ret != ANI_OK) {
         ROSEN_LOGE("Param z is invalid, ret %{public}d", ret);
         return false;
@@ -367,43 +379,16 @@ ani_object CreateAniUndefined(ani_env* env)
     return static_cast<ani_object>(aniRef);
 }
 
-ani_object CreateAniObjectWithCls(ani_env* env, ani_class cls, const ani_method ctor, ...)
+ani_object CreateAniObject(ani_env* env, const ani_class cls, const ani_method ctor, ...)
 {
     if (cls == nullptr || ctor == nullptr) {
-        ROSEN_LOGE("[Drawing] CreateAniObjectWithCls cls or ctor is null");
+        ROSEN_LOGE("[Drawing] CreateAniObject cls or ctor is null");
         return CreateAniUndefined(env);
     }
     ani_object aniObject;
     va_list args;
     va_start(args, ctor);
     if (env->Object_New_V(cls, ctor, &aniObject, args) != ANI_OK) {
-        ROSEN_LOGE("[Drawing] CreateAniObjectWithCls Object_New failed");
-        va_end(args);
-        return CreateAniUndefined(env);
-    }
-    va_end(args);
-
-    return aniObject;
-}
-
-ani_object CreateAniObject(ani_env* env, const char* className, const char* methodSig, ...)
-{
-    ani_class aniClass;
-    if (env->FindClass(className, &aniClass) != ANI_OK) {
-        ROSEN_LOGE("[Drawing] CreateAniObject FindClass failed");
-        return CreateAniUndefined(env);
-    }
-
-    ani_method aniConstructor;
-    if (env->Class_FindMethod(aniClass, "<ctor>", methodSig, &aniConstructor) != ANI_OK) {
-        ROSEN_LOGE("[Drawing] CreateAniObject Class_FindMethod failed");
-        return CreateAniUndefined(env);
-    }
-
-    ani_object aniObject;
-    va_list args;
-    va_start(args, methodSig);
-    if (env->Object_New_V(aniClass, aniConstructor, &aniObject, args) != ANI_OK) {
         ROSEN_LOGE("[Drawing] CreateAniObject Object_New failed");
         va_end(args);
         return CreateAniUndefined(env);
@@ -420,60 +405,46 @@ ani_object CreateAniNull(ani_env* env)
     return static_cast<ani_object>(aniRef);
 }
 
-bool GetPointFromAniPointObj(ani_env* env, ani_object obj, Drawing::Point& point)
+bool CreateAniEnumByEnumIndex(ani_env* env, const ani_enum enumType, ani_size index, ani_enum_item& enumItem)
 {
-    ani_class pointClass;
-    ani_status status = env->FindClass("@ohos.graphics.common2D.common2D.Point", &pointClass);
-    if (status != ANI_OK) {
-        ROSEN_LOGE("Failed to find class, status:%{public}d", static_cast<int32_t>(status));
+    if (enumType == nullptr) {
+        ROSEN_LOGE("CreateAniEnumByEnumIndex enumType is null.");
         return false;
     }
-    ani_boolean isPointClass;
-    env->Object_InstanceOf(obj, pointClass, &isPointClass);
-    if (!isPointClass) {
-        ROSEN_LOGE("object is not a point obj");
+    ani_status ret = env->Enum_GetEnumItemByIndex(enumType, index, &enumItem);
+    if (ret != ANI_OK) {
+        ROSEN_LOGE("CreateAniEnumByEnumIndex get enum by index failed. ret: %{public}d.", ret);
         return false;
     }
 
-    ani_double x = 0.0;
-    ani_double y = 0.0;
-    if ((env->Object_GetPropertyByName_Double(obj, "x", &x) != ANI_OK) ||
-        (env->Object_GetPropertyByName_Double(obj, "y", &y) != ANI_OK)) {
-        ROSEN_LOGE("GetPointFromAniPointObj failed");
-        return false;
-    }
-    point.SetX(x);
-    point.SetY(y);
     return true;
 }
 
-bool CreateAniEnumByEnumIndex(ani_env* env, const char* enumDescripter, ani_size index, ani_enum_item& enumItem)
+bool CreateAniEnumByEnumName(ani_env* env, const ani_enum enumType, const std::string itemName, ani_enum_item& enumItem)
 {
-    ani_enum enumType;
-    ani_status ret = env->FindEnum(enumDescripter, &enumType);
-    if (ret != ANI_OK) {
-        ROSEN_LOGE("CreateAniEnum find enum failed. ret: %{public}d. %{public}s", ret, enumDescripter);
+    if (enumType == nullptr) {
+        ROSEN_LOGE("CreateAniEnumByEnumName enumType is null.");
         return false;
     }
-    ret = env->Enum_GetEnumItemByIndex(enumType, index, &enumItem);
+    ani_status ret = env->Enum_GetEnumItemByName(enumType, itemName.c_str(), &enumItem);
     if (ret != ANI_OK) {
-        ROSEN_LOGE("CreateAniEnum get enum by index failed. ret: %{public}d.", ret);
+        ROSEN_LOGE("CreateAniEnumByEnumName get enum by index failed. ret: %{public}d.", ret);
         return false;
     }
 
     return true;
 }
 
-bool SetPointToAniPointArrayWithIndex(ani_env* env, Drawing::Point& point, ani_object& pointArray, uint32_t index)
+bool SetPointToAniPointArrayWithIndex(ani_env* env, Drawing::Point& point, ani_array& pointArray, uint32_t index)
 {
     ani_object pointObj;
     if (!CreatePointObjAndCheck(env, point, pointObj)) {
         ROSEN_LOGE("AniPathIterator::Next Set pointObj from point failed.");
         return false;
     }
-    ani_status ret = env->Object_CallMethodByName_Void(pointArray, "$_set", "iY:", index, pointObj);
+    ani_status ret = env->Object_CallMethod_Void(pointArray, AniGlobalMethod::GetInstance().arraySet, index, pointObj);
     if (ret != ANI_OK) {
-        ROSEN_LOGE("AniPathIterator::Next SObject_CallMethodByName_Void  $_set Faild. ret: %{public}d", ret);
+        ROSEN_LOGE("AniPathIterator::Next Object_CallMethod_Void arraySet Faild. ret: %{public}d", ret);
         return false;
     }
     return true;
@@ -533,8 +504,8 @@ std::shared_ptr<FontMgr> GetFontMgr(std::shared_ptr<Font> font)
 
 ani_object CreateAniArrayWithSize(ani_env* env, size_t size)
 {
-    ani_class arrayCls;
-    if (env->FindClass("escompat.Array", &arrayCls) != ANI_OK) {
+    ani_class arrayCls = AniGlobalClass::GetInstance().arrayCls;
+    if (arrayCls == nullptr) {
         ROSEN_LOGE("Failed to findClass escompat.Array");
         return CreateAniUndefined(env);
     }
diff --git a/interfaces/kits/ani/drawing/ani_drawing_utils.h b/interfaces/kits/ani/drawing/ani_drawing_utils.h
index 40cb03bfe4..74cb2cbb71 100644
--- a/interfaces/kits/ani/drawing/ani_drawing_utils.h
+++ b/interfaces/kits/ani/drawing/ani_drawing_utils.h
@@ -50,7 +50,6 @@ struct RectPropertyConfig {
     ani_double& result;
 };
 
-constexpr char NATIVE_OBJ[] = "nativeObj";
 constexpr size_t ARGC_ZERO = 0;
 constexpr size_t ARGC_ONE = 1;
 constexpr size_t ARGC_TWO = 2;
@@ -92,11 +91,16 @@ inline std::string CreateStdString(ani_env* env, ani_string aniStr)
 ani_status CreateStdStringUtf16(ani_env* env, const ani_string& str, std::u16string& utf16Str);
 
 template<typename T>
-T* GetNativeFromObj(ani_env* env, ani_object obj)
+T* GetNativeFromObj(ani_env* env, ani_object obj, ani_field nativeObjField)
 {
+    if (nativeObjField == nullptr) {
+        ROSEN_LOGE("nativeObjField is null");
+        return nullptr;
+    }
     ani_long nativeObj {};
-    if (env->Object_GetFieldByName_Long(obj, NATIVE_OBJ, &nativeObj) != ANI_OK) {
-        ROSEN_LOGE("[ANI] Object_GetField_Long fetch failed");
+    ani_status ret = env->Object_GetField_Long(obj, nativeObjField, &nativeObj);
+    if (ret != ANI_OK) {
+        ROSEN_LOGE("Failed to get native obj, ret %{public}d", ret);
         return nullptr;
     }
     T *object = reinterpret_cast<T*>(nativeObj);
@@ -109,15 +113,13 @@ T* GetNativeFromObj(ani_env* env, ani_object obj)
 
 ani_object CreateAniUndefined(ani_env* env);
 
-ani_object CreateAniObjectWithCls(ani_env* env, ani_class cls, const ani_method ctor, ...);
-
-ani_object CreateAniObject(ani_env* env, const char* className, const char* methodSig, ...);
+ani_object CreateAniObject(ani_env* env, const ani_class cls, const ani_method ctor, ...);
 
 ani_object CreateAniNull(ani_env* env);
 
-bool CreateAniEnumByEnumIndex(ani_env* env, const char* enumDescripter, ani_size index, ani_enum_item& enumItem);
+bool CreateAniEnumByEnumIndex(ani_env* env, const ani_enum enumType, ani_size index, ani_enum_item& enumItem);
 
-bool GetPointFromAniPointObj(ani_env* env, ani_object obj, Drawing::Point& point);
+bool CreateAniEnumByEnumName(ani_env* env, const ani_enum enumType, const std::string itemName, ani_enum_item& enumItem);
 
 template<typename T>
 ani_object CreateAniObjectStatic(ani_env* env, const char* className, T* obj)
@@ -157,8 +159,6 @@ ani_object CreateAniObjectStatic(ani_env* env, const char* className, T* obj)
     return aniObject;
 }
 
-bool GetPointFromAniPointObj(ani_env* env, ani_object obj, Drawing::Point& point);
-
 ani_object CreateAniArrayWithSize(ani_env* env, size_t size);
 
 bool GetColorQuadFromParam(ani_env* env, ani_object obj, Drawing::ColorQuad &color);
@@ -173,7 +173,7 @@ ani_status CreateRectObj(ani_env* env, const Drawing::Rect& rect, ani_object& ob
 
 ani_status GetPointFromPointObj(ani_env* env, ani_object obj, Drawing::Point& point);
 
-bool ConvertFromAniPointsArray(ani_env* env, ani_object aniPointArray, Drawing::Point* points, uint32_t pointSize);
+bool ConvertFromAniPointsArray(ani_env* env, ani_array aniPointArray, Drawing::Point* points, uint32_t pointSize);
 
 ani_status CreatePointObj(ani_env* env, const Drawing::Point& point, ani_object& obj);
 
@@ -181,7 +181,7 @@ bool CreatePointObjAndCheck(ani_env* env, const Drawing::Point& point, ani_objec
 
 bool GetPoint3FromPoint3dObj(ani_env* env, ani_object obj, Drawing::Point3& point3d);
 
-bool SetPointToAniPointArrayWithIndex(ani_env* env, Drawing::Point& point, ani_object& pointArray, uint32_t index);
+bool SetPointToAniPointArrayWithIndex(ani_env* env, Drawing::Point& point, ani_array& pointArray, uint32_t index);
 
 inline bool CheckDoubleOutOfRange(ani_double val, double lowerBound, double upperBound)
 {
diff --git a/interfaces/kits/ani/drawing/brush_ani/ani_brush.cpp b/interfaces/kits/ani/drawing/brush_ani/ani_brush.cpp
index 203ff25078..d7c9b49b9b 100644
--- a/interfaces/kits/ani/drawing/brush_ani/ani_brush.cpp
+++ b/interfaces/kits/ani/drawing/brush_ani/ani_brush.cpp
@@ -28,13 +28,11 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_BRUSH_NAME = "@ohos.graphics.drawing.drawing.Brush";
 
 ani_status AniBrush::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_BRUSH_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().brush;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_BRUSH_NAME);
         return ANI_NOT_FOUND;
     }
@@ -64,7 +62,7 @@ ani_status AniBrush::AniInit(ani_env *env)
         ani_native_function { "setShaderEffect", nullptr, reinterpret_cast<void*>(SetShaderEffect) },
     };
 
-    ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_BRUSH_NAME);
         return ANI_NOT_FOUND;
@@ -97,7 +95,7 @@ void AniBrush::Constructor(ani_env* env, ani_object obj)
 
 void AniBrush::ConstructorWithBrush(ani_env* env, ani_object obj, ani_object aniBrushObj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, aniBrushObj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, aniBrushObj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniBrush::ConstructorWithBrush brush is nullptr.");
@@ -115,7 +113,7 @@ void AniBrush::ConstructorWithBrush(ani_env* env, ani_object obj, ani_object ani
 
 ani_int AniBrush::GetAlpha(ani_env* env, ani_object obj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::GetAlpha brush is nullptr.");
         return -1;
@@ -126,7 +124,7 @@ ani_int AniBrush::GetAlpha(ani_env* env, ani_object obj)
 
 void AniBrush::SetColorWithObject(ani_env* env, ani_object obj, ani_object aniColor)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniBrush::SetColorWithObject brush is nullptr.");
@@ -149,7 +147,7 @@ void AniBrush::SetColorWithObject(ani_env* env, ani_object obj, ani_object aniCo
 void AniBrush::SetColorWithARGB(ani_env* env, ani_object obj, ani_int alpha,
     ani_int red, ani_int green, ani_int blue)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniBrush::SetColorWithARGB brush is nullptr.");
@@ -179,7 +177,7 @@ void AniBrush::SetColorWithARGB(ani_env* env, ani_object obj, ani_int alpha,
 
 void AniBrush::SetColor(ani_env* env, ani_object obj, ani_int color)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::SetColor brush is nullptr.");
         return;
@@ -193,7 +191,7 @@ void AniBrush::SetColor(ani_env* env, ani_object obj, ani_int color)
 ani_object AniBrush::GetColor(ani_env* env, ani_object obj)
 {
     ani_object aniObj = CreateAniUndefined(env);
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::GetColor brush is nullptr.");
         return aniObj;
@@ -206,7 +204,7 @@ ani_object AniBrush::GetColor(ani_env* env, ani_object obj)
 
 ani_int AniBrush::GetHexColor(ani_env* env, ani_object obj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::GetHexColor brush is nullptr.");
         return -1;
@@ -218,7 +216,7 @@ ani_int AniBrush::GetHexColor(ani_env* env, ani_object obj)
 
 void AniBrush::SetAntiAlias(ani_env* env, ani_object obj, ani_boolean aa)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::SetAntiAlias brush is nullptr.");
         return;
@@ -230,7 +228,7 @@ void AniBrush::SetAntiAlias(ani_env* env, ani_object obj, ani_boolean aa)
 
 ani_boolean AniBrush::IsAntiAlias(ani_env* env, ani_object obj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::IsAntiAlias brush is nullptr.");
         return ANI_FALSE;
@@ -242,7 +240,7 @@ ani_boolean AniBrush::IsAntiAlias(ani_env* env, ani_object obj)
 
 void AniBrush::Reset(ani_env* env, ani_object obj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::Reset brush is nullptr.");
         return;
@@ -253,7 +251,7 @@ void AniBrush::Reset(ani_env* env, ani_object obj)
 
 void AniBrush::SetAlpha(ani_env* env, ani_object obj, ani_int alpha)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::SetAlpha brush is nullptr.");
         return;
@@ -270,7 +268,7 @@ void AniBrush::SetAlpha(ani_env* env, ani_object obj, ani_int alpha)
 
 void AniBrush::SetBlendMode(ani_env* env, ani_object obj, ani_enum_item aniBlendMode)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::SetBlendMode brush is nullptr.");
         return;
@@ -303,7 +301,7 @@ AniBrush::~AniBrush()
 
 void AniBrush::SetColorFilter(ani_env* env, ani_object obj, ani_object objColorFilter)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::SetColorFilter brush is nullptr.");
         return;
@@ -313,7 +311,8 @@ void AniBrush::SetColorFilter(ani_env* env, ani_object obj, ani_object objColorF
     env->Reference_IsNull(objColorFilter, &isNull);
     AniColorFilter* aniColorFilter = nullptr;
     if (!isNull) {
-        aniColorFilter = GetNativeFromObj<AniColorFilter>(env, objColorFilter);
+        aniColorFilter = GetNativeFromObj<AniColorFilter>(env, objColorFilter,
+            AniGlobalField::GetInstance().colorFilterNativeObj);
         if (aniColorFilter == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniBrush::SetColorFilter invalid param colorFilter.");
@@ -328,7 +327,7 @@ void AniBrush::SetColorFilter(ani_env* env, ani_object obj, ani_object objColorF
 
 ani_object AniBrush::GetColorFilter(ani_env* env, ani_object obj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::GetColorFilter brush is nullptr.");
         return CreateAniUndefined(env);
@@ -339,7 +338,8 @@ ani_object AniBrush::GetColorFilter(ani_env* env, ani_object obj)
     }
 
     AniColorFilter* colorFilter = new AniColorFilter(aniBrush->GetBrush()->GetFilter().GetColorFilter());
-    ani_object aniObj = CreateAniObject(env, ANI_CLASS_COLORFILTER_NAME, nullptr);
+    ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().colorFilter,
+        AniGlobalMethod::GetInstance().colorFilterCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj,
         NATIVE_OBJ, reinterpret_cast<ani_long>(colorFilter))) {
         ROSEN_LOGE("AniBrush::GetColorFilter failed cause by Object_SetFieldByName_Long");
@@ -351,7 +351,7 @@ ani_object AniBrush::GetColorFilter(ani_env* env, ani_object obj)
 
 void AniBrush::SetImageFilter(ani_env* env, ani_object obj, ani_object imageFilterObj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::SetImageFilter brush is nullptr.");
         return;
@@ -361,7 +361,8 @@ void AniBrush::SetImageFilter(ani_env* env, ani_object obj, ani_object imageFilt
     env->Reference_IsNull(imageFilterObj, &isNull);
     AniImageFilter* aniImageFilter = nullptr;
     if (!isNull) {
-        aniImageFilter = GetNativeFromObj<AniImageFilter>(env, imageFilterObj);
+        aniImageFilter = GetNativeFromObj<AniImageFilter>(env, imageFilterObj,
+            AniGlobalField::GetInstance().imageFilterNativeObj);
         if (aniImageFilter == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniBrush::SetImageFilter invalid param imageFilter.");
@@ -375,7 +376,7 @@ void AniBrush::SetImageFilter(ani_env* env, ani_object obj, ani_object imageFilt
 
 void AniBrush::SetMaskFilter(ani_env* env, ani_object obj, ani_object maskFilterObj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::SetMaskFilter brush is nullptr.");
         return;
@@ -385,7 +386,8 @@ void AniBrush::SetMaskFilter(ani_env* env, ani_object obj, ani_object maskFilter
     env->Reference_IsNull(maskFilterObj, &isNull);
     AniMaskFilter* aniMaskFilter = nullptr;
     if (!isNull) {
-        aniMaskFilter = GetNativeFromObj<AniMaskFilter>(env, maskFilterObj);
+        aniMaskFilter = GetNativeFromObj<AniMaskFilter>(env, maskFilterObj,
+            AniGlobalField::GetInstance().maskFilterNativeObj);
         if (aniMaskFilter == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniBrush::SetMaskFilter invalid param maskFilter.");
@@ -399,7 +401,7 @@ void AniBrush::SetMaskFilter(ani_env* env, ani_object obj, ani_object maskFilter
 
 void AniBrush::SetShadowLayer(ani_env* env, ani_object obj, ani_object shadowLayerObj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::SetShadowLayer brush is nullptr.");
         return;
@@ -409,7 +411,8 @@ void AniBrush::SetShadowLayer(ani_env* env, ani_object obj, ani_object shadowLay
     env->Reference_IsNull(shadowLayerObj, &isNull);
     AniShadowLayer* aniShadowLayer = nullptr;
     if (!isNull) {
-        aniShadowLayer = GetNativeFromObj<AniShadowLayer>(env, shadowLayerObj);
+        aniShadowLayer = GetNativeFromObj<AniShadowLayer>(env, shadowLayerObj,
+            AniGlobalField::GetInstance().shadowLayerNativeObj);
         if (aniShadowLayer == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniBrush::SetShadowLayer invalid param shadowLayer.");
@@ -421,7 +424,7 @@ void AniBrush::SetShadowLayer(ani_env* env, ani_object obj, ani_object shadowLay
 
 void AniBrush::SetShaderEffect(ani_env* env, ani_object obj, ani_object shaderEffectObj)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, obj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniBrush::SetShaderEffect brush is nullptr.");
         return;
@@ -431,7 +434,8 @@ void AniBrush::SetShaderEffect(ani_env* env, ani_object obj, ani_object shaderEf
     env->Reference_IsNull(shaderEffectObj, &isNull);
     AniShaderEffect* aniShaderEffect = nullptr;
     if (!isNull) {
-        aniShaderEffect = GetNativeFromObj<AniShaderEffect>(env, shaderEffectObj);
+        aniShaderEffect = GetNativeFromObj<AniShaderEffect>(env, shaderEffectObj,
+            AniGlobalField::GetInstance().shaderEffectNativeObj);
         if (aniShaderEffect == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniBrush::SetShaderEffect invalid param shaderEffect.");
@@ -470,7 +474,7 @@ ani_object AniBrush::BrushTransferStatic(
 
 ani_long AniBrush::GetBrushAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, input);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, input, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr || aniBrush->GetBrush() == nullptr) {
         ROSEN_LOGE("AniBrush::GetBrushAddr aniBrush is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/canvas_ani/ani_canvas.cpp b/interfaces/kits/ani/drawing/canvas_ani/ani_canvas.cpp
index 2fcd1b7e85..d77190ee3f 100644
--- a/interfaces/kits/ani/drawing/canvas_ani/ani_canvas.cpp
+++ b/interfaces/kits/ani/drawing/canvas_ani/ani_canvas.cpp
@@ -267,8 +267,6 @@ namespace {
 ani_field gNativeObjField = nullptr;
 }
 
-const char* ANI_CLASS_CANVAS_NAME = "@ohos.graphics.drawing.drawing.Canvas";
-const char* ANI_CLASS_POINT_NAME = "@ohos.graphics.common2D.common2D.Point";
 static constexpr int VERTEX_COUNT_MIN_SIZE = 3;
 
 bool GetNativeObj(ani_env* env, ani_object obj, ani_long& nativeObj)
@@ -376,13 +374,12 @@ static const std::array g_methods = {
 
 ani_status AniCanvas::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_CANVAS_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().canvas;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_CANVAS_NAME);
         return ANI_NOT_FOUND;
     }
-    ret = env->Class_BindNativeMethods(cls, g_methods.data(), g_methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, g_methods.data(), g_methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_CANVAS_NAME);
         return ANI_NOT_FOUND;
@@ -457,7 +454,7 @@ void AniCanvas::Constructor(ani_env* env, ani_object obj, ani_object pixelmapObj
 void AniCanvas::DrawRect(ani_env* env, ani_object obj,
     ani_double left, ani_double top, ani_double right, ani_double bottom)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         AniThrowError(env, "Invalid params.");
         return;
@@ -492,13 +489,14 @@ void AniCanvas::DrawRectWithRect(ani_env* env, ani_object obj, ani_object aniRec
 
 void AniCanvas::DrawRoundRect(ani_env* env, ani_object obj, ani_object roundRectObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawRoundRect canvas is nullptr.");
         return;
     }
-    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, roundRectObj);
+    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, roundRectObj,
+        AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniRoundRect == nullptr || aniRoundRect->GetRoundRect() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawRoundRect roundRect is nullptr.");
@@ -510,20 +508,22 @@ void AniCanvas::DrawRoundRect(ani_env* env, ani_object obj, ani_object roundRect
 
 void AniCanvas::DrawNestedRoundRect(ani_env* env, ani_object obj, ani_object outerObj, ani_object innerObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawNestedRoundRect canvas is nullptr.");
         return;
     }
 
-    auto aniOuterRoundRect = GetNativeFromObj<AniRoundRect>(env, outerObj);
+    auto aniOuterRoundRect = GetNativeFromObj<AniRoundRect>(env, outerObj,
+        AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniOuterRoundRect == nullptr || aniOuterRoundRect->GetRoundRect() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawNestedRoundRect outerRoundRect is nullptr.");
         return;
     }
-    auto aniInnerRoundRect = GetNativeFromObj<AniRoundRect>(env, innerObj);
+    auto aniInnerRoundRect = GetNativeFromObj<AniRoundRect>(env, innerObj,
+        AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniInnerRoundRect == nullptr || aniInnerRoundRect->GetRoundRect() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawNestedRoundRect innerRoundRect is nullptr.");
@@ -536,12 +536,12 @@ void AniCanvas::DrawNestedRoundRect(ani_env* env, ani_object obj, ani_object out
 
 void AniCanvas::DrawBackground(ani_env* env, ani_object obj, ani_object brushObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawBackground canvas is nullptr.");
         return;
     }
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, brushObj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, brushObj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawBackground brush is nullptr.");
         return;
@@ -554,12 +554,12 @@ void AniCanvas::DrawShadow(ani_env* env, ani_object obj, ani_object pathObj,
     ani_object planeParams, ani_object devLightPos, ani_double lightRadius,
     ani_object ambientColor, ani_object spotColor, ani_enum_item flagEnum)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawShadow canvas is nullptr.");
         return;
     }
-    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawShadow path is nullptr.");
         return;
@@ -600,13 +600,13 @@ void AniCanvas::DrawShadowWithOption(ani_env* env, ani_object obj, ani_object pa
     ani_object planeParams, ani_object devLightPos, ani_double lightRadius,
     ani_object ambientColorOps, ani_object spotColorOps, ani_enum_item flagEnum)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawShadowWithOption canvas is nullptr.");
         return;
     }
-    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawShadowWithOption path is nullptr.");
@@ -646,7 +646,7 @@ void AniCanvas::DrawShadowWithOption(ani_env* env, ani_object obj, ani_object pa
 
 void AniCanvas::DrawCircle(ani_env* env, ani_object obj, ani_double x, ani_double y, ani_double radius)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawCircle canvas is nullptr.");
         return;
@@ -661,7 +661,7 @@ void AniCanvas::DrawImage(ani_env* env, ani_object obj, ani_object pixelmapObj,
     ani_double left, ani_double top, ani_object samplingOptionsObj)
 {
 #ifdef ROSEN_OHOS
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawImage canvas is nullptr.");
         return;
@@ -677,7 +677,8 @@ void AniCanvas::DrawImage(ani_env* env, ani_object obj, ani_object pixelmapObj,
     ani_boolean isUndefined;
     env->Reference_IsUndefined(samplingOptionsObj, &isUndefined);
     if (!isUndefined) {
-        AniSamplingOptions* aniSamplingOptions = GetNativeFromObj<AniSamplingOptions>(env, samplingOptionsObj);
+        AniSamplingOptions* aniSamplingOptions = GetNativeFromObj<AniSamplingOptions>(env, samplingOptionsObj,
+            AniGlobalField::GetInstance().samplingOptionsNativeObj);
         if (aniSamplingOptions == nullptr || aniSamplingOptions->GetSamplingOptions() == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniCanvas::DrawImage samplingOptions is nullptr.");
@@ -709,7 +710,7 @@ void AniCanvas::DrawImageLattice(ani_env* env, ani_object obj, ani_object pixelm
     ani_object latticeObj, ani_object dstRectObj, ani_enum_item filterModeEnum)
 {
 #ifdef ROSEN_OHOS
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawImageLattice canvas is nullptr.");
@@ -722,7 +723,7 @@ void AniCanvas::DrawImageLattice(ani_env* env, ani_object obj, ani_object pixelm
         return;
     }
 
-    auto aniLattice = GetNativeFromObj<AniLattice>(env, latticeObj);
+    auto aniLattice = GetNativeFromObj<AniLattice>(env, latticeObj, AniGlobalField::GetInstance().latticeNativeObj);
     if (aniLattice == nullptr || aniLattice->GetLattice() == nullptr) {
         ROSEN_LOGE("AniCanvas::DrawImageLattice lattice is nullptr");
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
@@ -763,7 +764,7 @@ void AniCanvas::DrawImageNine(ani_env* env, ani_object obj, ani_object pixelmapO
     ani_object centerRectObj, ani_object dstRectObj, ani_enum_item filterModeEnum)
 {
 #ifdef ROSEN_OHOS
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawImageNine canvas is nullptr.");
         return;
@@ -816,7 +817,7 @@ void AniCanvas::DrawImageNine(ani_env* env, ani_object obj, ani_object pixelmapO
 void AniCanvas::DrawImageRect(ani_env* env, ani_object obj,
     ani_object pixelmapObj, ani_object rectObj, ani_object samplingOptionsObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         AniThrowError(env, "Invalid params.");
         return;
@@ -839,7 +840,8 @@ void AniCanvas::DrawImageRect(ani_env* env, ani_object obj,
     ani_boolean isUndefined;
     env->Reference_IsUndefined(samplingOptionsObj, &isUndefined);
     if (!isUndefined) {
-        aniSamplingOptions = GetNativeFromObj<AniSamplingOptions>(env, samplingOptionsObj);
+        aniSamplingOptions = GetNativeFromObj<AniSamplingOptions>(env, samplingOptionsObj,
+            AniGlobalField::GetInstance().samplingOptionsNativeObj);
         if (aniSamplingOptions == nullptr || aniSamplingOptions->GetSamplingOptions() == nullptr) {
             AniThrowError(env, "Invalid params.");
             return;
@@ -899,15 +901,14 @@ void AniCanvas::DrawImageRectWithSrcInner(std::shared_ptr<Media::PixelMap> pixel
 #endif
 
 #ifdef ROSEN_OHOS
-bool AniCanvas::GetVertices(ani_env* env, ani_object verticesObj, float* vertices, uint32_t verticesSize)
+bool AniCanvas::GetVertices(ani_env* env, ani_array verticesObj, float* vertices, uint32_t verticesSize)
 {
     for (uint32_t i = 0; i < verticesSize; i++) {
         ani_double vertex;
         ani_ref vertexRef;
-        if (ANI_OK !=  env->Object_CallMethodByName_Ref(
-            verticesObj, "$_get", "i:Y", &vertexRef, (ani_int)i) ||
-            ANI_OK !=  env->Object_CallMethodByName_Double(
-                static_cast<ani_object>(vertexRef), "toDouble", ":d", &vertex)) {
+        if (ANI_OK !=  env->Array_Get(verticesObj, (ani_int)i, &vertexRef) ||
+            ANI_OK !=  env->Object_CallMethod_Double(
+                static_cast<ani_object>(vertexRef), AniGlobalMethod::GetInstance().doubleGet, &vertex)) {
             delete []vertices;
             return false;
         }
@@ -916,15 +917,15 @@ bool AniCanvas::GetVertices(ani_env* env, ani_object verticesObj, float* vertice
     return true;
 }
 
-bool AniCanvas::GetVerticesUint16(ani_env* env, ani_object verticesObj, uint16_t* vertices, uint32_t verticesSize)
+bool AniCanvas::GetVerticesUint16(ani_env* env, ani_array verticesObj, uint16_t* vertices, uint32_t verticesSize)
 {
     for (uint32_t i = 0; i < verticesSize; i++) {
         ani_int vertex;
         ani_ref vertexRef;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(
-            verticesObj, "$_get", "i:Y", &vertexRef, (ani_int)i) ||
-            ANI_OK != env->Object_CallMethodByName_Int(
-                static_cast<ani_object>(vertexRef), "toInt", ":i", &vertex)) {
+        if (ANI_OK != env->Array_Get(
+            verticesObj, (ani_int)i, &vertexRef) ||
+            ANI_OK != env->Object_CallMethod_Int(
+                static_cast<ani_object>(vertexRef), AniGlobalMethod::GetInstance().intGet, &vertex)) {
             ROSEN_LOGE("AniCanvas::GetVerticesUint16 vertices is invalid");
             return false;
         }
@@ -937,15 +938,14 @@ bool AniCanvas::GetVerticesUint16(ani_env* env, ani_object verticesObj, uint16_t
     return true;
 }
 
-bool AniCanvas::GetColorsUint32(ani_env* env, ani_object colorsObj, uint32_t* colors, uint32_t colorsSize)
+bool AniCanvas::GetColorsUint32(ani_env* env, ani_array colorsObj, uint32_t* colors, uint32_t colorsSize)
 {
     for (uint32_t i = 0; i < colorsSize; i++) {
         ani_int color;
         ani_ref colorRef;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(
-            colorsObj, "$_get", "i:Y", &colorRef, (ani_int)i) ||
-            ANI_OK != env->Object_CallMethodByName_Int(
-                static_cast<ani_object>(colorRef), "unboxed", ":i", &color)) {
+        if (ANI_OK != env->Array_Get(colorsObj, (ani_int)i, &colorRef) ||
+            ANI_OK != env->Object_CallMethod_Int(
+                static_cast<ani_object>(colorRef), AniGlobalMethod::GetInstance().intGet, &color)) {
             ROSEN_LOGE("AniCanvas::GetColorsUint32 colors is invalid");
             return false;
         }
@@ -956,12 +956,12 @@ bool AniCanvas::GetColorsUint32(ani_env* env, ani_object colorsObj, uint32_t* co
 #endif
 
 #ifdef ROSEN_OHOS
-void AniCanvas::GetColorsAndDraw(ani_env* env, ani_object colorsObj, int32_t colorOffset,
+void AniCanvas::GetColorsAndDraw(ani_env* env, ani_array colorsObj, int32_t colorOffset,
     DrawPixelMapMeshArgs& args, AniCanvas* aniCanvas)
 {
     float* verticesMesh = args.verticesSize ? (args.vertices + args.vertOffset * 2) : nullptr;
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(colorsObj, "length", &aniLength)) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(colorsObj, &aniLength)) {
         AniThrowError(env, "Invalid params.");
         return;
     }
@@ -989,9 +989,9 @@ void AniCanvas::GetColorsAndDraw(ani_env* env, ani_object colorsObj, int32_t col
     for (uint32_t i = 0; i < colorsSize; i++) {
         ani_int color;
         ani_ref colorRef;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(
-            colorsObj, "$_get", "i:Y", &colorRef, (ani_int)i) ||
-            ANI_OK != env->Object_CallMethodByName_Int(static_cast<ani_object>(colorRef), "toInt", ":i", &color)) {
+        if (ANI_OK != env->Array_Get(colorsObj, (ani_int)i, &colorRef) ||
+            ANI_OK != env->Object_CallMethod_Int(
+                static_cast<ani_object>(colorRef), AniGlobalMethod::GetInstance().intGet, &color)) {
             delete []colors;
             AniThrowError(env, "Incorrect DrawPixelMapMesh parameter color type.");
             return;
@@ -1007,9 +1007,9 @@ void AniCanvas::GetColorsAndDraw(ani_env* env, ani_object colorsObj, int32_t col
 
 void AniCanvas::DrawPixelMapMesh(ani_env* env, ani_object obj,
     ani_object pixelmapObj, ani_int aniMeshWidth, ani_int aniMeshHeight,
-    ani_object verticesObj, ani_int aniVertOffset, ani_object colorsObj, ani_int aniColorOffset)
+    ani_array verticesObj, ani_int aniVertOffset, ani_array colorsObj, ani_int aniColorOffset)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         AniThrowError(env, "Invalid params.");
         return;
@@ -1031,8 +1031,8 @@ void AniCanvas::DrawPixelMapMesh(ani_env* env, ani_object obj,
         return;
     }
 
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(verticesObj, "length", &aniLength)) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(verticesObj, &aniLength)) {
         AniThrowError(env, "Invalid params.");
         return;
     }
@@ -1075,15 +1075,15 @@ bool AniCanvas::CheckDrawVerticesParams(ani_env* env, ani_int& vertexCount, ani_
 }
 
 bool AniCanvas::GetPositions(ani_env* env, ani_int vertexCount,
-    ani_object positionsObj, std::vector<Drawing::Point>& pointPositions)
+    ani_array positionsObj, std::vector<Drawing::Point>& pointPositions)
 {
-    ani_int aniPositionsLength = 0;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(positionsObj, "length", &aniPositionsLength)) {
+    ani_size aniPositionsLength = 0;
+    if (ANI_OK != env->Array_GetLength(positionsObj, &aniPositionsLength)) {
         ROSEN_LOGE("AniCanvas::DrawVertices positions is invalid");
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid positions params.");
         return false;
     }
-    if (aniPositionsLength != vertexCount) {
+    if ((ani_int)aniPositionsLength != vertexCount) {
         ROSEN_LOGE("AniCanvas::DrawVertices positionsSize is invalid");
         ThrowBusinessError(env, DrawingErrorCode::ERROR_PARAM_VERIFICATION_FAILED, "Invalid positions params.");
         return false;
@@ -1101,17 +1101,23 @@ bool AniCanvas::GetPositions(ani_env* env, ani_int vertexCount,
 bool AniCanvas::GetTexs(ani_env* env, ani_int vertexCount,
     ani_object texsObj, std::vector<Drawing::Point>& pointTexs)
 {
-    ani_int aniTexsLength = 0;
-    env->Object_GetPropertyByName_Int(texsObj, "length", &aniTexsLength);
+    ani_boolean isNull = ANI_TRUE;
+    env->Reference_IsNull(texsObj, &isNull);
+    if (isNull) {
+        return true;
+    }
+    ani_size aniTexsLength = 0;
+    ani_array arrayObj = reinterpret_cast<ani_array>(texsObj);
+    env->Array_GetLength(arrayObj, &aniTexsLength);
     uint32_t texsSize = static_cast<uint32_t>(aniTexsLength);
     if (texsSize != 0) {
-        if (aniTexsLength != vertexCount) {
+        if ((ani_int)aniTexsLength != vertexCount) {
             ROSEN_LOGE("AniCanvas::DrawVertices texsSize is invalid");
             ThrowBusinessError(env, DrawingErrorCode::ERROR_PARAM_VERIFICATION_FAILED, "Invalid texsObj params.");
             return false;
         }
         pointTexs.resize(texsSize);
-        if (!ConvertFromAniPointsArray(env, texsObj, pointTexs.data(), texsSize)) {
+        if (!ConvertFromAniPointsArray(env, arrayObj, pointTexs.data(), texsSize)) {
             ROSEN_LOGE("AniCanvas::DrawVertices GetTexsPoints is invalid");
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid texsObj params.");
             return false;
@@ -1123,9 +1129,15 @@ bool AniCanvas::GetTexs(ani_env* env, ani_int vertexCount,
 bool AniCanvas::GetColors(ani_env* env, ani_int vertexCount,
     ani_object colorsObj, std::unique_ptr<uint32_t[]>& colors)
 {
-    ani_int aniColorsLength = 0;
-    env->Object_GetPropertyByName_Int(colorsObj, "length", &aniColorsLength);
-    int32_t colorsSize = aniColorsLength;
+    ani_boolean isNull = ANI_TRUE;
+    env->Reference_IsNull(colorsObj, &isNull);
+    if (isNull) {
+        return true;
+    }
+    ani_size aniColorsLength = 0;
+    ani_array arrayObj = reinterpret_cast<ani_array>(colorsObj);
+    env->Array_GetLength(arrayObj, &aniColorsLength);
+    int32_t colorsSize = static_cast<int32_t>(aniColorsLength);
     if (colorsSize != 0) {
         if (colorsSize != vertexCount) {
             ROSEN_LOGE("AniCanvas::DrawVertices colorsSize is invalid");
@@ -1133,7 +1145,7 @@ bool AniCanvas::GetColors(ani_env* env, ani_int vertexCount,
             return false;
         }
         colors = std::make_unique<uint32_t[]>(colorsSize);
-        if (!GetColorsUint32(env, colorsObj, colors.get(), colorsSize)) {
+        if (!GetColorsUint32(env, arrayObj, colors.get(), colorsSize)) {
             ROSEN_LOGE("AniCanvas::DrawVertices GetColors is invalid");
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid colors params.");
             return false;
@@ -1145,9 +1157,15 @@ bool AniCanvas::GetColors(ani_env* env, ani_int vertexCount,
 bool AniCanvas::GetIndices(ani_env* env, ani_int indexCount,
     ani_object indicesObj, std::unique_ptr<uint16_t[]>& indices)
 {
-    ani_int aniIndicesLength = 0;
-    env->Object_GetPropertyByName_Int(indicesObj, "length", &aniIndicesLength);
-    int32_t indicesSize = aniIndicesLength;
+    ani_boolean isNull = ANI_TRUE;
+    env->Reference_IsNull(indicesObj, &isNull);
+    if (isNull) {
+        return true;
+    }
+    ani_size aniIndicesLength = 0;
+    ani_array arrayObj = reinterpret_cast<ani_array>(indicesObj);
+    env->Array_GetLength(arrayObj, &aniIndicesLength);
+    int32_t indicesSize = static_cast<int32_t>(aniIndicesLength);
     if (indicesSize != 0) {
         if (indicesSize != indexCount) {
             ROSEN_LOGE("AniCanvas::DrawVertices indicesSize is Invalid");
@@ -1155,7 +1173,7 @@ bool AniCanvas::GetIndices(ani_env* env, ani_int indexCount,
             return false;
         }
         indices = std::make_unique<uint16_t[]>(indicesSize);
-        if (!GetVerticesUint16(env, indicesObj, indices.get(), indicesSize)) {
+        if (!GetVerticesUint16(env, arrayObj, indices.get(), indicesSize)) {
             ROSEN_LOGE("AniCanvas::DrawVertices GetIndices is invalid");
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid indices params.");
             return false;
@@ -1185,10 +1203,10 @@ bool AniCanvas::GetVertexModeAndBlendMode(ani_env* env, ani_enum_item aniVertexM
 }
 
 void AniCanvas::DrawVertices(ani_env* env, ani_object obj, ani_enum_item aniVertexMode,
-    ani_int aniVertexCount, ani_object positionsObj, ani_object texsObj, ani_object colorsObj,
+    ani_int aniVertexCount, ani_array positionsObj, ani_object texsObj, ani_object colorsObj,
     ani_int aniIndexCount, ani_object indicesObj, ani_enum_item aniBlendMode)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid Canvas params.");
         return;
@@ -1222,7 +1240,7 @@ void AniCanvas::DrawVertices(ani_env* env, ani_object obj, ani_enum_item aniVert
 void AniCanvas::DrawImageRectWithSrc(ani_env* env, ani_object obj, ani_object pixelmapObj,
     ani_object srcRectObj, ani_object dstRectObj, ani_object samplingOptionsObj, ani_object constraintObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "DrawImageRectWithSrc canvas is nullptr.");
         return;
@@ -1244,7 +1262,8 @@ void AniCanvas::DrawImageRectWithSrc(ani_env* env, ani_object obj, ani_object pi
     ani_boolean isUndefined = true;
     env->Reference_IsUndefined(samplingOptionsObj, &isUndefined);
     if (!isUndefined) {
-        aniSamplingOptions = GetNativeFromObj<AniSamplingOptions>(env, samplingOptionsObj);
+        aniSamplingOptions = GetNativeFromObj<AniSamplingOptions>(env, samplingOptionsObj,
+            AniGlobalField::GetInstance().samplingOptionsNativeObj);
         if (aniSamplingOptions == nullptr || aniSamplingOptions->GetSamplingOptions() == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "DrawImageRectWithSrc samplingOptions is nullptr.");
@@ -1276,7 +1295,7 @@ void AniCanvas::DrawImageRectWithSrc(ani_env* env, ani_object obj, ani_object pi
 
 void AniCanvas::DrawColorWithObject(ani_env* env, ani_object obj, ani_object colorObj, ani_object aniBlendMode)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawColorWithObject canvas is nullptr.");
@@ -1318,7 +1337,7 @@ void AniCanvas::DrawColorWithObject(ani_env* env, ani_object obj, ani_object col
 void AniCanvas::DrawColorWithArgb(ani_env* env, ani_object obj, ani_int alpha, ani_int red,
     ani_int green, ani_int blue, ani_object aniBlendMode)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawColorWithArgb canvas is nullptr.");
@@ -1370,7 +1389,7 @@ void AniCanvas::DrawColorWithArgb(ani_env* env, ani_object obj, ani_int alpha, a
 
 void AniCanvas::DrawColor(ani_env* env, ani_object obj, ani_int color, ani_object aniBlendMode)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawColor canvas is nullptr.");
         return;
@@ -1403,12 +1422,12 @@ void AniCanvas::DrawColor(ani_env* env, ani_object obj, ani_int color, ani_objec
 
 void AniCanvas::DrawPath(ani_env* env, ani_object obj, ani_object pathObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawPath canvas is nullptr.");
         return;
     }
-    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawPath path is nullptr.");
         return;
@@ -1421,7 +1440,7 @@ void AniCanvas::DrawPath(ani_env* env, ani_object obj, ani_object pathObj)
 void AniCanvas::DrawLine(ani_env* env, ani_object obj, ani_double x0,
     ani_double y0, ani_double x1, ani_double y1)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawLine canvas is nullptr.");
         return;
@@ -1433,13 +1452,13 @@ void AniCanvas::DrawLine(ani_env* env, ani_object obj, ani_double x0,
 void AniCanvas::DrawSingleCharacter(ani_env* env, ani_object obj, ani_string text,
     ani_object fontObj, ani_double x, ani_double y)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawSingleCharacter canvas is nullptr.");
         return;
     }
-    auto aniFont = GetNativeFromObj<AniFont>(env, fontObj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, fontObj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawSingleCharacter font is nullptr.");
@@ -1477,12 +1496,12 @@ void AniCanvas::DrawSingleCharacter(ani_env* env, ani_object obj, ani_string tex
 
 void AniCanvas::DrawTextBlob(ani_env* env, ani_object obj, ani_object textBlobObj, ani_double x, ani_double y)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawTextBlob canvas is nullptr.");
         return;
     }
-    auto aniTextBlob = GetNativeFromObj<AniTextBlob>(env, textBlobObj);
+    auto aniTextBlob = GetNativeFromObj<AniTextBlob>(env, textBlobObj, AniGlobalField::GetInstance().textBlobNativeObj);
     if (aniTextBlob == nullptr || aniTextBlob->GetTextBlob() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawTextBlob textBlob is nullptr.");
         return;
@@ -1493,7 +1512,7 @@ void AniCanvas::DrawTextBlob(ani_env* env, ani_object obj, ani_object textBlobOb
 
 void AniCanvas::DrawOval(ani_env* env, ani_object obj, ani_object rectObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawOval canvas is nullptr.");
         return;
@@ -1512,7 +1531,7 @@ void AniCanvas::DrawOval(ani_env* env, ani_object obj, ani_object rectObj)
 void AniCanvas::DrawArc(ani_env* env, ani_object obj, ani_object rectObj,
     ani_double startAngle, ani_double sweepAngle)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawArc canvas is nullptr.");
         return;
@@ -1531,7 +1550,7 @@ void AniCanvas::DrawArc(ani_env* env, ani_object obj, ani_object rectObj,
 void AniCanvas::DrawArcWithCenter(ani_env* env, ani_object obj, ani_object rectObj,
     ani_double startAngle, ani_double sweepAngle, ani_boolean useCenter)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::DrawArcWithCenter canvas is nullptr.");
@@ -1558,7 +1577,7 @@ void AniCanvas::DrawArcWithCenter(ani_env* env, ani_object obj, ani_object rectO
 
 void AniCanvas::DrawPoint(ani_env* env, ani_object obj, ani_double x, ani_double y)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawPoint canvas is nullptr.");
         return;
@@ -1567,22 +1586,19 @@ void AniCanvas::DrawPoint(ani_env* env, ani_object obj, ani_double x, ani_double
     aniCanvas->NotifyDirty();
 }
 
-bool GetPoints(ani_env* env, ani_object pointsObj, uint32_t size, Drawing::Point* point)
+bool GetPoints(ani_env* env, ani_array pointsObj, uint32_t size, Drawing::Point* point)
 {
     ani_boolean isPointClass = false;
     for (uint32_t i = 0; i < size; i++) {
         ani_ref pointRef;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(
-            pointsObj, "$_get", "i:Y", &pointRef, (ani_int)i)) {
+        if (ANI_OK != env->Array_Get(pointsObj, (ani_int)i, &pointRef)) {
             ROSEN_LOGE("GetPoints get points failed");
             return false;
         }
         if (i == 0) {
-            ani_class pointClass;
-            ani_status ret = env->FindClass(ANI_CLASS_POINT_NAME, &pointClass);
-            if (ret != ANI_OK) {
-                ROSEN_LOGE("[ANI] can't find class %{public}s, status = %{public}d",
-                    ANI_CLASS_POINT_NAME, static_cast<int>(ret));
+            ani_class pointClass = AniGlobalClass::GetInstance().pointInterface;
+            if (pointClass == nullptr) {
+                ROSEN_LOGE("[ANI] can't find class %{public}s", ANI_CLASS_POINT_NAME);
                 return false;
             }
             env->Object_InstanceOf(static_cast<ani_object>(pointRef), pointClass, &isPointClass);
@@ -1595,15 +1611,15 @@ bool GetPoints(ani_env* env, ani_object pointsObj, uint32_t size, Drawing::Point
     return true;
 }
 
-void AniCanvas::DrawPoints(ani_env* env, ani_object obj, ani_object pointsObj, ani_object aniPointMode)
+void AniCanvas::DrawPoints(ani_env* env, ani_object obj, ani_array pointsObj, ani_object aniPointMode)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawPoints canvas is nullptr.");
         return;
     }
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(pointsObj, "length", &aniLength) || aniLength == 0) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(pointsObj, &aniLength) || aniLength == 0) {
         ROSEN_LOGE("AniCanvas::DrawPoints points are invalid");
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawPoints incorrect type points.");
         return;
@@ -1650,12 +1666,12 @@ void AniCanvas::DrawPoints(ani_env* env, ani_object obj, ani_object pointsObj, a
 
 void AniCanvas::DrawRegion(ani_env* env, ani_object obj, ani_object regionObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawRegion canvas is nullptr.");
         return;
     }
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, regionObj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, regionObj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::DrawRegion region is nullptr.");
         return;
@@ -1672,7 +1688,7 @@ void AniCanvas::AttachBrush(ani_env* env, ani_object obj, ani_object brushObj)
         return;
     }
 
-    auto aniBrush = GetNativeFromObj<AniBrush>(env, brushObj);
+    auto aniBrush = GetNativeFromObj<AniBrush>(env, brushObj, AniGlobalField::GetInstance().brushNativeObj);
     if (aniBrush == nullptr) {
         AniThrowError(env, "Invalid params.");
         return;
@@ -1683,13 +1699,13 @@ void AniCanvas::AttachBrush(ani_env* env, ani_object obj, ani_object brushObj)
 
 void AniCanvas::AttachPen(ani_env* env, ani_object obj, ani_object penObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         AniThrowError(env, "Invalid params.");
         return;
     }
 
-    auto aniPen = GetNativeFromObj<AniPen>(env, penObj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, penObj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr) {
         AniThrowError(env, "Invalid params.");
         return;
@@ -1711,7 +1727,7 @@ void AniCanvas::DetachBrush(ani_env* env, ani_object obj)
 
 void AniCanvas::DetachPen(ani_env* env, ani_object obj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         AniThrowError(env, "Invalid params.");
         return;
@@ -1722,7 +1738,7 @@ void AniCanvas::DetachPen(ani_env* env, ani_object obj)
 
 ani_int AniCanvas::Save(ani_env* env, ani_object obj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         AniThrowError(env, "Invalid params.");
         return -1;
@@ -1734,7 +1750,7 @@ ani_int AniCanvas::Save(ani_env* env, ani_object obj)
 
 ani_long AniCanvas::SaveLayer(ani_env* env, ani_object obj, ani_object rectObj, ani_object brushObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         AniThrowError(env, "Invalid params.");
         return -1;
@@ -1761,7 +1777,8 @@ ani_long AniCanvas::SaveLayer(ani_env* env, ani_object obj, ani_object rectObj,
         return ret;
     }
 
-    Drawing::AniBrush* aniBrush = GetNativeFromObj<AniBrush>(env, brushObj);
+    Drawing::AniBrush* aniBrush = GetNativeFromObj<AniBrush>(env, brushObj,
+        AniGlobalField::GetInstance().brushNativeObj);
     Drawing::Brush* drawingBrushPtr = aniBrush ? aniBrush->GetBrush().get() : nullptr;
 
     ani_long ret = canvas->GetSaveCount();
@@ -1772,7 +1789,7 @@ ani_long AniCanvas::SaveLayer(ani_env* env, ani_object obj, ani_object rectObj,
 
 void AniCanvas::Clear(ani_env* env, ani_object obj, ani_object objColor)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::Clear canvas is nullptr.");
         return;
@@ -1791,7 +1808,7 @@ void AniCanvas::Clear(ani_env* env, ani_object obj, ani_object objColor)
 
 void AniCanvas::ClearWithOption(ani_env* env, ani_object obj, ani_object objColor)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::ClearWithOption canvas is nullptr.");
@@ -1812,7 +1829,7 @@ void AniCanvas::ClearWithOption(ani_env* env, ani_object obj, ani_object objColo
 
 void AniCanvas::Restore(ani_env* env, ani_object obj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         AniThrowError(env, "Invalid params.");
         return;
@@ -1823,7 +1840,7 @@ void AniCanvas::Restore(ani_env* env, ani_object obj)
 
 ani_int AniCanvas::GetSaveCount(ani_env* env, ani_object obj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         AniThrowError(env, "Invalid params.");
         return -1;
@@ -1834,7 +1851,7 @@ ani_int AniCanvas::GetSaveCount(ani_env* env, ani_object obj)
 
 void AniCanvas::RestoreToCount(ani_env* env, ani_object obj, ani_int count)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr || count < 0) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::RestoreToCount canvas is nullptr.");
         return;
@@ -1845,7 +1862,7 @@ void AniCanvas::RestoreToCount(ani_env* env, ani_object obj, ani_int count)
 
 ani_int AniCanvas::GetWidth(ani_env* env, ani_object obj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::GetWidth canvas is nullptr.");
         return -1;
@@ -1856,7 +1873,7 @@ ani_int AniCanvas::GetWidth(ani_env* env, ani_object obj)
 
 ani_int AniCanvas::GetHeight(ani_env* env, ani_object obj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::GetHeight canvas is nullptr.");
         return -1;
@@ -1868,7 +1885,7 @@ ani_int AniCanvas::GetHeight(ani_env* env, ani_object obj)
 ani_object AniCanvas::GetLocalClipBounds(ani_env* env, ani_object obj)
 {
     ani_object aniObj = CreateAniUndefined(env);
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::GetLocalClipBounds canvas is nullptr.");
@@ -1883,7 +1900,7 @@ ani_object AniCanvas::GetLocalClipBounds(ani_env* env, ani_object obj)
 ani_object AniCanvas::GetTotalMatrix(ani_env* env, ani_object obj)
 {
     ani_object aniObj = CreateAniUndefined(env);
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::GetTotalMatrix canvas is nullptr.");
@@ -1893,7 +1910,8 @@ ani_object AniCanvas::GetTotalMatrix(ani_env* env, ani_object obj)
     Drawing::Matrix matrix = aniCanvas->GetCanvas()->GetTotalMatrix();
     std::shared_ptr<Drawing::Matrix> matrixPtr = std::make_shared<Drawing::Matrix>(matrix);
     AniMatrix* aniMatrix = new AniMatrix(matrixPtr);
-    aniObj = CreateAniObject(env, ANI_CLASS_MATRIX_NAME, ":");
+    aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().matrix,
+        AniGlobalMethod::GetInstance().matrixCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj,
         NATIVE_OBJ, reinterpret_cast<ani_long>(aniMatrix))) {
         ROSEN_LOGE("AniCanvas::GetTotalMatrix failed cause by Object_SetFieldByName_Long");
@@ -1905,7 +1923,7 @@ ani_object AniCanvas::GetTotalMatrix(ani_env* env, ani_object obj)
 
 void AniCanvas::Scale(ani_env* env, ani_object obj, ani_double sx, ani_double sy)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::Scale canvas is nullptr.");
         return;
@@ -1915,7 +1933,7 @@ void AniCanvas::Scale(ani_env* env, ani_object obj, ani_double sx, ani_double sy
 
 void AniCanvas::Skew(ani_env* env, ani_object obj, ani_double sx, ani_double sy)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::Skew canvas is nullptr.");
         return;
@@ -1925,7 +1943,7 @@ void AniCanvas::Skew(ani_env* env, ani_object obj, ani_double sx, ani_double sy)
 
 void AniCanvas::Rotate(ani_env* env, ani_object obj, ani_double degrees, ani_double sx, ani_double sy)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::Rotate canvas is nullptr.");
         return;
@@ -1936,12 +1954,12 @@ void AniCanvas::Rotate(ani_env* env, ani_object obj, ani_double degrees, ani_dou
 
 void AniCanvas::ConcatMatrix(ani_env* env, ani_object obj, ani_object matrixObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::ConcatMatrix canvas is nullptr.");
         return;
     }
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, matrixObj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, matrixObj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::ConcatMatrix matrix is nullptr.");
         return;
@@ -1952,7 +1970,7 @@ void AniCanvas::ConcatMatrix(ani_env* env, ani_object obj, ani_object matrixObj)
 
 void AniCanvas::Translate(ani_env* env, ani_object obj, ani_double dx, ani_double dy)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::Translate canvas is nullptr.");
         return;
@@ -1962,12 +1980,12 @@ void AniCanvas::Translate(ani_env* env, ani_object obj, ani_double dx, ani_doubl
 
 void AniCanvas::ClipPath(ani_env* env, ani_object obj, ani_object pathObj, ani_object clipOpObj, ani_object aaObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::ClipPath canvas is nullptr.");
         return;
     }
-    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::ClipPath path is nullptr.");
         return;
@@ -2010,7 +2028,7 @@ void AniCanvas::ClipPath(ani_env* env, ani_object obj, ani_object pathObj, ani_o
 
 void AniCanvas::ClipRect(ani_env* env, ani_object obj, ani_object rectObj, ani_object clipOpObj, ani_object aaObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::ClipRect canvas is nullptr.");
         return;
@@ -2060,12 +2078,12 @@ void AniCanvas::ClipRect(ani_env* env, ani_object obj, ani_object rectObj, ani_o
 
 void AniCanvas::ClipRegion(ani_env* env, ani_object obj, ani_object regionObj, ani_object clipOpObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::ClipRegion canvas is nullptr.");
         return;
     }
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, regionObj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, regionObj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::ClipRegion canvas is nullptr.");
         return;
@@ -2095,12 +2113,13 @@ void AniCanvas::ClipRegion(ani_env* env, ani_object obj, ani_object regionObj, a
 void AniCanvas::ClipRoundRect(ani_env* env, ani_object obj, ani_object roundRectObj,
     ani_object clipOpObj, ani_object aaObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::ClipRoundRect canvas is nullptr.");
         return;
     }
-    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, roundRectObj);
+    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, roundRectObj,
+        AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniRoundRect == nullptr || aniRoundRect->GetRoundRect() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::ClipRoundRect roundRect is nullptr.");
@@ -2144,7 +2163,7 @@ void AniCanvas::ClipRoundRect(ani_env* env, ani_object obj, ani_object roundRect
 
 ani_boolean AniCanvas::IsClipEmpty(ani_env* env, ani_object obj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::IsClipEmpty canvas is nullptr.");
         return ANI_FALSE;
@@ -2157,12 +2176,12 @@ ani_boolean AniCanvas::IsClipEmpty(ani_env* env, ani_object obj)
 
 void AniCanvas::SetMatrix(ani_env* env, ani_object obj, ani_object matrixObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::SetMatrix canvas is nullptr.");
         return;
     }
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, matrixObj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, matrixObj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::SetMatrix matrix is nullptr.");
         return;
@@ -2173,7 +2192,7 @@ void AniCanvas::SetMatrix(ani_env* env, ani_object obj, ani_object matrixObj)
 
 void AniCanvas::ResetMatrix(ani_env* env, ani_object obj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniCanvas::ResetMatrix canvas is nullptr.");
         return;
@@ -2184,14 +2203,14 @@ void AniCanvas::ResetMatrix(ani_env* env, ani_object obj)
 
 ani_boolean AniCanvas::QuickRejectPath(ani_env* env, ani_object obj, ani_object pathObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::QuickRejectPath canvas is nullptr.");
         return ANI_FALSE;
     }
 
-    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, pathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::QuickRejectPath path is nullptr.");
@@ -2204,7 +2223,7 @@ ani_boolean AniCanvas::QuickRejectPath(ani_env* env, ani_object obj, ani_object
 
 ani_boolean AniCanvas::QuickRejectRect(ani_env* env, ani_object obj, ani_object rectObj)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, obj, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniCanvas::QuickRejectRect canvas is nullptr.");
@@ -2238,7 +2257,8 @@ ani_object AniCanvas::CreateAniCanvas(ani_env* env, Canvas* canvas)
     ani_ref aniRef;
     env->GetUndefined(&aniRef);
     auto aniCanvas = new AniCanvas(canvas);
-    ani_object aniObj = CreateAniObject(env, ANI_CLASS_CANVAS_NAME, nullptr, aniRef);
+    ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().canvas,
+        AniGlobalMethod::GetInstance().canvasCtor, aniRef);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj,
         NATIVE_OBJ, reinterpret_cast<ani_long>(aniCanvas))) {
         ROSEN_LOGE("aniCanvas failed cause by Object_SetFieldByName_Long");
@@ -2276,7 +2296,8 @@ ani_object AniCanvas::CanvasTransferStatic(ani_env* env, [[maybe_unused]]ani_obj
 #ifdef ROSEN_OHOS
     aniCanvas->mPixelMap_ = jsCanvas->GetPixelMap();
 #endif
-    ani_object aniCanvasObj = CreateAniObject(env, ANI_CLASS_CANVAS_NAME, nullptr, nullptr);
+    ani_object aniCanvasObj = CreateAniObject(env, AniGlobalClass::GetInstance().canvas,
+        AniGlobalMethod::GetInstance().canvasCtor, nullptr);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniCanvasObj, NATIVE_OBJ, reinterpret_cast<ani_long>(aniCanvas))) {
         ROSEN_LOGE("AniCanvas::CanvasTransferStatic failed create aniBrush");
         delete aniCanvas;
@@ -2287,7 +2308,7 @@ ani_object AniCanvas::CanvasTransferStatic(ani_env* env, [[maybe_unused]]ani_obj
 
 ani_long AniCanvas::GetCanvasAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, input);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, input, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ROSEN_LOGE("AniCanvas::GetCanvasAddr aniCanvas is null");
         return 0;
@@ -2298,7 +2319,7 @@ ani_long AniCanvas::GetCanvasAddr(ani_env* env, [[maybe_unused]]ani_object obj,
 ani_long AniCanvas::GetPixelMapAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
 #ifdef ROSEN_OHOS
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, input);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, input, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ROSEN_LOGE("AniCanvas::GetPixelMapAddr aniCanvas is null");
         return 0;
@@ -2314,7 +2335,7 @@ ani_long AniCanvas::GetPixelMapAddr(ani_env* env, [[maybe_unused]]ani_object obj
 
 ani_boolean AniCanvas::GetCanvasOwned(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, input);
+    auto aniCanvas = GetNativeFromObj<AniCanvas>(env, input, AniGlobalField::GetInstance().canvasNativeObj);
     if (aniCanvas == nullptr || aniCanvas->GetCanvas() == nullptr) {
         ROSEN_LOGE("AniCanvas::GetPixelMapAddr aniCanvas is null");
         return false;
diff --git a/interfaces/kits/ani/drawing/canvas_ani/ani_canvas.h b/interfaces/kits/ani/drawing/canvas_ani/ani_canvas.h
index ef210b2e7b..c137c81c20 100644
--- a/interfaces/kits/ani/drawing/canvas_ani/ani_canvas.h
+++ b/interfaces/kits/ani/drawing/canvas_ani/ani_canvas.h
@@ -88,13 +88,13 @@ public:
     static void DrawArcWithCenter(ani_env* env, ani_object obj, ani_object rectObj,
         ani_double startAngle, ani_double sweepAngle, ani_boolean useCenter);
     static void DrawPoint(ani_env* env, ani_object obj, ani_double x, ani_double y);
-    static void DrawPoints(ani_env* env, ani_object obj, ani_object pointsObj, ani_object aniPointMode);
+    static void DrawPoints(ani_env* env, ani_object obj, ani_array pointsObj, ani_object aniPointMode);
     static void DrawRegion(ani_env* env, ani_object obj, ani_object regionObj);
     static void DrawPixelMapMesh(ani_env* env, ani_object obj,
         ani_object pixelmapObj, ani_int aniMeshWidth, ani_int aniMeshHeight,
-        ani_object verticesObj, ani_int aniVertOffset, ani_object colorsObj, ani_int aniColorOffset);
+        ani_array verticesObj, ani_int aniVertOffset, ani_array colorsObj, ani_int aniColorOffset);
     static void DrawVertices(ani_env* env, ani_object obj, ani_enum_item aniVertexMode,
-        ani_int aniVertexCount, ani_object positionsObj, ani_object texsObj,
+        ani_int aniVertexCount, ani_array positionsObj, ani_object texsObj,
         ani_object colorsObj, ani_int aniIndexCount, ani_object indicesObj, ani_enum_item aniBlendMode);
     static void AttachBrush(ani_env* env, ani_object obj, ani_object brushObj);
     static void AttachPen(ani_env* env, ani_object obj, ani_object penObj);
@@ -141,21 +141,21 @@ private:
         Drawing::Rect& rect, AniSamplingOptions* samplingOptions);
     void DrawImageRectWithSrcInner(std::shared_ptr<Media::PixelMap> pixelmap, Drawing::Rect& srcRect,
         Drawing::Rect& dstRect, AniSamplingOptions* samplingOptions, int32_t srcRectConstraint);
-    static bool GetVertices(ani_env* env, ani_object verticesObj, float* vertices, uint32_t verticesSize);
-    static bool GetVerticesUint16(ani_env* env, ani_object verticesObj, uint16_t* vertices, uint32_t verticesSize);
-    static bool GetColorsUint32(ani_env* env, ani_object colorsObj, uint32_t* colors, uint32_t colorsSize);
+    static bool GetVertices(ani_env* env, ani_array verticesObj, float* vertices, uint32_t verticesSize);
+    static bool GetVerticesUint16(ani_env* env, ani_array verticesObj, uint16_t* vertices, uint32_t verticesSize);
+    static bool GetColorsUint32(ani_env* env, ani_array colorsObj, uint32_t* colors, uint32_t colorsSize);
     static bool GetVertexModeAndBlendMode(ani_env* env, ani_enum_item aniVertexMode, ani_enum_item aniBlendMode,
         VertexMode& vertexMode, BlendMode& blendMode);
     static bool GetIndices(ani_env* env, ani_int indexCount, ani_object indicesObj,
         std::unique_ptr<uint16_t[]>& indices);
     static bool GetColors(ani_env* env, ani_int vertexCount, ani_object colorsObj,
         std::unique_ptr<uint32_t[]>& colors);
-    static bool GetPositions(ani_env* env, ani_int vertexCount, ani_object positionsObj,
+    static bool GetPositions(ani_env* env, ani_int vertexCount, ani_array positionsObj,
         std::vector<Drawing::Point>& pointPositions);
     static bool GetTexs(ani_env* env, ani_int vertexCount, ani_object texsObj,
         std::vector<Drawing::Point>& pointTexs);
     static bool CheckDrawVerticesParams(ani_env* env, ani_int& vertexCount, ani_int& indexCount);
-    static void GetColorsAndDraw(ani_env* env, ani_object colorsObj, int32_t colorOffset,
+    static void GetColorsAndDraw(ani_env* env, ani_array colorsObj, int32_t colorOffset,
         DrawPixelMapMeshArgs& args, AniCanvas* aniCanvas);
     std::shared_ptr<Media::PixelMap>* GetPixelMapPtrAddr();
 #endif
diff --git a/interfaces/kits/ani/drawing/color_filter_ani/ani_color_filter.cpp b/interfaces/kits/ani/drawing/color_filter_ani/ani_color_filter.cpp
index a365c18758..f76bcfb9c2 100644
--- a/interfaces/kits/ani/drawing/color_filter_ani/ani_color_filter.cpp
+++ b/interfaces/kits/ani/drawing/color_filter_ani/ani_color_filter.cpp
@@ -26,9 +26,8 @@ namespace Drawing {
 
 ani_status AniColorFilter::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_COLORFILTER_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().colorFilter;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_COLORFILTER_NAME);
         return ANI_NOT_FOUND;
     }
@@ -51,7 +50,7 @@ ani_status AniColorFilter::AniInit(ani_env *env)
         ani_native_function { "createSRGBGammaToLinear", nullptr, reinterpret_cast<void*>(CreateSRGBGammaToLinear) },
     };
 
-    ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s ret: %{public}d", ANI_CLASS_COLORFILTER_NAME, ret);
         return ANI_NOT_FOUND;
@@ -153,7 +152,8 @@ ani_object AniColorFilter::ColorFilterTransferStatic(ani_env* env, [[maybe_unuse
 
 ani_long AniColorFilter::GetColorFilterAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniColorFilter = GetNativeFromObj<AniColorFilter>(env, input);
+    auto aniColorFilter = GetNativeFromObj<AniColorFilter>(env, input,
+        AniGlobalField::GetInstance().colorFilterNativeObj);
     if (aniColorFilter == nullptr || aniColorFilter->GetColorFilter() == nullptr) {
         ROSEN_LOGE("AniColorFilter::GetColorFilterAddr aniColorFilter is null");
         return 0;
@@ -209,15 +209,16 @@ ani_object AniColorFilter::CreateLightingColorFilter(
 }
 
 ani_object AniColorFilter::CreateMatrixColorFilter(
-    ani_env* env, [[maybe_unused]]ani_object obj, ani_object aniMatrixArrayObj)
+    ani_env* env, [[maybe_unused]]ani_object obj, ani_array aniMatrixArrayObj)
 {
-    ani_int aniLength;
-    ani_status ret = env->Object_GetPropertyByName_Int(aniMatrixArrayObj, "length", &aniLength);
+    ani_size length;
+    ani_status ret = env->Array_GetLength(aniMatrixArrayObj, &length);
     if (ret != ANI_OK) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param matrix.");
         return CreateAniUndefined(env);
     }
-    uint32_t arraySize = static_cast<uint32_t>(aniLength);
+
+    uint32_t arraySize = static_cast<uint32_t>(length);
     if (arraySize != ColorMatrix::MATRIX_SIZE) {
         ROSEN_LOGD("AniColorFilter::CreateMatrixColorFilter aniMatrixArrayObj size is invalid %{public}u.", arraySize);
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid matrix array size.");
@@ -226,16 +227,15 @@ ani_object AniColorFilter::CreateMatrixColorFilter(
     std::unique_ptr<float[]> matrixArray = std::make_unique<float[]>(arraySize);
     for (uint32_t i = 0; i < arraySize; i++) {
         ani_double value;
-        ani_ref valueRef;
-        ret = env->Object_CallMethodByName_Ref(aniMatrixArrayObj, "$_get", "i:Y", &valueRef,
-            static_cast<ani_int>(i));
+        ani_ref aniRef = nullptr;
+        ret = env->Array_Get(aniMatrixArrayObj, i, &aniRef);
         if (ret != ANI_OK) {
             ROSEN_LOGD("AniColorFilter::CreateMatrixColorFilter get matrix array element failed %{public}d", ret);
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid matrix array element.");
             return CreateAniUndefined(env);
         }
-
-        ret = env->Object_CallMethodByName_Double(static_cast<ani_object>(valueRef), "toDouble", ":d", &value);
+        ret = env->Object_CallMethod_Double(
+            reinterpret_cast<ani_object>(aniRef), AniGlobalMethod::GetInstance().doubleGet, &value);
         if (ret != ANI_OK) {
             ROSEN_LOGD("AniColorFilter::CreateMatrixColorFilter get matrix array element failed %{public}d", ret);
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid matrix array element.");
@@ -259,12 +259,14 @@ ani_object AniColorFilter::CreateMatrixColorFilter(
 ani_object AniColorFilter::CreateComposeColorFilter(
     ani_env* env, [[maybe_unused]] ani_object obj, ani_object aniOuterColorFilterObj, ani_object aniInnerColorFilterObj)
 {
-    auto aniOuterColorFilter = GetNativeFromObj<AniColorFilter>(env, aniOuterColorFilterObj);
+    auto aniOuterColorFilter = GetNativeFromObj<AniColorFilter>(env, aniOuterColorFilterObj,
+        AniGlobalField::GetInstance().colorFilterNativeObj);
     if (aniOuterColorFilter == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid param outer.");
         return CreateAniUndefined(env);
     }
-    auto aniInnerColorFilter = GetNativeFromObj<AniColorFilter>(env, aniInnerColorFilterObj);
+    auto aniInnerColorFilter = GetNativeFromObj<AniColorFilter>(env, aniInnerColorFilterObj,
+        AniGlobalField::GetInstance().colorFilterNativeObj);
     if (aniInnerColorFilter == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid param inner.");
         return CreateAniUndefined(env);
diff --git a/interfaces/kits/ani/drawing/color_filter_ani/ani_color_filter.h b/interfaces/kits/ani/drawing/color_filter_ani/ani_color_filter.h
index 4f6442828a..b3e567c115 100644
--- a/interfaces/kits/ani/drawing/color_filter_ani/ani_color_filter.h
+++ b/interfaces/kits/ani/drawing/color_filter_ani/ani_color_filter.h
@@ -39,7 +39,7 @@ public:
     static ani_object CreateLightingColorFilter(
         ani_env* env, ani_object obj, ani_double aniMultiplyColor, ani_double addColor);
 
-    static ani_object CreateMatrixColorFilter(ani_env* env, ani_object obj, ani_object aniMatrixArrayObj);
+    static ani_object CreateMatrixColorFilter(ani_env* env, ani_object obj, ani_array aniMatrixArrayObj);
 
     static ani_object CreateComposeColorFilter(
     ani_env* env, ani_object obj, ani_object aniOuterColorFilterObj, ani_object aniInnerColorFilterObj);
diff --git a/interfaces/kits/ani/drawing/font_ani/ani_font.cpp b/interfaces/kits/ani/drawing/font_ani/ani_font.cpp
index 06d52af1bb..a72f310526 100644
--- a/interfaces/kits/ani/drawing/font_ani/ani_font.cpp
+++ b/interfaces/kits/ani/drawing/font_ani/ani_font.cpp
@@ -30,9 +30,6 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_FONT_NAME = "@ohos.graphics.drawing.drawing.Font";
-const char* ANI_FONT_HINTING_NAME = "@ohos.graphics.drawing.drawing.FontHinting";
-const char* ANI_FONT_EDGING_NAME = "@ohos.graphics.drawing.drawing.FontEdging";
 
 static std::string GetFontHintingItemName(FontHinting hinting)
 {
@@ -66,7 +63,7 @@ static std::string GetFontEdgingItemName(FontEdging edging)
 
 ani_object CreateAniFontMetrics(ani_env* env, const FontMetrics& fontMetrics)
 {
-    ani_object aniFontMetrics = CreateAniObjectWithCls(env, AniGlobalClass::GetInstance().fontMetrics,
+    ani_object aniFontMetrics = CreateAniObject(env, AniGlobalClass::GetInstance().fontMetrics,
         AniGlobalMethod::GetInstance().fontMetricsCtor,
         ani_int(static_cast<int>(fontMetrics.fFlags)),
         ani_double(fontMetrics.fTop),
@@ -142,13 +139,12 @@ static const std::array g_methods = {
 
 ani_status AniFont::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_FONT_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().font;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_FONT_NAME);
         return ANI_NOT_FOUND;
     }
-    ret = env->Class_BindNativeMethods(cls, g_methods.data(), g_methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, g_methods.data(), g_methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_FONT_NAME);
         return ANI_NOT_FOUND;
@@ -181,7 +177,7 @@ void AniFont::Constructor(ani_env* env, ani_object obj)
 
 ani_object AniFont::GetMetrics(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetTypeface font is nullptr.");
         return ani_object{};
@@ -194,7 +190,7 @@ ani_object AniFont::GetMetrics(ani_env* env, ani_object obj)
 
 ani_double AniFont::GetSize(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetSize font is nullptr.");
         return -1;
@@ -205,7 +201,7 @@ ani_double AniFont::GetSize(ani_env* env, ani_object obj)
 
 ani_object AniFont::GetTypeface(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetMetrics font is nullptr.");
         return ani_object{};
@@ -213,7 +209,8 @@ ani_object AniFont::GetTypeface(ani_env* env, ani_object obj)
 
     std::shared_ptr<Typeface> typeface = aniFont->GetFont()->GetTypeface();
     AniTypeface* aniTypeface = new AniTypeface(typeface);
-    ani_object aniObj = CreateAniObject(env, "@ohos.graphics.drawing.drawing.Typeface", nullptr);
+    ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().typeface,
+        AniGlobalMethod::GetInstance().typefaceCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj,
         NATIVE_OBJ, reinterpret_cast<ani_long>(aniTypeface))) {
         ROSEN_LOGE("AniFont::GetTypeface failed cause by Object_SetFieldByName_Long");
@@ -225,7 +222,7 @@ ani_object AniFont::GetTypeface(ani_env* env, ani_object obj)
 
 void AniFont::EnableSubpixel(ani_env* env, ani_object obj, ani_boolean isSubpixel)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::EnableSubpixel font is nullptr.");
         return;
@@ -237,7 +234,7 @@ void AniFont::EnableSubpixel(ani_env* env, ani_object obj, ani_boolean isSubpixe
 
 void AniFont::EnableEmbolden(ani_env* env, ani_object obj, ani_boolean isEmbolden)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::EnableEmbolden font is nullptr.");
         return;
@@ -249,7 +246,7 @@ void AniFont::EnableEmbolden(ani_env* env, ani_object obj, ani_boolean isEmbolde
 
 void AniFont::EnableLinearMetrics(ani_env* env, ani_object obj, ani_boolean isLinearMetrics)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniFont::EnableLinearMetrics font is nullptr.");
@@ -262,7 +259,7 @@ void AniFont::EnableLinearMetrics(ani_env* env, ani_object obj, ani_boolean isLi
 
 void AniFont::SetSize(ani_env* env, ani_object obj, ani_double size)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::SetSize font is nullptr.");
         return;
@@ -273,13 +270,13 @@ void AniFont::SetSize(ani_env* env, ani_object obj, ani_double size)
 
 void AniFont::SetTypeface(ani_env* env, ani_object obj, ani_object typeface)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::SetTypeface font is nullptr.");
         return;
     }
 
-    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, typeface);
+    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, typeface, AniGlobalField::GetInstance().typefaceNativeObj);
     if (aniTypeface == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::SetTypeface typeface is nullptr.");
         return;
@@ -290,7 +287,7 @@ void AniFont::SetTypeface(ani_env* env, ani_object obj, ani_object typeface)
 
 ani_double AniFont::MeasureSingleCharacter(ani_env* env, ani_object obj, ani_string text)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniFont::MeasureSingleCharacter font is nullptr.");
@@ -325,7 +322,7 @@ ani_double AniFont::MeasureSingleCharacter(ani_env* env, ani_object obj, ani_str
 
 ani_double AniFont::MeasureText(ani_env* env, ani_object obj, ani_string aniText, ani_enum_item encoding)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::MeasureText font is nullptr.");
         return -1;
@@ -353,7 +350,7 @@ ani_double AniFont::MeasureText(ani_env* env, ani_object obj, ani_string aniText
 
 void AniFont::SetScaleX(ani_env* env, ani_object obj, ani_double scaleX)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::SetScaleX font is nullptr.");
         return;
@@ -364,7 +361,7 @@ void AniFont::SetScaleX(ani_env* env, ani_object obj, ani_double scaleX)
 
 void AniFont::SetBaselineSnap(ani_env* env, ani_object obj, ani_boolean isBaselineSnap)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::SetBaselineSnap font is nullptr.");
         return;
@@ -376,7 +373,7 @@ void AniFont::SetBaselineSnap(ani_env* env, ani_object obj, ani_boolean isBaseli
 
 ani_boolean AniFont::IsBaselineSnap(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::IsBaselineSnap font is nullptr.");
         return ANI_FALSE;
@@ -388,7 +385,7 @@ ani_boolean AniFont::IsBaselineSnap(ani_env* env, ani_object obj)
 
 void AniFont::SetEmbeddedBitmaps(ani_env* env, ani_object obj, ani_boolean isEmbeddedBitmaps)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::SetEmbeddedBitmaps font is nullptr.");
         return;
@@ -400,7 +397,7 @@ void AniFont::SetEmbeddedBitmaps(ani_env* env, ani_object obj, ani_boolean isEmb
 
 ani_boolean AniFont::IsEmbeddedBitmaps(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::IsEmbeddedBitmaps font is nullptr.");
         return ANI_FALSE;
@@ -412,7 +409,7 @@ ani_boolean AniFont::IsEmbeddedBitmaps(ani_env* env, ani_object obj)
 
 void AniFont::SetForceAutoHinting(ani_env* env, ani_object obj, ani_boolean isForceAutoHinting)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniFont::SetForceAutoHinting font is nullptr.");
@@ -423,17 +420,17 @@ void AniFont::SetForceAutoHinting(ani_env* env, ani_object obj, ani_boolean isFo
     aniFont->GetFont()->SetForceAutoHinting(forceAutoHinting);
 }
 
-ani_object AniFont::GetWidths(ani_env* env, ani_object obj, ani_object glyphs)
+ani_object AniFont::GetWidths(ani_env* env, ani_object obj, ani_array glyphs)
 {
     ani_object arrayObj = CreateAniUndefined(env);
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetWidths font is nullptr.");
         return arrayObj;
     }
 
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(glyphs, "length", &aniLength) || aniLength == 0) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(glyphs, &aniLength) || aniLength == 0) {
         ROSEN_LOGE("AniFont::GetWidths Failed to get size of glyph array");
         return arrayObj;
     }
@@ -442,10 +439,9 @@ ani_object AniFont::GetWidths(ani_env* env, ani_object obj, ani_object glyphs)
     for (uint32_t i = 0; i < fontSize; i++) {
         ani_int glyph;
         ani_ref glyphRef;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(
-            glyphs, "$_get", "i:Y", &glyphRef, (ani_int)i) ||
-            ANI_OK != env->Object_CallMethodByName_Int(
-                static_cast<ani_object>(glyphRef), "toInt", ":i", &glyph)) {
+        if (ANI_OK != env->Array_Get(glyphs, (ani_int)i, &glyphRef) ||
+            ANI_OK != env->Object_CallMethod_Int(
+                static_cast<ani_object>(glyphRef), AniGlobalMethod::GetInstance().intGet, &glyph)) {
             ROSEN_LOGE("AniFont::GetWidths Incorrect parameter glyph type.");
             return arrayObj;
         }
@@ -465,11 +461,13 @@ ani_object AniFont::GetWidths(ani_env* env, ani_object obj, ani_object glyphs)
     }
 
     for (uint32_t i = 0; i < fontSize; i++) {
-        ani_object aniObj = CreateAniObject(env, ANI_DOUBLE_STRING, "d:", widthPtr[i]);
+        ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().doubleCls,
+            AniGlobalMethod::GetInstance().doubleCtor, widthPtr[i]);
         if (aniObj == CreateAniUndefined(env)) {
             return CreateAniUndefined(env);
         }
-        ani_status ret = env->Object_CallMethodByName_Void(arrayObj, "$_set", "iY:", (ani_int)i, aniObj);
+        ani_status ret = env->Object_CallMethod_Void(
+            arrayObj, AniGlobalMethod::GetInstance().arraySet, (ani_int)i, aniObj);
         if (ret != ANI_OK) {
             ROSEN_LOGE("AniFont::GetWidths Failed to set width item");
             return CreateAniUndefined(env);
@@ -482,7 +480,7 @@ ani_object AniFont::TextToGlyphs(ani_env* env, ani_object obj, ani_string aniTex
 {
     std::string text = CreateStdString(env, aniText);
     ani_object arrayObj = CreateAniUndefined(env);
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::TextToGlyphs font is nullptr.");
         return arrayObj;
@@ -497,7 +495,7 @@ ani_object AniFont::TextToGlyphs(ani_env* env, ani_object obj, ani_string aniTex
     env->Reference_IsUndefined(glyphCount, &isUndefined);
     if (!isUndefined) {
         ani_int aniGlyphCount;
-        if (ANI_OK != env->Object_CallMethodByName_Int(glyphCount, "toInt", ":i", &aniGlyphCount)) {
+        if (ANI_OK != env->Object_CallMethod_Int(glyphCount, AniGlobalMethod::GetInstance().intGet, &aniGlyphCount)) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniFont::TextToGlyphs incorrect type glyph.");
             return arrayObj;
@@ -519,13 +517,14 @@ ani_object AniFont::TextToGlyphs(ani_env* env, ani_object obj, ani_string aniTex
     }
 
     for (uint32_t i = 0; i < count; i++) {
-        ani_object aniObj = CreateAniObject(env, ANI_INT_STRING, "i:", glyphPtr[i]);
+        ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().intCls,
+            AniGlobalMethod::GetInstance().intCtor, glyphPtr[i]);
         if (aniObj == CreateAniUndefined(env)) {
             ROSEN_LOGE("AniFont::GetWidths Failed to create Int object");
             return CreateAniUndefined(env);
         }
-        ani_status ret = env->Object_CallMethodByName_Void(arrayObj, "$_set",
-            "iY:", (ani_int)i, aniObj);
+        ani_status ret = env->Object_CallMethod_Void(
+            arrayObj, AniGlobalMethod::GetInstance().arraySet, (ani_int)i, aniObj);
         if (ret != ANI_OK) {
             ROSEN_LOGE("AniFont::TextToGlyphs Failed to set width item");
             return CreateAniUndefined(env);
@@ -536,7 +535,7 @@ ani_object AniFont::TextToGlyphs(ani_env* env, ani_object obj, ani_string aniTex
 
 ani_boolean AniFont::IsSubpixel(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::IsSubpixel font is nullptr.");
         return ANI_FALSE;
@@ -548,7 +547,7 @@ ani_boolean AniFont::IsSubpixel(ani_env* env, ani_object obj)
 
 ani_boolean AniFont::IsLinearMetrics(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::IsLinearMetrics font is nullptr.");
         return ANI_FALSE;
@@ -560,7 +559,7 @@ ani_boolean AniFont::IsLinearMetrics(ani_env* env, ani_object obj)
 
 ani_double AniFont::GetSkewX(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetSkewX font is nullptr.");
         return -1;
@@ -572,7 +571,7 @@ ani_double AniFont::GetSkewX(ani_env* env, ani_object obj)
 
 ani_boolean AniFont::IsEmbolden(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::IsEmbolden font is nullptr.");
         return ANI_FALSE;
@@ -584,7 +583,7 @@ ani_boolean AniFont::IsEmbolden(ani_env* env, ani_object obj)
 
 void AniFont::SetHinting(ani_env* env, ani_object obj, ani_enum_item hinting)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::SetHinting font is nullptr.");
         return;
@@ -606,7 +605,7 @@ void AniFont::SetHinting(ani_env* env, ani_object obj, ani_enum_item hinting)
 
 ani_int AniFont::CountText(ani_env* env, ani_object obj, ani_string aniText)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::CountText font is nullptr.");
         return -1;
@@ -622,7 +621,7 @@ ani_int AniFont::CountText(ani_env* env, ani_object obj, ani_string aniText)
 
 void AniFont::SetSkewX(ani_env* env, ani_object obj, ani_double skewX)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::SetSkewX font is nullptr.");
         return;
@@ -633,7 +632,7 @@ void AniFont::SetSkewX(ani_env* env, ani_object obj, ani_double skewX)
 
 void AniFont::SetEdging(ani_env* env, ani_object obj, ani_enum_item edging)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::SetEdging font is nullptr.");
         return;
@@ -655,7 +654,7 @@ void AniFont::SetEdging(ani_env* env, ani_object obj, ani_enum_item edging)
 
 ani_boolean AniFont::IsForceAutoHinting(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::IsForceAutoHinting font is nullptr.");
         return ANI_FALSE;
@@ -667,7 +666,7 @@ ani_boolean AniFont::IsForceAutoHinting(ani_env* env, ani_object obj)
 
 ani_double AniFont::GetScaleX(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetScaleX font is nullptr.");
         return -1;
@@ -679,50 +678,34 @@ ani_double AniFont::GetScaleX(ani_env* env, ani_object obj)
 
 ani_enum_item AniFont::GetHinting(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetHinting font is nullptr.");
         return {};
     }
     FontHinting hinting = aniFont->GetFont()->GetHinting();
-
-    ani_enum type;
-    if (ANI_OK != env->FindEnum(ANI_FONT_HINTING_NAME, &type)) {
-        ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
-            "Find enum for FontHinting failed.");
-        return {};
-    }
-
     std::string itemName = GetFontHintingItemName(hinting);
     ani_enum_item enumItem;
-    if (ANI_OK != env->Enum_GetEnumItemByName(type, itemName.c_str(), &enumItem)) {
+    if (!CreateAniEnumByEnumName(env, AniGlobalEnum::GetInstance().fontHinting, itemName, enumItem)) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
-            "Failed to obtain the FontHinting enumeration.");
+            "Find enum for FontHinting failed.");
         return {};
     }
-
     return enumItem;
 }
 
 ani_enum_item AniFont::GetEdging(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetEdging font is nullptr.");
         return {};
     }
     FontEdging edging = aniFont->GetFont()->GetEdging();
-
-    ani_enum type;
-    if (ANI_OK != env->FindEnum(ANI_FONT_EDGING_NAME, &type)) {
-        ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Find enum for FontEdging failed.");
-        return {};
-    }
-
     std::string itemName = GetFontEdgingItemName(edging);
     ani_enum_item enumItem;
-    if (ANI_OK != env->Enum_GetEnumItemByName(type, itemName.c_str(), &enumItem)) {
-        ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Failed to obtain the FontEdging enumeration.");
+    if (!CreateAniEnumByEnumName(env, AniGlobalEnum::GetInstance().fontEdging, itemName, enumItem)) {
+        ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Find enum for FontEdging failed.");
         return {};
     }
 
@@ -732,7 +715,7 @@ ani_enum_item AniFont::GetEdging(ani_env* env, ani_object obj)
 ani_object AniFont::CreatePathForGlyph(ani_env* env, ani_object obj, ani_int index)
 {
     ani_object aniObj = CreateAniUndefined(env);
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::CreatePathForGlyph font is nullptr.");
         return aniObj;
@@ -747,7 +730,8 @@ ani_object AniFont::CreatePathForGlyph(ani_env* env, ani_object obj, ani_int ind
         return aniObj;
     }
     AniPath* aniPath = new AniPath(path);
-    aniObj = CreateAniObject(env, ANI_CLASS_PATH_NAME, ":");
+    aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().path,
+        AniGlobalMethod::GetInstance().pathCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj,
         NATIVE_OBJ, reinterpret_cast<ani_long>(aniPath))) {
         ROSEN_LOGE("AniFont::CreatePathForGlyph failed cause by Object_SetFieldByName_Long");
@@ -757,17 +741,17 @@ ani_object AniFont::CreatePathForGlyph(ani_env* env, ani_object obj, ani_int ind
     return aniObj;
 }
 
-ani_object AniFont::GetBounds(ani_env* env, ani_object obj, ani_object glyphs)
+ani_object AniFont::GetBounds(ani_env* env, ani_object obj, ani_array glyphs)
 {
     ani_object arrayObj = CreateAniUndefined(env);
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetBounds font is nullptr.");
         return arrayObj;
     }
 
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(glyphs, "length", &aniLength) || aniLength == 0) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(glyphs, &aniLength) || aniLength == 0) {
         ROSEN_LOGE("AniFont::GetBounds Failed to get size of glyph array %d", aniLength);
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetBounds Invalid params.");
         return arrayObj;
@@ -778,10 +762,9 @@ ani_object AniFont::GetBounds(ani_env* env, ani_object obj, ani_object glyphs)
     for (uint32_t i = 0; i < glyphscnt; i++) {
         ani_int glyph;
         ani_ref glyphRef;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(
-            glyphs, "$_get", "i:Y", &glyphRef, (ani_int)i) ||
-            ANI_OK != env->Object_CallMethodByName_Int(
-                static_cast<ani_object>(glyphRef), "toInt", ":i", &glyph)) {
+        if (ANI_OK != env->Array_Get(glyphs, (ani_int)i, &glyphRef) ||
+            ANI_OK != env->Object_CallMethod_Int(
+                static_cast<ani_object>(glyphRef), AniGlobalMethod::GetInstance().intGet, &glyph)) {
             ROSEN_LOGE("AniFont::GetBounds Incorrect parameter glyph type.");
             return arrayObj;
         }
@@ -803,7 +786,8 @@ ani_object AniFont::GetBounds(ani_env* env, ani_object obj, ani_object glyphs)
     for (uint32_t i = 0; i < glyphscnt; i++) {
         ani_object aniObj;
         CreateRectObj(env, rectPtr[i], aniObj);
-        ani_status ret = env->Object_CallMethodByName_Void(arrayObj, "$_set", "iY:", (ani_int)i, aniObj);
+        ani_status ret = env->Object_CallMethod_Void(
+            arrayObj, AniGlobalMethod::GetInstance().arraySet, (ani_int)i, aniObj);
         if (ret != ANI_OK) {
             ROSEN_LOGE("AniFont::GetBounds Failed to set rect item");
             return CreateAniUndefined(env);
@@ -815,7 +799,7 @@ ani_object AniFont::GetBounds(ani_env* env, ani_object obj, ani_object glyphs)
 ani_object AniFont::GetTextPath(ani_env* env, ani_object obj, ani_string aniText,
     ani_int byteLength, ani_double x, ani_double y)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniFont::GetTextPath font is nullptr.");
         return CreateAniUndefined(env);
@@ -828,7 +812,8 @@ ani_object AniFont::GetTextPath(ani_env* env, ani_object obj, ani_string aniText
     std::shared_ptr<Path> path = std::make_shared<Path>();
     realFont->GetTextPath(text.c_str(), byteLength, TextEncoding::UTF8, x, y, path.get());
     AniPath* aniPath = new AniPath(path);
-    ani_object aniObj = CreateAniObject(env, ANI_CLASS_PATH_NAME, ":");
+    ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().path,
+        AniGlobalMethod::GetInstance().pathCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj,
         NATIVE_OBJ, reinterpret_cast<ani_long>(aniPath))) {
         ROSEN_LOGE("AniFont::GetTextPath failed cause by Object_SetFieldByName_Long");
@@ -840,7 +825,7 @@ ani_object AniFont::GetTextPath(ani_env* env, ani_object obj, ani_string aniText
 
 void AniFont::SetThemeFontFollowed(ani_env* env, ani_object obj, ani_boolean followed)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniFont::SetThemeFontFollowed font is nullptr.");
@@ -853,7 +838,7 @@ void AniFont::SetThemeFontFollowed(ani_env* env, ani_object obj, ani_boolean fol
 
 ani_boolean AniFont::IsThemeFontFollowed(ani_env* env, ani_object obj)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, obj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, obj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniFont::IsThemeFontFollowed font is nullptr.");
@@ -895,7 +880,7 @@ ani_object AniFont::FontTransferStatic(
 
 ani_long AniFont::GetFontAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, input);
+    auto aniFont = GetNativeFromObj<AniFont>(env, input, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ROSEN_LOGE("AniFont::GetFontAddr aniFont is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/font_ani/ani_font.h b/interfaces/kits/ani/drawing/font_ani/ani_font.h
index da5aefd3ec..3ecb82c317 100644
--- a/interfaces/kits/ani/drawing/font_ani/ani_font.h
+++ b/interfaces/kits/ani/drawing/font_ani/ani_font.h
@@ -47,7 +47,7 @@ public:
     static void SetEmbeddedBitmaps(ani_env* env, ani_object obj, ani_boolean isEmbeddedBitmaps);
     static ani_boolean IsEmbeddedBitmaps(ani_env* env, ani_object obj);
     static void SetForceAutoHinting(ani_env* env, ani_object obj, ani_boolean isForceAutoHinting);
-    static ani_object GetWidths(ani_env* env, ani_object obj, ani_object glyphs);
+    static ani_object GetWidths(ani_env* env, ani_object obj, ani_array glyphs);
     static ani_object TextToGlyphs(ani_env* env, ani_object obj, ani_string aniText, ani_object glyphCount);
     static ani_boolean IsSubpixel(ani_env* env, ani_object obj);
     static ani_boolean IsLinearMetrics(ani_env* env, ani_object obj);
@@ -62,7 +62,7 @@ public:
     static ani_enum_item GetHinting(ani_env* env, ani_object obj);
     static ani_enum_item GetEdging(ani_env* env, ani_object obj);
     static ani_object CreatePathForGlyph(ani_env* env, ani_object obj, ani_int index);
-    static ani_object GetBounds(ani_env* env, ani_object obj, ani_object glyphs);
+    static ani_object GetBounds(ani_env* env, ani_object obj, ani_array glyphs);
     static ani_object GetTextPath(ani_env* env, ani_object obj, ani_string aniText,
         ani_int byteLength, ani_double x, ani_double y);
     static void SetThemeFontFollowed(ani_env* env, ani_object obj, ani_boolean followed);
diff --git a/interfaces/kits/ani/drawing/image_filter_ani/ani_image_filter.cpp b/interfaces/kits/ani/drawing/image_filter_ani/ani_image_filter.cpp
index ccd1514c82..ff4ee2a877 100644
--- a/interfaces/kits/ani/drawing/image_filter_ani/ani_image_filter.cpp
+++ b/interfaces/kits/ani/drawing/image_filter_ani/ani_image_filter.cpp
@@ -20,13 +20,10 @@
 namespace OHOS::Rosen {
 namespace Drawing {
 
-const char* ANI_CLASS_IMAGEFILTER_NAME = "@ohos.graphics.drawing.drawing.ImageFilter";
-
 ani_status AniImageFilter::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_IMAGEFILTER_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().imageFilter;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_IMAGEFILTER_NAME);
         return ANI_NOT_FOUND;
     }
@@ -36,7 +33,7 @@ ani_status AniImageFilter::AniInit(ani_env *env)
         ani_native_function { "createBlurImageFilter", nullptr, reinterpret_cast<void*>(CreateBlurImageFilter) },
     };
 
-    ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail. ret %{public}d %{public}s", ret, ANI_CLASS_IMAGEFILTER_NAME);
         return ANI_NOT_FOUND;
@@ -48,7 +45,8 @@ ani_status AniImageFilter::AniInit(ani_env *env)
 ani_object AniImageFilter::CreateFromColorFilter(
     ani_env* env, [[maybe_unused]]ani_object obj, ani_object aniColorFilterObj, ani_object aniImageFilterObj)
 {
-    auto aniColorFilter = GetNativeFromObj<AniColorFilter>(env, aniColorFilterObj);
+    auto aniColorFilter = GetNativeFromObj<AniColorFilter>(env, aniColorFilterObj,
+        AniGlobalField::GetInstance().colorFilterNativeObj);
     if (aniColorFilter == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param colorFilter.");
         return CreateAniUndefined(env);
@@ -60,7 +58,8 @@ ani_object AniImageFilter::CreateFromColorFilter(
     env->Reference_IsUndefined(aniImageFilterObj, &isImageFilterUndefined);
     AniImageFilter* aniImageFilter = nullptr;
     if (!isImageFilterNull && !isImageFilterUndefined) {
-        aniImageFilter = GetNativeFromObj<AniImageFilter>(env, aniImageFilterObj);
+        aniImageFilter = GetNativeFromObj<AniImageFilter>(env, aniImageFilterObj,
+            AniGlobalField::GetInstance().imageFilterNativeObj);
         if (aniImageFilter == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param imageFilter.");
             return CreateAniUndefined(env);
@@ -87,7 +86,8 @@ ani_object AniImageFilter::CreateBlurImageFilter(ani_env* env, [[maybe_unused]]a
     env->Reference_IsUndefined(aniImageFilterObj, &isImageFilterUndefined);
     AniImageFilter* aniImageFilter = nullptr;
     if (!isImageFilterNull && !isImageFilterUndefined) {
-        aniImageFilter = GetNativeFromObj<AniImageFilter>(env, aniImageFilterObj);
+        aniImageFilter = GetNativeFromObj<AniImageFilter>(env, aniImageFilterObj,
+            AniGlobalField::GetInstance().imageFilterNativeObj);
         if (aniImageFilter == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param imageFilter.");
             return CreateAniUndefined(env);
diff --git a/interfaces/kits/ani/drawing/lattice_ani/ani_lattice.cpp b/interfaces/kits/ani/drawing/lattice_ani/ani_lattice.cpp
index aef150e1a3..69c9768a6d 100644
--- a/interfaces/kits/ani/drawing/lattice_ani/ani_lattice.cpp
+++ b/interfaces/kits/ani/drawing/lattice_ani/ani_lattice.cpp
@@ -22,12 +22,11 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_ANI_LATTICE_NAME = "@ohos.graphics.drawing.drawing.Lattice";
 struct LatticeCreationParams {
     ani_env* env;
     ani_object obj;
-    ani_object xDivs;
-    ani_object yDivs;
+    ani_array xDivs;
+    ani_array yDivs;
     ani_int fXCount;
     ani_int fYCount;
     ani_object fBounds;
@@ -36,10 +35,10 @@ struct LatticeCreationParams {
     bool isColorArray;
 };
 
-bool GetLatticeDividers(ani_env* env, ani_object dividersArray, uint32_t count, std::vector<int>& dividers)
+bool GetLatticeDividers(ani_env* env, ani_array dividersArray, uint32_t count, std::vector<int>& dividers)
 {
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(dividersArray, "length", &aniLength)) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(dividersArray, &aniLength)) {
         ROSEN_LOGE("AniLattice::CreateImageLattice dividers are invalid");
         return false;
     }
@@ -54,14 +53,14 @@ bool GetLatticeDividers(ani_env* env, ani_object dividersArray, uint32_t count,
         for (uint32_t i = 0; i < dividersSize; i++) {
             ani_int divider;
             ani_ref dividerRef;
-            int ret = 0;
-            if ((ret = env->Object_CallMethodByName_Ref(dividersArray,
-                "$_get", "i:Y", &dividerRef, (ani_int)i)) != ANI_OK) {
+            ani_status ret = env->Array_Get(dividersArray, (ani_int)i, &dividerRef);
+            if (ret != ANI_OK) {
                 ROSEN_LOGE("AniLattice::CreateImageLattice  get divider ref failed. ret: %{public}d", ret);
                 return false;
             }
-            if ((ret = env->Object_CallMethodByName_Int(
-                static_cast<ani_object>(dividerRef), "toInt", ":i", &divider)) != ANI_OK) {
+            ret = env->Object_CallMethod_Int(
+                static_cast<ani_object>(dividerRef), AniGlobalMethod::GetInstance().intGet, &divider);
+            if (ret != ANI_OK) {
                 ROSEN_LOGE("AniLattice::CreateImageLattice Get divider failed. ret: %{public}d", ret);
                 return false;
             }
@@ -74,8 +73,9 @@ bool GetLatticeDividers(ani_env* env, ani_object dividersArray, uint32_t count,
 bool GetLatticeRectTypes(ani_env* env, ani_object rectTypesArray, uint32_t count,
     std::vector<Lattice::RectType>& latticeRectTypes)
 {
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(rectTypesArray, "length", &aniLength)) {
+    ani_array arrayObj = reinterpret_cast<ani_array>(rectTypesArray);
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(arrayObj, &aniLength)) {
         ROSEN_LOGE("AniLattice::CreateImageLattice rectTypes are invalid");
         return false;
     }
@@ -90,8 +90,7 @@ bool GetLatticeRectTypes(ani_env* env, ani_object rectTypesArray, uint32_t count
         for (uint32_t i = 0; i < rectTypesSize; i++) {
             ani_int rectType;
             ani_ref rectTypeRef;
-            if (ANI_OK != env->Object_CallMethodByName_Ref(
-                rectTypesArray, "$_get", "i:Y", &rectTypeRef, (ani_int)i) ||
+            if (ANI_OK != env->Array_Get(arrayObj, (ani_int)i, &rectTypeRef) ||
                 ANI_OK != env->EnumItem_GetValue_Int((ani_enum_item)rectTypeRef, &rectType)) {
                 ROSEN_LOGE("AniLattice::CreateImageLattice Incorrect parameter dividers type.");
                 return false;
@@ -106,11 +105,11 @@ bool GetLatticeRectTypes(ani_env* env, ani_object rectTypesArray, uint32_t count
     return true;
 }
 
-bool ProcessColorElement(ani_env* env, ani_object colorRef, std::vector<Color>& latticeColors)
+bool ProcessColorElement(ani_env* env, ani_object colorObj, std::vector<Color>& latticeColors)
 {
     Drawing::ColorQuad colorQuad;
     
-    if (!GetColorQuadFromColorObj(env, colorRef, colorQuad)) {
+    if (!GetColorQuadFromColorObj(env, colorObj, colorQuad)) {
         ROSEN_LOGE("ProcessColorElement: failed to get color from Color object");
         return false;
     }
@@ -121,12 +120,11 @@ bool ProcessColorElement(ani_env* env, ani_object colorRef, std::vector<Color>&
     return true;
 }
 
-bool ProcessIntElement(ani_env* env, ani_object colorRef, std::vector<Color>& latticeColors)
+bool ProcessIntElement(ani_env* env, ani_object colorObj, std::vector<Color>& latticeColors)
 {
     ani_int aniColor;
-    if (ANI_OK != env->Object_CallMethodByName_Int(
-        colorRef, "toInt", ":i", &aniColor)) {
-        ROSEN_LOGE("ProcessIntElement: failed to Object_CallMethodByName_Int");
+    if (ANI_OK != env->Object_CallMethod_Int(colorObj, AniGlobalMethod::GetInstance().intGet, &aniColor)) {
+        ROSEN_LOGE("ProcessIntElement: failed to Object_CallMethod_Int");
         return false;
     }
     
@@ -140,8 +138,9 @@ bool ProcessIntElement(ani_env* env, ani_object colorRef, std::vector<Color>& la
 bool GetLatticeColors(
     ani_env* env, ani_object colorsArray, uint32_t count, std::vector<Color>& latticeColors, bool isColorArray)
 {
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(colorsArray, "length", &aniLength)) {
+    ani_array arrayObj = reinterpret_cast<ani_array>(colorsArray);
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(arrayObj, &aniLength)) {
         ROSEN_LOGE("GetLatticeColors: colors are invalid %{public}s, %{public}d", __FUNCTION__, __LINE__);
         return false;
     }
@@ -156,8 +155,7 @@ bool GetLatticeColors(
         latticeColors.reserve(colorsSize);
         for (uint32_t i = 0; i < colorsSize; i++) {
             ani_ref colorRef;
-            if (ANI_OK != env->Object_CallMethodByName_Ref(
-                colorsArray, "$_get", "i:Y", &colorRef, (ani_int)i)) {
+            if (ANI_OK != env->Array_Get(arrayObj, (ani_int)i, &colorRef)) {
                 ROSEN_LOGE("GetLatticeColors: colors is invalid %{public}s, %{public}d", __FUNCTION__, __LINE__);
                 return false;
             }
@@ -175,9 +173,8 @@ bool GetLatticeColors(
 
 ani_status AniLattice::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_ANI_LATTICE_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().lattice;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_ANI_LATTICE_NAME);
         return ANI_NOT_FOUND;
     }
@@ -192,7 +189,7 @@ ani_status AniLattice::AniInit(ani_env *env)
         ani_native_function { "getLatticeAddr", nullptr, reinterpret_cast<void*>(GetLatticeAddr) },
     };
 
-    ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s ret: %{public}d", ANI_CLASS_ANI_LATTICE_NAME, ret);
         return ANI_NOT_FOUND;
@@ -264,7 +261,7 @@ ani_object CreateImageLatticeInternal(const LatticeCreationParams& params)
 }
 
 ani_object AniLattice::CreateImageLattice(ani_env* env,
-    ani_object obj, ani_object xDivs, ani_object yDivs, ani_int fXCount,
+    ani_object obj, ani_array xDivs, ani_array yDivs, ani_int fXCount,
     ani_int fYCount, ani_object fBounds, ani_object fRectTypes, ani_object fColors)
 {
     LatticeCreationParams params = {
@@ -274,7 +271,7 @@ ani_object AniLattice::CreateImageLattice(ani_env* env,
 }
 
 ani_object AniLattice::CreateImageLatticeWithArrayInt(ani_env* env,
-    ani_object obj, ani_object xDivs, ani_object yDivs, ani_int fXCount,
+    ani_object obj, ani_array xDivs, ani_array yDivs, ani_int fXCount,
     ani_int fYCount, ani_object fBounds, ani_object fRectTypes, ani_object fColors)
 {
     LatticeCreationParams params = {
@@ -315,7 +312,7 @@ ani_object AniLattice::LatticeTransferStatic(ani_env* env, [[maybe_unused]]ani_o
 
 ani_long AniLattice::GetLatticeAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniLattice = GetNativeFromObj<AniLattice>(env, input);
+    auto aniLattice = GetNativeFromObj<AniLattice>(env, input, AniGlobalField::GetInstance().latticeNativeObj);
     if (aniLattice == nullptr || aniLattice->GetLattice() == nullptr) {
         ROSEN_LOGE("AniLattice::GetLatticeAddr aniLattice is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/lattice_ani/ani_lattice.h b/interfaces/kits/ani/drawing/lattice_ani/ani_lattice.h
index 86df219d46..3f7ac78415 100644
--- a/interfaces/kits/ani/drawing/lattice_ani/ani_lattice.h
+++ b/interfaces/kits/ani/drawing/lattice_ani/ani_lattice.h
@@ -28,10 +28,10 @@ public:
 
     static ani_status AniInit(ani_env *env);
     static ani_object CreateImageLattice(ani_env* env,
-        ani_object obj, ani_object xDivs, ani_object yDivs, ani_int fXCount,
+        ani_object obj, ani_array xDivs, ani_array yDivs, ani_int fXCount,
         ani_int fYCount, ani_object fBounds, ani_object fRectTypes, ani_object fColors);
     static ani_object CreateImageLatticeWithArrayInt(ani_env* env,
-        ani_object obj, ani_object xDivs, ani_object yDivs, ani_int fXCount,
+        ani_object obj, ani_array xDivs, ani_array yDivs, ani_int fXCount,
         ani_int fYCount, ani_object fBounds, ani_object fRectTypes, ani_object fColors);
 
     std::shared_ptr<Lattice> GetLattice();
diff --git a/interfaces/kits/ani/drawing/mask_filter_ani/ani_mask_filter.cpp b/interfaces/kits/ani/drawing/mask_filter_ani/ani_mask_filter.cpp
index e1102a1136..c3223465cb 100644
--- a/interfaces/kits/ani/drawing/mask_filter_ani/ani_mask_filter.cpp
+++ b/interfaces/kits/ani/drawing/mask_filter_ani/ani_mask_filter.cpp
@@ -18,13 +18,10 @@
 namespace OHOS::Rosen {
 namespace Drawing {
 
-const char* ANI_CLASS_MASKFILTER_NAME = "@ohos.graphics.drawing.drawing.MaskFilter";
-
 ani_status AniMaskFilter::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_MASKFILTER_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().maskFilter;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_MASKFILTER_NAME);
         return ANI_NOT_FOUND;
     }
@@ -33,7 +30,7 @@ ani_status AniMaskFilter::AniInit(ani_env *env)
         ani_native_function { "createBlurMaskFilter", nullptr, reinterpret_cast<void*>(CreateBlurMaskFilter) },
     };
 
-    ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_MASKFILTER_NAME);
         return ANI_NOT_FOUND;
diff --git a/interfaces/kits/ani/drawing/matrix_ani/ani_matrix.cpp b/interfaces/kits/ani/drawing/matrix_ani/ani_matrix.cpp
index 2fd0050a29..5cc598b66f 100644
--- a/interfaces/kits/ani/drawing/matrix_ani/ani_matrix.cpp
+++ b/interfaces/kits/ani/drawing/matrix_ani/ani_matrix.cpp
@@ -28,9 +28,8 @@ constexpr uint32_t POLY_POINT_COUNT_MAX = 4;
 
 ani_status AniMatrix::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_MATRIX_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().matrix;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_MATRIX_NAME);
         return ANI_NOT_FOUND;
     }
@@ -63,7 +62,7 @@ ani_status AniMatrix::AniInit(ani_env *env)
         ani_native_function { "setScale", nullptr, reinterpret_cast<void*>(SetScale) },
     };
 
-    ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: ret %{public}d %{public}s", ret, ANI_CLASS_MATRIX_NAME);
         return ANI_NOT_FOUND;
@@ -96,7 +95,7 @@ void AniMatrix::Constructor(ani_env* env, ani_object obj)
 
 void AniMatrix::ConstructorWithMatrix(ani_env* env, ani_object obj, ani_object aniMatrixObj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -115,7 +114,7 @@ void AniMatrix::ConstructorWithMatrix(ani_env* env, ani_object obj, ani_object a
 
 void AniMatrix::Reset(ani_env* env, ani_object obj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -126,7 +125,7 @@ void AniMatrix::Reset(ani_env* env, ani_object obj)
 
 void AniMatrix::SetTranslation(ani_env* env, ani_object obj, ani_double dx, ani_double dy)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -136,7 +135,7 @@ void AniMatrix::SetTranslation(ani_env* env, ani_object obj, ani_double dx, ani_
 
 ani_double AniMatrix::GetValue(ani_env* env, ani_object obj, ani_int index)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return 0;
@@ -152,13 +151,13 @@ ani_double AniMatrix::GetValue(ani_env* env, ani_object obj, ani_int index)
 
 void AniMatrix::preConcat(ani_env* env, ani_object obj, ani_object aniMatrixObj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniMatrix::preConcat invalid params: aniMatrix. ");
         return;
     }
-    auto aniNewMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj);
+    auto aniNewMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniNewMatrix == nullptr || aniNewMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniMatrix::preConcat invalid params: otherMatrix. ");
@@ -170,7 +169,7 @@ void AniMatrix::preConcat(ani_env* env, ani_object obj, ani_object aniMatrixObj)
 
 ani_boolean AniMatrix::RectStaysRect(ani_env* env, ani_object obj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return false;
@@ -180,7 +179,7 @@ ani_boolean AniMatrix::RectStaysRect(ani_env* env, ani_object obj)
 
 ani_boolean AniMatrix::IsAffine(ani_env* env, ani_object obj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return false;
@@ -190,7 +189,7 @@ ani_boolean AniMatrix::IsAffine(ani_env* env, ani_object obj)
 
 void AniMatrix::PreRotate(ani_env* env, ani_object obj, ani_double degree, ani_double px, ani_double py)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -200,7 +199,7 @@ void AniMatrix::PreRotate(ani_env* env, ani_object obj, ani_double degree, ani_d
 
 void AniMatrix::PreScale(ani_env* env, ani_object obj, ani_double sx, ani_double sy, ani_double px, ani_double py)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -211,7 +210,7 @@ void AniMatrix::PreScale(ani_env* env, ani_object obj, ani_double sx, ani_double
 ani_boolean AniMatrix::SetRectToRect(ani_env* env, ani_object obj, ani_object aniSrcRectObj,
     ani_object aniDstRectObj, ani_enum_item aniScaleToFit)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return false;
@@ -237,7 +236,7 @@ ani_boolean AniMatrix::SetRectToRect(ani_env* env, ani_object obj, ani_object an
 }
 void AniMatrix::PostScale(ani_env* env, ani_object obj, ani_double sx, ani_double sy, ani_double px, ani_double py)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -247,7 +246,7 @@ void AniMatrix::PostScale(ani_env* env, ani_object obj, ani_double sx, ani_doubl
 
 void AniMatrix::PostTranslate(ani_env* env, ani_object obj, ani_double dx, ani_double dy)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -259,15 +258,13 @@ ani_object DoubleToObject(ani_env *env, double value)
 {
     ani_object aniObject = nullptr;
     ani_double doubleValue = static_cast<ani_double>(value);
-    ani_class aniClass;
-    static const char* className = "std.core.Double";
-    ani_status ret = env->FindClass(className, &aniClass);
-    if (ret != ANI_OK) {
-        ROSEN_LOGE("Not found '%{public}s' ret: %{public}d.", className, ret);
+    ani_class aniClass = AniGlobalClass::GetInstance().doubleCls;
+    if (aniClass == nullptr) {
+        ROSEN_LOGE("Not found %{public}s", ANI_DOUBLE_STRING);
         return aniObject;
     }
     ani_method ctorMethod;
-    ret = env->Class_FindMethod(aniClass, "<ctor>", "d:", &ctorMethod);
+    ani_status ret = env->Class_FindMethod(aniClass, "<ctor>", "d:", &ctorMethod);
     if (ret != ANI_OK) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Class_FindMethod <ctor> Failed.");
         return aniObject;
@@ -282,7 +279,7 @@ ani_object DoubleToObject(ani_env *env, double value)
 
 ani_object AniMatrix::GetAll(ani_env* env, ani_object obj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid params.");
         return CreateAniUndefined(env);
@@ -290,8 +287,8 @@ ani_object AniMatrix::GetAll(ani_env* env, ani_object obj)
     Drawing::Matrix::Buffer buffer;
     aniMatrix->GetMatrix()->GetAll(buffer);
 
-    ani_class arrayCls = nullptr;
-    if (ANI_OK != env->FindClass("escompat.Array", &arrayCls)) {
+    ani_class arrayCls = AniGlobalClass::GetInstance().arrayCls;
+    if (arrayCls == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Find class failed.");
         return CreateAniUndefined(env);
     }
@@ -310,7 +307,8 @@ ani_object AniMatrix::GetAll(ani_env* env, ani_object obj)
     ani_size index = 0;
     for (auto item : buffer) {
         ani_object aniValue = DoubleToObject(env, item);
-        if (ANI_OK != env->Object_CallMethodByName_Void(arrayObj, "$_set", "iY:", index, aniValue)) {
+        if (ANI_OK != env->Object_CallMethod_Void(
+            arrayObj, AniGlobalMethod::GetInstance().arraySet, index, aniValue)) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Object_CallMethodByName_Void Array Faild");
             return CreateAniUndefined(env);
         }
@@ -319,16 +317,16 @@ ani_object AniMatrix::GetAll(ani_env* env, ani_object obj)
     return arrayObj;
 }
 
-void AniMatrix::SetMatrix(ani_env* env, ani_object obj, ani_object aniValueArrayObj)
+void AniMatrix::SetMatrix(ani_env* env, ani_object obj, ani_array aniValueArrayObj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid params.");
         return;
     }
     std::vector<float> matrixVector;
-    ani_int aniLength;
-    ani_status ret = env->Object_GetPropertyByName_Int(aniValueArrayObj, "length", &aniLength);
+    ani_size aniLength;
+    ani_status ret = env->Array_GetLength(aniValueArrayObj, &aniLength);
     if (ret != ANI_OK) {
         ROSEN_LOGE("AniMatrix::SetMatrix aniValueArrayObj are invalid ret: %{public}d", ret);
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid param matrix.");
@@ -344,14 +342,14 @@ void AniMatrix::SetMatrix(ani_env* env, ani_object obj, ani_object aniValueArray
     for (uint32_t i = 0; i < matrixSize; i++) {
         ani_ref matrixRef;
         ani_double matrixValue;
-        ret = env->Object_CallMethodByName_Ref(
-            aniValueArrayObj, "$_get", "i:Y", &matrixRef, static_cast<ani_int>(i));
+        ret = env->Array_Get(aniValueArrayObj, (ani_int)i, &matrixRef);
         if (ret != ANI_OK) {
             ROSEN_LOGE("AniMatrix::SetMatrix aniValueArrayObj get pointRef failed. ret: %{public}d", ret);
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid param matrix array element.");
             return;
         }
-        ret = env->Object_CallMethodByName_Double(static_cast<ani_object>(matrixRef), "toDouble", ":d", &matrixValue);
+        ret = env->Object_CallMethod_Double(
+            static_cast<ani_object>(matrixRef), AniGlobalMethod::GetInstance().doubleGet, &matrixValue);
         if (ret != ANI_OK) {
             ROSEN_LOGE("AniMatrix::SetMatrix matrixRef is invalid. ret: %{public}d", ret);
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid param matrix array element.");
@@ -366,7 +364,7 @@ void AniMatrix::SetMatrix(ani_env* env, ani_object obj, ani_object aniValueArray
 
 ani_boolean AniMatrix::MapRect(ani_env* env, ani_object obj, ani_object aniDstRectObj, ani_object aniSrcRectObj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid params.");
         return false;
@@ -395,7 +393,7 @@ ani_boolean AniMatrix::MapRect(ani_env* env, ani_object obj, ani_object aniDstRe
 
 void AniMatrix::PostRotate(ani_env* env, ani_object obj, ani_double degree, ani_double px, ani_double py)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid params.");
         return;
@@ -405,13 +403,13 @@ void AniMatrix::PostRotate(ani_env* env, ani_object obj, ani_double degree, ani_
 
 ani_boolean AniMatrix::Invert(ani_env* env, ani_object obj, ani_object aniMatrixObj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid params.");
         return false;
     }
 
-    auto aniNewMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj);
+    auto aniNewMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniNewMatrix == nullptr || aniNewMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid param matrix.");
         return false;
@@ -427,12 +425,12 @@ ani_boolean AniMatrix::Invert(ani_env* env, ani_object obj, ani_object aniMatrix
 
 ani_boolean AniMatrix::IsEqual(ani_env* env, ani_object obj, ani_object aniMatrixObj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid params.");
         return false;
     }
-    auto aniNewMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj);
+    auto aniNewMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniNewMatrix == nullptr || aniNewMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid param matrix.");
         return false;
@@ -440,10 +438,10 @@ ani_boolean AniMatrix::IsEqual(ani_env* env, ani_object obj, ani_object aniMatri
     return aniMatrix->GetMatrix()->operator == (*aniNewMatrix->GetMatrix());
 }
 
-ani_boolean AniMatrix::SetPolyToPoly(ani_env* env, ani_object obj, ani_object aniSrcPointArray,
-    ani_object aniDstPointArray, ani_int count)
+ani_boolean AniMatrix::SetPolyToPoly(ani_env* env, ani_object obj, ani_array aniSrcPointArray,
+    ani_array aniDstPointArray, ani_int count)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return false;
@@ -470,7 +468,7 @@ ani_boolean AniMatrix::SetPolyToPoly(ani_env* env, ani_object obj, ani_object an
 
 ani_boolean AniMatrix::IsIdentity(ani_env* env, ani_object obj)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "invalid params.");
         return false;
@@ -480,8 +478,8 @@ ani_boolean AniMatrix::IsIdentity(ani_env* env, ani_object obj)
 
 ani_object GetPointArray(ani_env* env, const std::vector<Drawing::Point>& points, uint32_t count)
 {
-    ani_class arrayCls = nullptr;
-    if (ANI_OK != env->FindClass("escompat.Array", &arrayCls)) {
+    ani_class arrayCls = AniGlobalClass::GetInstance().arrayCls;
+    if (arrayCls == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "FindClass escompat.Array Failed");
         return CreateAniUndefined(env);
     }
@@ -504,9 +502,9 @@ ani_object GetPointArray(ani_env* env, const std::vector<Drawing::Point>& points
             return aniPointObj;
         }
 
-        if (ANI_OK != env->Object_CallMethodByName_Void(
-            arrayObj, "$_set", "iY:", index, aniPointObj)) {
-            ROSEN_LOGE("SObject_CallMethodByName_Void  $_set Faild ");
+        if (ANI_OK != env->Object_CallMethod_Void(
+            arrayObj, AniGlobalMethod::GetInstance().arraySet, index, aniPointObj)) {
+            ROSEN_LOGE("Object_CallMethod_Void arraySet Faild ");
             return CreateAniUndefined(env);
         }
         index++;
@@ -514,16 +512,16 @@ ani_object GetPointArray(ani_env* env, const std::vector<Drawing::Point>& points
     return arrayObj;
 }
 
-ani_object AniMatrix::MapPoints(ani_env* env, ani_object obj, ani_object aniSrcPointArray)
+ani_object AniMatrix::MapPoints(ani_env* env, ani_object obj, ani_array aniSrcPointArray)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return CreateAniUndefined(env);
     }
     
-    ani_int aniLength;
-    ani_status ret = env->Object_GetPropertyByName_Int(aniSrcPointArray, "length", &aniLength);
+    ani_size aniLength;
+    ani_status ret = env->Array_GetLength(aniSrcPointArray, &aniLength);
     if (ret != ANI_OK || aniLength == 0) {
         ROSEN_LOGE("AniMatrix::MapPoints error getting aniSrcPointArray length. ret: %{public}d, length: %{public}d",
             ret, aniLength);
@@ -543,7 +541,7 @@ ani_object AniMatrix::MapPoints(ani_env* env, ani_object obj, ani_object aniSrcP
 
 void AniMatrix::SetRotation(ani_env* env, ani_object obj, ani_double degree, ani_double px, ani_double py)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid src array size.");
         return;
@@ -554,7 +552,7 @@ void AniMatrix::SetRotation(ani_env* env, ani_object obj, ani_double degree, ani
 
 void AniMatrix::PreTranslate(ani_env* env, ani_object obj, ani_double dx, ani_double dy)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid src array size.");
         return;
@@ -564,7 +562,7 @@ void AniMatrix::PreTranslate(ani_env* env, ani_object obj, ani_double dx, ani_do
 
 void AniMatrix::SetScale(ani_env* env, ani_object obj, ani_double sx, ani_double sy, ani_double px, ani_double py)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, obj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid src array size.");
         return;
@@ -602,7 +600,7 @@ ani_object AniMatrix::MatrixTransferStatic(
 
 ani_long AniMatrix::GetMatrixAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, input);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, input, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ROSEN_LOGE("AniMatrix::GetMatrixAddr aniMatrix is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/matrix_ani/ani_matrix.h b/interfaces/kits/ani/drawing/matrix_ani/ani_matrix.h
index b9705e0344..db547079aa 100644
--- a/interfaces/kits/ani/drawing/matrix_ani/ani_matrix.h
+++ b/interfaces/kits/ani/drawing/matrix_ani/ani_matrix.h
@@ -43,16 +43,16 @@ public:
     static void PostScale(ani_env* env, ani_object obj, ani_double sx, ani_double sy, ani_double px, ani_double py);
     static void PostTranslate(ani_env* env, ani_object obj, ani_double dx, ani_double dy);
     static ani_object GetAll(ani_env* env, ani_object obj);
-    static void SetMatrix(ani_env* env, ani_object obj, ani_object aniValueArrayObj);
+    static void SetMatrix(ani_env* env, ani_object obj, ani_array aniValueArrayObj);
     static ani_boolean MapRect(ani_env* env, ani_object obj, ani_object aniDstRectObj, ani_object aniSrcRectObj);
     static void PostRotate(ani_env* env, ani_object obj, ani_double degree, ani_double px, ani_double py);
     static ani_boolean Invert(ani_env* env, ani_object obj, ani_object aniMatrixObj);
     static ani_boolean IsEqual(ani_env* env, ani_object obj, ani_object aniMatrixObj);
-    static ani_boolean SetPolyToPoly(ani_env* env, ani_object obj, ani_object aniSrcPointArray,
-        ani_object aniDstPointArray, ani_int count);
+    static ani_boolean SetPolyToPoly(ani_env* env, ani_object obj, ani_array aniSrcPointArray,
+        ani_array aniDstPointArray, ani_int count);
     static void PreConcat(ani_env* env, ani_object obj, ani_object aniMatrixObj);
     static ani_boolean IsIdentity(ani_env* env, ani_object obj);
-    static ani_object MapPoints(ani_env* env, ani_object obj, ani_object aniSrcPointArray);
+    static ani_object MapPoints(ani_env* env, ani_object obj, ani_array aniSrcPointArray);
     static void SetRotation(ani_env* env, ani_object obj, ani_double degree, ani_double px, ani_double py);
     static void PreTranslate(ani_env* env, ani_object obj, ani_double dx, ani_double dy);
     static void SetScale(ani_env* env, ani_object obj, ani_double sx, ani_double sy, ani_double px, ani_double py);
diff --git a/interfaces/kits/ani/drawing/path_ani/ani_path.cpp b/interfaces/kits/ani/drawing/path_ani/ani_path.cpp
index a6cc8a399b..f4a2b2c080 100644
--- a/interfaces/kits/ani/drawing/path_ani/ani_path.cpp
+++ b/interfaces/kits/ani/drawing/path_ani/ani_path.cpp
@@ -75,14 +75,13 @@ static const std::array g_methods = {
 
 ani_status AniPath::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_PATH_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().path;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_PATH_NAME);
         return ANI_NOT_FOUND;
     }
 
-    ret = env->Class_BindNativeMethods(cls, g_methods.data(), g_methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, g_methods.data(), g_methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: ret %{public}d %{public}s", ret, ANI_CLASS_PATH_NAME);
         return ret;
@@ -115,7 +114,7 @@ void AniPath::Constructor(ani_env* env, ani_object obj)
 
 void AniPath::ConstructorWithPath(ani_env* env, ani_object obj, ani_object aniPathObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, aniPathObj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, aniPathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -132,7 +131,7 @@ void AniPath::ConstructorWithPath(ani_env* env, ani_object obj, ani_object aniPa
 
 void AniPath::Reset(ani_env* env, ani_object obj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -144,7 +143,7 @@ void AniPath::Reset(ani_env* env, ani_object obj)
 void AniPath::ArcTo(ani_env* env, ani_object obj, ani_double x1, ani_double y1, ani_double x2, ani_double y2,
     ani_double startDeg, ani_double sweepDeg)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -156,7 +155,7 @@ void AniPath::ArcTo(ani_env* env, ani_object obj, ani_double x1, ani_double y1,
 
 ani_boolean AniPath::IsRect(ani_env* env, ani_object obj, ani_object aniRectObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params. ");
         return false;
@@ -180,12 +179,12 @@ ani_boolean AniPath::IsRect(ani_env* env, ani_object obj, ani_object aniRectObj)
 ani_boolean AniPath::GetSegment(ani_env* env, ani_object obj, ani_boolean forceClosed, ani_double start,
     ani_double stop, ani_boolean startWithMoveTo, ani_object aniPathObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return false;
     }
-    auto dst = GetNativeFromObj<AniPath>(env, aniPathObj);
+    auto dst = GetNativeFromObj<AniPath>(env, aniPathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (dst == nullptr || dst->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param dst.");
         return false;
@@ -196,13 +195,14 @@ ani_boolean AniPath::GetSegment(ani_env* env, ani_object obj, ani_boolean forceC
 
 ani_object AniPath::GetPathIterator(ani_env* env, ani_object obj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return CreateAniUndefined(env);
     }
     AniPathIterator* aniPathItertor = new AniPathIterator(*aniPath->GetPath());
-    ani_object aniObj = CreateAniObject(env, "@ohos.graphics.drawing.drawing.PathIterator", nullptr, obj);
+    ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().pathIterator,
+        AniGlobalMethod::GetInstance().pathIteratorCtor, obj);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj, NATIVE_OBJ, reinterpret_cast<ani_long>(aniPathItertor))) {
         ROSEN_LOGE("AniPath::GetPathIterator failed create PathIntertor.");
         delete aniPathItertor;
@@ -213,7 +213,7 @@ ani_object AniPath::GetPathIterator(ani_env* env, ani_object obj)
 
 void AniPath::RLineTo(ani_env* env, ani_object obj, ani_double dx, ani_double dy)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -223,13 +223,14 @@ void AniPath::RLineTo(ani_env* env, ani_object obj, ani_double dx, ani_double dy
 
 void AniPath::AddRoundRect(ani_env* env, ani_object obj, ani_object aniRoundRectObj, ani_object aniPathDirectionObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
     }
 
-    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, aniRoundRectObj);
+    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, aniRoundRectObj,
+        AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniRoundRect == nullptr || aniRoundRect->GetRoundRect() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param roundRect.");
         return;
@@ -251,7 +252,7 @@ void AniPath::AddRoundRect(ani_env* env, ani_object obj, ani_object aniRoundRect
 
 void AniPath::RQuadTo(ani_env* env, ani_object obj, ani_double dx1, ani_double dy1, ani_double dx2, ani_double dy2)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -261,12 +262,12 @@ void AniPath::RQuadTo(ani_env* env, ani_object obj, ani_double dx1, ani_double d
 
 void AniPath::Transform(ani_env* env, ani_object obj, ani_object aniMatrix)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
     }
-    auto matrix = GetNativeFromObj<AniMatrix>(env, aniMatrix);
+    auto matrix = GetNativeFromObj<AniMatrix>(env, aniMatrix, AniGlobalField::GetInstance().matrixNativeObj);
     if (matrix == nullptr || matrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param matrix.");
         return;
@@ -276,14 +277,15 @@ void AniPath::Transform(ani_env* env, ani_object obj, ani_object aniMatrix)
 
 ani_object AniPath::Offset(ani_env* env, ani_object obj, ani_double dx, ani_double dy)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return CreateAniUndefined(env);
     }
     std::shared_ptr<Path> path = std::make_shared<Path>();
     aniPath->GetPath()->Offset(path.get(), dx, dy);
-    ani_object aniObj = CreateAniObject(env, ANI_CLASS_PATH_NAME, ":");
+    ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().path,
+        AniGlobalMethod::GetInstance().pathCtor);
     ani_boolean isUndefined;
     env->Reference_IsUndefined(aniObj, &isUndefined);
     if (isUndefined) {
@@ -303,7 +305,7 @@ ani_object AniPath::Offset(ani_env* env, ani_object obj, ani_double dx, ani_doub
 
 void AniPath::AddArc(ani_env* env, ani_object obj, ani_object aniRectObj, ani_double startAngle, ani_double endAngle)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -318,7 +320,7 @@ void AniPath::AddArc(ani_env* env, ani_object obj, ani_object aniRectObj, ani_do
 
 void AniPath::RMoveTo(ani_env* env, ani_object obj, ani_double dx, ani_double dy)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -329,19 +331,19 @@ void AniPath::RMoveTo(ani_env* env, ani_object obj, ani_double dx, ani_double dy
 ani_boolean AniPath::GetPositionAndTangent(ani_env* env, ani_object obj, ani_boolean forceClosed,
     ani_double distance, ani_object aniPosition, ani_object aniTangent)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return false;
     }
     Drawing::Point position;
-    if (!GetPointFromAniPointObj(env, aniPosition, position)) {
+    if (GetPointFromPointObj(env, aniPosition, position) != ANI_OK) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param position.");
         return false;
     }
 
     Drawing::Point tangent;
-    if (!GetPointFromAniPointObj(env, aniTangent, tangent)) {
+    if (GetPointFromPointObj(env, aniTangent, tangent) != ANI_OK) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param tangent.");
         return false;
     }
@@ -355,7 +357,7 @@ ani_boolean AniPath::GetPositionAndTangent(ani_env* env, ani_object obj, ani_boo
 
 ani_double AniPath::GetLength(ani_env* env, ani_object obj, ani_boolean forceClosed)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return 0.0;
@@ -365,13 +367,13 @@ ani_double AniPath::GetLength(ani_env* env, ani_object obj, ani_boolean forceClo
 
 ani_boolean AniPath::Op(ani_env* env, ani_object obj, ani_object aniPathObj, ani_enum_item aniPathOpEnum)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return false;
     }
 
-    auto aniNewPath = GetNativeFromObj<AniPath>(env, aniPathObj);
+    auto aniNewPath = GetNativeFromObj<AniPath>(env, aniPathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniNewPath == nullptr  || aniNewPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param path.");
         return false;
@@ -387,16 +389,16 @@ ani_boolean AniPath::Op(ani_env* env, ani_object obj, ani_object aniPathObj, ani
 }
 
 
-void AniPath::AddPolygon(ani_env* env, ani_object obj, ani_object aniPointArray, ani_boolean aniClose)
+void AniPath::AddPolygon(ani_env* env, ani_object obj, ani_array aniPointArray, ani_boolean aniClose)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
     }
     std::vector<Drawing::Point> points;
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(aniPointArray, "length", &aniLength)) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(aniPointArray, &aniLength)) {
         ROSEN_LOGE("AniPath::AddPolygon aniPointsObj are invalid");
         return;
     }
@@ -409,14 +411,13 @@ void AniPath::AddPolygon(ani_env* env, ani_object obj, ani_object aniPointArray,
     for (uint32_t i = 0; i < pointSize; i++) {
         ani_ref pointRef;
         Drawing::Point point;
-        ani_status ret = env->Object_CallMethodByName_Ref(
-            aniPointArray, "$_get", "i:Y", &pointRef, static_cast<ani_int>(i));
+        ani_status ret = env->Array_Get(aniPointArray, static_cast<ani_int>(i), &pointRef);
         if (ret != ANI_OK) {
             ROSEN_LOGE("AniPath::AddPolygon get point from array failed: %{public}d", ret);
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param points.");
             return;
         }
-        if (!GetPointFromAniPointObj(env, static_cast<ani_object>(pointRef), point)) {
+        if (GetPointFromPointObj(env, static_cast<ani_object>(pointRef), point) != ANI_OK) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param points.");
             return;
         }
@@ -428,7 +429,7 @@ void AniPath::AddPolygon(ani_env* env, ani_object obj, ani_object aniPointArray,
 void AniPath::ConicTo(ani_env* env, ani_object obj, ani_double ctrlX, ani_double ctrlY, ani_double endX,
     ani_double endY, ani_double weight)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -439,7 +440,7 @@ void AniPath::ConicTo(ani_env* env, ani_object obj, ani_double ctrlX, ani_double
 void AniPath::AddCircle(
     ani_env* env, ani_object obj, ani_double x, ani_double y, ani_double radius, ani_object aniPathDirectionObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -463,7 +464,7 @@ void AniPath::AddCircle(
 void AniPath::RCubicTo(ani_env* env, ani_object obj, ani_double ctrlX1, ani_double ctrlY1,
     ani_double ctrlX2, ani_double ctrlY2, ani_double endX, ani_double endY)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -474,7 +475,7 @@ void AniPath::RCubicTo(ani_env* env, ani_object obj, ani_double ctrlX1, ani_doub
 void AniPath::RConicTo(ani_env* env, ani_object obj, ani_double ctrlX, ani_double ctrlY, ani_double endX,
     ani_double endY, ani_double weight)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -484,7 +485,7 @@ void AniPath::RConicTo(ani_env* env, ani_object obj, ani_double ctrlX, ani_doubl
 
 void AniPath::SetFillType(ani_env* env, ani_object obj, ani_enum_item aniPathFillType)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -501,7 +502,7 @@ void AniPath::SetFillType(ani_env* env, ani_object obj, ani_enum_item aniPathFil
 
 void AniPath::AddRect(ani_env* env, ani_object obj, ani_object aniRectObj, ani_object aniPathDirectionObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -531,12 +532,12 @@ void AniPath::AddRect(ani_env* env, ani_object obj, ani_object aniRectObj, ani_o
 ani_boolean AniPath::GetMatrix(ani_env* env, ani_object obj, ani_boolean aniForceClosed, ani_double distance,
     ani_object aniMatrixObj, ani_enum_item aniPathMeasureMatrixFlags)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return false;
     }
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param matrix.");
         return false;
@@ -562,7 +563,7 @@ ani_boolean AniPath::GetMatrix(ani_env* env, ani_object obj, ani_boolean aniForc
 
 ani_object AniPath::GetBounds(ani_env* env, ani_object obj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return CreateAniUndefined(env);
@@ -580,7 +581,7 @@ ani_object AniPath::GetBounds(ani_env* env, ani_object obj)
 void AniPath::AddOval(
     ani_env* env, ani_object obj, ani_object aniRectObj, ani_int aniStart, ani_object aniPathDirectionObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -614,7 +615,7 @@ void AniPath::AddOval(
 
 ani_boolean AniPath::Contains(ani_env* env, ani_object obj, ani_double x, ani_double y)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return false;
@@ -624,12 +625,12 @@ ani_boolean AniPath::Contains(ani_env* env, ani_object obj, ani_double x, ani_do
 
 void AniPath::AddPath(ani_env* env, ani_object obj, ani_object aniPathObj, ani_object aniMatrixObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
     }
-    auto aniNewPath = GetNativeFromObj<AniPath>(env, aniPathObj);
+    auto aniNewPath = GetNativeFromObj<AniPath>(env, aniPathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniNewPath == nullptr  || aniNewPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param path.");
         return;
@@ -643,7 +644,7 @@ void AniPath::AddPath(ani_env* env, ani_object obj, ani_object aniPathObj, ani_o
         aniPath->GetPath()->AddPath(*aniNewPath->GetPath(), Drawing::Matrix());
         return;
     }
-    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj);
+    auto aniMatrix = GetNativeFromObj<AniMatrix>(env, aniMatrixObj, AniGlobalField::GetInstance().matrixNativeObj);
     if (aniMatrix == nullptr || aniMatrix->GetMatrix() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param matrix.");
         return;
@@ -653,7 +654,7 @@ void AniPath::AddPath(ani_env* env, ani_object obj, ani_object aniPathObj, ani_o
 
 ani_boolean AniPath::IsClosed(ani_env* env, ani_object obj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return false;
@@ -663,7 +664,7 @@ ani_boolean AniPath::IsClosed(ani_env* env, ani_object obj)
 
 ani_boolean AniPath::BuildFromSVGString(ani_env* env, ani_object obj, ani_string aniStringObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return false;
@@ -675,7 +676,7 @@ ani_boolean AniPath::BuildFromSVGString(ani_env* env, ani_object obj, ani_string
 void AniPath::CubicTo(ani_env* env, ani_object obj, ani_double ctrlX1, ani_double ctrlY1, ani_double ctrlX2,
     ani_double ctrlY2, ani_double endX, ani_double endY)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -686,7 +687,7 @@ void AniPath::CubicTo(ani_env* env, ani_object obj, ani_double ctrlX1, ani_doubl
 void AniPath::QuadTo(ani_env* env, ani_object obj, ani_double ctrlX, ani_double ctrlY, ani_double ctrlX2,
     ani_double ctrlY2)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -696,7 +697,7 @@ void AniPath::QuadTo(ani_env* env, ani_object obj, ani_double ctrlX, ani_double
 
 void AniPath::LineTo(ani_env* env, ani_object obj, ani_double x, ani_double y)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -706,7 +707,7 @@ void AniPath::LineTo(ani_env* env, ani_object obj, ani_double x, ani_double y)
 
 void AniPath::MoveTo(ani_env* env, ani_object obj, ani_double x, ani_double y)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -716,7 +717,7 @@ void AniPath::MoveTo(ani_env* env, ani_object obj, ani_double x, ani_double y)
 
 void AniPath::Close(ani_env* env, ani_object obj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr  || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -726,7 +727,7 @@ void AniPath::Close(ani_env* env, ani_object obj)
 
 ani_boolean AniPath::IsInverseFillType(ani_env* env, ani_object obj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return false;
@@ -736,7 +737,7 @@ ani_boolean AniPath::IsInverseFillType(ani_env* env, ani_object obj)
 
 void AniPath::ToggleInverseFillType(ani_env* env, ani_object obj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, obj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, obj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param.");
         return;
@@ -774,7 +775,7 @@ ani_object AniPath::PathTransferStatic(
 
 ani_long AniPath::GetPathAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, input);
+    auto aniPath = GetNativeFromObj<AniPath>(env, input, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ROSEN_LOGE("AniPath::GetPathAddr aniPath is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/path_ani/ani_path.h b/interfaces/kits/ani/drawing/path_ani/ani_path.h
index 36cbdf3275..7635326428 100644
--- a/interfaces/kits/ani/drawing/path_ani/ani_path.h
+++ b/interfaces/kits/ani/drawing/path_ani/ani_path.h
@@ -48,7 +48,7 @@ public:
         ani_double distance, ani_object aniPosition, ani_object aniTangent);
     static ani_double GetLength(ani_env* env, ani_object obj, ani_boolean forceClosed);
     static ani_boolean Op(ani_env* env, ani_object obj, ani_object aniPathObj, ani_enum_item aniPathOpEnum);
-    static void AddPolygon(ani_env* env, ani_object obj, ani_object aniPointArray, ani_boolean aniClose);
+    static void AddPolygon(ani_env* env, ani_object obj, ani_array aniPointArray, ani_boolean aniClose);
     static void ConicTo(ani_env* env, ani_object obj, ani_double ctrlX, ani_double ctrlY, ani_double endX,
         ani_double endY, ani_double weight);
     static void AddCircle(ani_env* env, ani_object obj,
diff --git a/interfaces/kits/ani/drawing/path_effect_ani/ani_path_effect.cpp b/interfaces/kits/ani/drawing/path_effect_ani/ani_path_effect.cpp
index e32e9fdb36..bd2993532f 100644
--- a/interfaces/kits/ani/drawing/path_effect_ani/ani_path_effect.cpp
+++ b/interfaces/kits/ani/drawing/path_effect_ani/ani_path_effect.cpp
@@ -21,13 +21,10 @@
 namespace OHOS::Rosen {
 namespace Drawing {
 
-const char* ANI_CLASS_PATHEFFECT_NAME = "@ohos.graphics.drawing.drawing.PathEffect";
-
 ani_status AniPathEffect::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_PATHEFFECT_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().pathEffect;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_PATHEFFECT_NAME);
         return ANI_NOT_FOUND;
     }
@@ -41,7 +38,7 @@ ani_status AniPathEffect::AniInit(ani_env *env)
         ani_native_function { "createDashPathEffect", nullptr, reinterpret_cast<void*>(CreateDashPathEffect) },
     };
 
-    ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_PATHEFFECT_NAME);
         return ANI_NOT_FOUND;
@@ -58,7 +55,8 @@ ani_object AniPathEffect::CreateDiscretePathEffect(ani_env* env, [[maybe_unused]
     env->Reference_IsUndefined(aniSeedAssistObj, &isUndefined);
     if (!isUndefined) {
         ani_double aniSeedAssist = 0;
-        ani_status ret =  env->Object_CallMethodByName_Double(aniSeedAssistObj, "toDouble", ":d", &aniSeedAssist);
+        ani_status ret =  env->Object_CallMethod_Double(
+            aniSeedAssistObj, AniGlobalMethod::GetInstance().doubleGet, &aniSeedAssist);
         if (ret != ANI_OK) {
             ROSEN_LOGE("AniPathEffect::CreateDiscretePathEffect invalid param seedAssist: %{public}d", ret);
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param seedAssist.");
@@ -81,12 +79,14 @@ ani_object AniPathEffect::CreateDiscretePathEffect(ani_env* env, [[maybe_unused]
 ani_object AniPathEffect::CreateSumPathEffect(ani_env* env, [[maybe_unused]]ani_object obj,
     ani_object aniFirstPathEffectObj, ani_object aniSecondPathEffectObj)
 {
-    auto aniFirstPathEffect = GetNativeFromObj<AniPathEffect>(env, aniFirstPathEffectObj);
+    auto aniFirstPathEffect = GetNativeFromObj<AniPathEffect>(env, aniFirstPathEffectObj,
+        AniGlobalField::GetInstance().pathEffectNativeObj);
     if (aniFirstPathEffect == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param firstPathEffect.");
         return CreateAniUndefined(env);
     }
-    auto aniSecondPathEffect = GetNativeFromObj<AniPathEffect>(env, aniSecondPathEffectObj);
+    auto aniSecondPathEffect = GetNativeFromObj<AniPathEffect>(env, aniSecondPathEffectObj,
+        AniGlobalField::GetInstance().pathEffectNativeObj);
     if (aniSecondPathEffect == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param secondPathEffect.");
         return CreateAniUndefined(env);
@@ -106,7 +106,7 @@ ani_object AniPathEffect::CreateSumPathEffect(ani_env* env, [[maybe_unused]]ani_
 ani_object AniPathEffect::CreatePathDashEffect(ani_env* env, [[maybe_unused]]ani_object obj,
     ani_object aniPathObj, ani_double aniAdvance, ani_double aniPhase, ani_enum_item aniStyleEnum)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, aniPathObj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, aniPathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param path.");
         return CreateAniUndefined(env);
@@ -132,12 +132,14 @@ ani_object AniPathEffect::CreatePathDashEffect(ani_env* env, [[maybe_unused]]ani
 ani_object AniPathEffect::CreateComposePathEffect(ani_env* env, [[maybe_unused]]ani_object obj,
     ani_object aniOuterPathEffectObj, ani_object aniInnerPathEffectObj)
 {
-    auto aniOuterPathEffect = GetNativeFromObj<AniPathEffect>(env, aniOuterPathEffectObj);
+    auto aniOuterPathEffect = GetNativeFromObj<AniPathEffect>(env, aniOuterPathEffectObj,
+        AniGlobalField::GetInstance().pathEffectNativeObj);
     if (aniOuterPathEffect == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param outer.");
         return CreateAniUndefined(env);
     }
-    auto aniInnerPathEffect = GetNativeFromObj<AniPathEffect>(env, aniInnerPathEffectObj);
+    auto aniInnerPathEffect = GetNativeFromObj<AniPathEffect>(env, aniInnerPathEffectObj,
+        AniGlobalField::GetInstance().pathEffectNativeObj);
     if (aniInnerPathEffect == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param outer.");
         return CreateAniUndefined(env);
@@ -169,10 +171,10 @@ ani_object AniPathEffect::CreateCornerPathEffect(
 }
 
 ani_object AniPathEffect::CreateDashPathEffect(
-    ani_env* env, [[maybe_unused]]ani_object obj, ani_object aniIntervalsArray, ani_double aniPhase)
+    ani_env* env, [[maybe_unused]]ani_object obj, ani_array aniIntervalsArray, ani_double aniPhase)
 {
-    ani_int aniLength;
-    ani_status ret = env->Object_GetPropertyByName_Int(aniIntervalsArray, "length", &aniLength);
+    ani_size aniLength;
+    ani_status ret = env->Array_GetLength(aniIntervalsArray, &aniLength);
     if (ret != ANI_OK) {
         ROSEN_LOGE("AniPathEffect::CreateDashPathEffect aniIntervalsArray invalid %{public}d", ret);
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param intervals.");
@@ -188,14 +190,14 @@ ani_object AniPathEffect::CreateDashPathEffect(
     for (uint32_t i = 0; i < intervalSize; i++) {
         ani_ref intervalRef;
         ani_double interval;
-        ret = env->Object_CallMethodByName_Ref(
-            aniIntervalsArray, "$_get", "i:Y", &intervalRef, static_cast<ani_int>(i));
+        ret = env->Array_Get(aniIntervalsArray, static_cast<ani_int>(i), &intervalRef);
         if (ret != ANI_OK) {
             ROSEN_LOGE("AniPathEffect::CreateDashPathEffect get intervalRef failed: %{public}d", ret);
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid intervals array length.");
             return CreateAniUndefined(env);
         }
-        ret = env->Object_CallMethodByName_Double(static_cast<ani_object>(intervalRef), "toDouble", ":d", &interval);
+        ret = env->Object_CallMethod_Double(
+            static_cast<ani_object>(intervalRef), AniGlobalMethod::GetInstance().doubleGet, &interval);
         if (ret != ANI_OK) {
             ROSEN_LOGE("AniPathEffect::CreateDashPathEffect intervalRef get interval failed: %d", ret);
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid intervals array length.");
diff --git a/interfaces/kits/ani/drawing/path_effect_ani/ani_path_effect.h b/interfaces/kits/ani/drawing/path_effect_ani/ani_path_effect.h
index 0a42418aa1..c468b0e3a5 100644
--- a/interfaces/kits/ani/drawing/path_effect_ani/ani_path_effect.h
+++ b/interfaces/kits/ani/drawing/path_effect_ani/ani_path_effect.h
@@ -38,7 +38,7 @@ public:
         ani_object aniOuterPathEffectObj, ani_object aniInnerPathEffectObj);
     static ani_object CreateCornerPathEffect(ani_env* env, ani_object obj, ani_double aniRadius);
     static ani_object CreateDashPathEffect(
-        ani_env* env, ani_object obj, ani_object aniIntervalsArray, ani_double aniPhase);
+        ani_env* env, ani_object obj, ani_array aniIntervalsArray, ani_double aniPhase);
 
     DRAWING_API std::shared_ptr<PathEffect> GetPathEffect();
 
diff --git a/interfaces/kits/ani/drawing/path_iterator_ani/ani_path_iterator.cpp b/interfaces/kits/ani/drawing/path_iterator_ani/ani_path_iterator.cpp
index df1902d5a7..89b43389a9 100644
--- a/interfaces/kits/ani/drawing/path_iterator_ani/ani_path_iterator.cpp
+++ b/interfaces/kits/ani/drawing/path_iterator_ani/ani_path_iterator.cpp
@@ -19,14 +19,11 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_PATH_ITERATOR_NAME = "@ohos.graphics.drawing.drawing.PathIterator";
-const char* ANI_ENUM_PATH_ITERATOR_VERB = "@ohos.graphics.drawing.drawing.PathIteratorVerb";
 
 ani_status AniPathIterator::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_PATH_ITERATOR_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().pathIterator;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_PATH_ITERATOR_NAME);
         return ANI_NOT_FOUND;
     }
@@ -39,7 +36,7 @@ ani_status AniPathIterator::AniInit(ani_env *env)
         ani_native_function { "peek", nullptr, reinterpret_cast<void*>(Peek) },
     };
 
-    ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_PATH_ITERATOR_NAME);
         return ANI_NOT_FOUND;
@@ -50,7 +47,7 @@ ani_status AniPathIterator::AniInit(ani_env *env)
 
 void AniPathIterator::ConstructorWithPath(ani_env* env, ani_object obj, ani_object aniPathObj)
 {
-    auto aniPath = GetNativeFromObj<AniPath>(env, aniPathObj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, aniPathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr || aniPath->GetPath() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return;
@@ -94,7 +91,7 @@ PathVerb AniPathIterator::GetReturnVerb(const PathVerb& cachedVerb)
     }
 }
 
-ani_object AniPathIterator::OnNext(ani_env* env, ani_object aniPointArray, ani_object aniOffsetObj)
+ani_object AniPathIterator::OnNext(ani_env* env, ani_array aniPointArray, ani_object aniOffsetObj)
 {
     int32_t offset = 0;
     ani_status ret = ANI_OK;
@@ -102,7 +99,8 @@ ani_object AniPathIterator::OnNext(ani_env* env, ani_object aniPointArray, ani_o
     env->Reference_IsUndefined(aniOffsetObj, &isUndefined);
     if (!isUndefined) {
         ani_int aniOffset = 0;
-        if (ANI_OK != env->Object_CallMethodByName_Int(aniOffsetObj, "toInt", ":i", &aniOffset)) {
+        if (ANI_OK != env->Object_CallMethod_Int(
+            aniOffsetObj, AniGlobalMethod::GetInstance().intGet, &aniOffset)) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param offset.");
             return CreateAniUndefined(env);
         }
@@ -114,8 +112,8 @@ ani_object AniPathIterator::OnNext(ani_env* env, ani_object aniPointArray, ani_o
         offset = static_cast<int32_t>(aniOffset);
     }
 
-    ani_int aniLength;
-    ret = env->Object_GetPropertyByName_Int(aniPointArray, "length", &aniLength);
+    ani_size aniLength;
+    ret = env->Array_GetLength(aniPointArray, &aniLength);
     if (ret != ANI_OK) {
         ROSEN_LOGE("AniPathIterator::Next points array invalid. ret: %{public}d", ret);
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param points.");
@@ -138,7 +136,8 @@ ani_object AniPathIterator::OnNext(ani_env* env, ani_object aniPointArray, ani_o
     }
 
     ani_enum_item enumItem;
-    bool result = CreateAniEnumByEnumIndex(env, ANI_ENUM_PATH_ITERATOR_VERB, static_cast<int>(returnVerb), enumItem);
+    bool result = CreateAniEnumByEnumIndex(
+        env, AniGlobalEnum::GetInstance().pathIteratorVerb, static_cast<ani_size>(returnVerb), enumItem);
     if (!result) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid path verb.");
         return CreateAniUndefined(env);
@@ -146,9 +145,10 @@ ani_object AniPathIterator::OnNext(ani_env* env, ani_object aniPointArray, ani_o
     return enumItem;
 }
 
-ani_object AniPathIterator::Next(ani_env* env, ani_object obj, ani_object aniPointArray, ani_object aniOffsetObj)
+ani_object AniPathIterator::Next(ani_env* env, ani_object obj, ani_array aniPointArray, ani_object aniOffsetObj)
 {
-    auto aniPathIterator = GetNativeFromObj<AniPathIterator>(env, obj);
+    auto aniPathIterator = GetNativeFromObj<AniPathIterator>(env, obj,
+        AniGlobalField::GetInstance().pathIteratorNativeObj);
     if (aniPathIterator == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return CreateAniUndefined(env);
@@ -166,7 +166,8 @@ ani_boolean AniPathIterator::OnHasNext(ani_env* env)
 
 ani_boolean AniPathIterator::HasNext(ani_env* env, ani_object obj)
 {
-    auto aniPathIterator = GetNativeFromObj<AniPathIterator>(env, obj);
+    auto aniPathIterator = GetNativeFromObj<AniPathIterator>(env, obj,
+        AniGlobalField::GetInstance().pathIteratorNativeObj);
     if (aniPathIterator == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return false;
@@ -183,7 +184,8 @@ ani_enum_item AniPathIterator::OnPeek(ani_env* env, PathIterator& pathIterator)
         pathVerb = pathIterator.Peek();
     }
     ani_enum_item enumItem;
-    bool result = CreateAniEnumByEnumIndex(env, ANI_ENUM_PATH_ITERATOR_VERB, static_cast<int>(pathVerb), enumItem);
+    bool result = CreateAniEnumByEnumIndex(
+        env, AniGlobalEnum::GetInstance().pathIteratorVerb, static_cast<ani_size>(pathVerb), enumItem);
     if (!result) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid path verb.");
         return nullptr;
@@ -193,7 +195,8 @@ ani_enum_item AniPathIterator::OnPeek(ani_env* env, PathIterator& pathIterator)
 
 ani_enum_item AniPathIterator::Peek(ani_env* env, ani_object obj)
 {
-    auto aniPathIterator = GetNativeFromObj<AniPathIterator>(env, obj);
+    auto aniPathIterator = GetNativeFromObj<AniPathIterator>(env, obj,
+        AniGlobalField::GetInstance().pathIteratorNativeObj);
     if (aniPathIterator == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return nullptr;
diff --git a/interfaces/kits/ani/drawing/path_iterator_ani/ani_path_iterator.h b/interfaces/kits/ani/drawing/path_iterator_ani/ani_path_iterator.h
index 2ee6f2698e..ec38f8b4f6 100644
--- a/interfaces/kits/ani/drawing/path_iterator_ani/ani_path_iterator.h
+++ b/interfaces/kits/ani/drawing/path_iterator_ani/ani_path_iterator.h
@@ -30,7 +30,7 @@ public:
 
     static void ConstructorWithPath(ani_env* env, ani_object obj, ani_object aniPathObj);
 
-    static ani_object Next(ani_env* env, ani_object obj, ani_object aniPointArray, ani_object aniOffsetObj);
+    static ani_object Next(ani_env* env, ani_object obj, ani_array aniPointArray, ani_object aniOffsetObj);
 
     static ani_boolean HasNext(ani_env* env, ani_object obj);
 
@@ -39,7 +39,7 @@ public:
     PathIterator& GetPathIterator();
 
 private:
-    ani_object OnNext(ani_env* env, ani_object aniPointArray, ani_object aniOffsetObj);
+    ani_object OnNext(ani_env* env, ani_array aniPointArray, ani_object aniOffsetObj);
     ani_boolean OnHasNext(ani_env* env);
     ani_enum_item OnPeek(ani_env* env, PathIterator& pathIterator);
 
diff --git a/interfaces/kits/ani/drawing/pen_ani/ani_pen.cpp b/interfaces/kits/ani/drawing/pen_ani/ani_pen.cpp
index 8853e67275..0d035ecfeb 100644
--- a/interfaces/kits/ani/drawing/pen_ani/ani_pen.cpp
+++ b/interfaces/kits/ani/drawing/pen_ani/ani_pen.cpp
@@ -28,9 +28,6 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_PEN_NAME = "@ohos.graphics.drawing.drawing.Pen";
-const char* ANI_CLASS_JOIN_STYLE_NAME = "@ohos.graphics.drawing.drawing.JoinStyle";
-const char* ANI_CLASS_CAP_STYLE_NAME = "@ohos.graphics.drawing.drawing.CapStyle";
 
 static const std::array g_methods = {
     ani_native_function { "constructorNative", ":", reinterpret_cast<void*>(AniPen::Constructor) },
@@ -74,13 +71,12 @@ static const std::array g_methods = {
 
 ani_status AniPen::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_PEN_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().pen;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_PEN_NAME);
         return ANI_NOT_FOUND;
     }
-    ret = env->Class_BindNativeMethods(cls, g_methods.data(), g_methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, g_methods.data(), g_methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_PEN_NAME);
         return ANI_NOT_FOUND;
@@ -113,7 +109,7 @@ void AniPen::Constructor(ani_env* env, ani_object obj)
 
 void AniPen::ConstructorWithPen(ani_env* env, ani_object obj, ani_object aniPenObj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, aniPenObj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, aniPenObj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params. ");
         return;
@@ -130,7 +126,7 @@ void AniPen::ConstructorWithPen(ani_env* env, ani_object obj, ani_object aniPenO
 
 ani_int AniPen::GetAlpha(ani_env* env, ani_object obj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params. ");
         return -1;
@@ -141,7 +137,7 @@ ani_int AniPen::GetAlpha(ani_env* env, ani_object obj)
 
 void AniPen::Reset(ani_env* env, ani_object obj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params. ");
         return;
@@ -152,7 +148,7 @@ void AniPen::Reset(ani_env* env, ani_object obj)
 
 void AniPen::SetAlpha(ani_env* env, ani_object obj, ani_int alpha)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params. ");
         return;
@@ -168,7 +164,7 @@ void AniPen::SetAlpha(ani_env* env, ani_object obj, ani_int alpha)
 
 void AniPen::SetBlendMode(ani_env* env, ani_object obj, ani_enum_item aniBlendMode)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params. ");
         return;
@@ -185,7 +181,7 @@ void AniPen::SetBlendMode(ani_env* env, ani_object obj, ani_enum_item aniBlendMo
 
 void AniPen::SetColorFilter(ani_env* env, ani_object obj, ani_object objColorFilter)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params. ");
         return;
@@ -195,7 +191,8 @@ void AniPen::SetColorFilter(ani_env* env, ani_object obj, ani_object objColorFil
     env->Reference_IsNull(objColorFilter, &isNull);
     AniColorFilter* aniColorFilter = nullptr;
     if (!isNull) {
-        aniColorFilter = GetNativeFromObj<AniColorFilter>(env, objColorFilter);
+        aniColorFilter = GetNativeFromObj<AniColorFilter>(env, objColorFilter,
+            AniGlobalField::GetInstance().colorFilterNativeObj);
         if (aniColorFilter == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param colorFilter.");
             return;
@@ -209,7 +206,7 @@ void AniPen::SetColorFilter(ani_env* env, ani_object obj, ani_object objColorFil
 
 ani_object AniPen::GetColorFilter(ani_env* env, ani_object obj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::GetColorFilter aniPen is nullptr.");
         return CreateAniUndefined(env);
@@ -218,7 +215,8 @@ ani_object AniPen::GetColorFilter(ani_env* env, ani_object obj)
         return CreateAniUndefined(env);
     }
     AniColorFilter* aniColorFilter = new AniColorFilter(aniPen->GetPen()->GetFilter().GetColorFilter());
-    ani_object aniObj = CreateAniObject(env, ANI_CLASS_COLORFILTER_NAME, nullptr);
+    ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().colorFilter,
+        AniGlobalMethod::GetInstance().colorFilterCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj,
         NATIVE_OBJ, reinterpret_cast<ani_long>(aniColorFilter))) {
         ROSEN_LOGE(" AniPen::GetColorFilter failed cause by Object_SetFieldByName_Long");
@@ -230,7 +228,7 @@ ani_object AniPen::GetColorFilter(ani_env* env, ani_object obj)
 
 ani_int AniPen::GetHexColor(ani_env* env, ani_object obj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::GetHexColor aniPen is nullptr.");
         return -1;
@@ -240,7 +238,7 @@ ani_int AniPen::GetHexColor(ani_env* env, ani_object obj)
 
 void AniPen::SetColor(ani_env* env, ani_object obj, ani_int color)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetColor aniPen is nullptr.");
         return;
@@ -253,7 +251,7 @@ void AniPen::SetColor(ani_env* env, ani_object obj, ani_int color)
 
 void AniPen::SetColorWithColor(ani_env* env, ani_object obj,  ani_object colorObj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetColor aniPen is nullptr.");
         return;
@@ -273,7 +271,7 @@ void AniPen::SetColorWithColor(ani_env* env, ani_object obj,  ani_object colorOb
 void AniPen::SetColorWithNumber(ani_env* env, ani_object obj, ani_int alpha,
     ani_int red, ani_int green, ani_int blue)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetColor aniPen is nullptr.");
         return;
@@ -304,7 +302,7 @@ void AniPen::SetColorWithNumber(ani_env* env, ani_object obj, ani_int alpha,
 
 void AniPen::SetDither(ani_env* env, ani_object obj, ani_boolean dither)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetDither aniPen is nullptr.");
         return;
@@ -313,7 +311,7 @@ void AniPen::SetDither(ani_env* env, ani_object obj, ani_boolean dither)
 
 void AniPen::SetAntiAlias(ani_env* env, ani_object obj, ani_boolean antiAlias)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetAntiAlias aniPen is nullptr.");
         return;
@@ -323,7 +321,7 @@ void AniPen::SetAntiAlias(ani_env* env, ani_object obj, ani_boolean antiAlias)
 
 void AniPen::SetStrokeWidth(ani_env* env, ani_object obj, ani_double width)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetStrokeWidth aniPen is nullptr.");
         return;
@@ -371,7 +369,7 @@ static Pen::CapStyle TsCapCastToCap(int32_t tsCap)
 
 void AniPen::SetCapStyle(ani_env* env, ani_object obj, ani_enum_item aniCapstyle)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetCapStyle aniPen is nullptr.");
         return;
@@ -386,12 +384,12 @@ void AniPen::SetCapStyle(ani_env* env, ani_object obj, ani_enum_item aniCapstyle
 
 ani_boolean AniPen::GetFillPath(ani_env* env, ani_object obj, ani_object src, ani_object dst)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::GetFillPath aniPen is nullptr.");
         return false;
     }
-    auto aniSrcPath = GetNativeFromObj<AniPath>(env, src);
+    auto aniSrcPath = GetNativeFromObj<AniPath>(env, src, AniGlobalField::GetInstance().pathNativeObj);
     if (aniSrcPath == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::GetFillPath aniSrcPath is nullptr.");
         return false;
@@ -400,7 +398,7 @@ ani_boolean AniPen::GetFillPath(ani_env* env, ani_object obj, ani_object src, an
         ROSEN_LOGE("AniPen::GetFillPath src path is nullptr");
         return false;
     }
-    auto aniDstPath = GetNativeFromObj<AniPath>(env, dst);
+    auto aniDstPath = GetNativeFromObj<AniPath>(env, dst, AniGlobalField::GetInstance().pathNativeObj);
     if (aniDstPath == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::GetFillPath aniDstPath is nullptr.");
         return false;
@@ -414,7 +412,7 @@ ani_boolean AniPen::GetFillPath(ani_env* env, ani_object obj, ani_object src, an
 
 void AniPen::SetMiterLimit(ani_env* env, ani_object obj, ani_double miter)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetMiterLimit aniPen is nullptr.");
         return;
@@ -425,21 +423,16 @@ void AniPen::SetMiterLimit(ani_env* env, ani_object obj, ani_double miter)
 ani_enum_item AniPen::GetCapStyle(ani_env* env, ani_object obj)
 {
     ani_enum_item value = nullptr;
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetMiterLimit aniPen is nullptr.");
         return value;
     }
-    ani_enum enumType;
-    if (ANI_OK != env->FindEnum(ANI_CLASS_CAP_STYLE_NAME, &enumType)) {
-        ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
-            "Find enum for CapStyle failed.");
-        return value;
-    }
     Pen::CapStyle capStyle = aniPen->GetPen()->GetCapStyle();
-    if (ANI_OK != env->Enum_GetEnumItemByIndex(enumType, static_cast<ani_size>(CapCastToTsCap(capStyle)), &value)) {
+    if (!CreateAniEnumByEnumIndex(
+        env, AniGlobalEnum::GetInstance().capStyle, static_cast<ani_size>(CapCastToTsCap(capStyle)), value)) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
-            "Failed to obtain the CapStyle enumeration.");
+            "Find enum for CapStyle failed.");
         return value;
     }
     return value;
@@ -447,7 +440,7 @@ ani_enum_item AniPen::GetCapStyle(ani_env* env, ani_object obj)
 
 ani_boolean AniPen::IsAntiAlias(ani_env* env, ani_object obj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::IsAntiAlias aniPen is nullptr.");
         return false;
@@ -457,7 +450,7 @@ ani_boolean AniPen::IsAntiAlias(ani_env* env, ani_object obj)
 
 ani_object AniPen::GetColor(ani_env* env, ani_object obj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::GetColor aniPen is nullptr.");
         return CreateAniUndefined(env);
@@ -470,7 +463,7 @@ ani_object AniPen::GetColor(ani_env* env, ani_object obj)
 
 void AniPen::SetJoinStyle(ani_env* env, ani_object obj, ani_enum_item aniJoinStyle)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetJoinStyle aniPen is nullptr.");
         return;
@@ -487,22 +480,15 @@ void AniPen::SetJoinStyle(ani_env* env, ani_object obj, ani_enum_item aniJoinSty
 ani_enum_item AniPen::GetJoinStyle(ani_env* env, ani_object obj)
 {
     ani_enum_item value = nullptr;
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::GetJoinStyle aniPen is nullptr.");
         return value;
     }
-    ani_enum enumType;
-    if (ANI_OK != env->FindEnum(ANI_CLASS_JOIN_STYLE_NAME, &enumType)) {
-        ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
-            "Find enum for JoinStyle failed.");
-        return value;
-    }
-
     Pen::JoinStyle joinStyle = aniPen->GetPen()->GetJoinStyle();
-    if (ANI_OK != env->Enum_GetEnumItemByIndex(enumType, static_cast<ani_size>(joinStyle), &value)) {
+    if (!CreateAniEnumByEnumIndex(env, AniGlobalEnum::GetInstance().joinStyle, static_cast<ani_size>(joinStyle), value)) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
-            "Failed to obtain the JoinStyle enumeration.");
+            "Find enum for JoinStyle failed.");
         return value;
     }
     return value;
@@ -510,7 +496,7 @@ ani_enum_item AniPen::GetJoinStyle(ani_env* env, ani_object obj)
 
 ani_double AniPen::GetWidth(ani_env* env, ani_object obj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::GetWidth aniPen is nullptr.");
         return -1;
@@ -520,7 +506,7 @@ ani_double AniPen::GetWidth(ani_env* env, ani_object obj)
 
 ani_double AniPen::GetMiterLimit(ani_env* env, ani_object obj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::GetMiterLimit aniPen is nullptr.");
         return -1;
@@ -530,7 +516,7 @@ ani_double AniPen::GetMiterLimit(ani_env* env, ani_object obj)
 
 void AniPen::SetPathEffect(ani_env* env, ani_object obj, ani_object aniPathEffectObj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetPathEffect aniPen is nullptr.");
         return;
@@ -539,7 +525,8 @@ void AniPen::SetPathEffect(ani_env* env, ani_object obj, ani_object aniPathEffec
     env->Reference_IsNull(aniPathEffectObj, &isNull);
     AniPathEffect* aniPathEffect = nullptr;
     if (!isNull) {
-        aniPathEffect = GetNativeFromObj<AniPathEffect>(env, aniPathEffectObj);
+        aniPathEffect = GetNativeFromObj<AniPathEffect>(env, aniPathEffectObj,
+            AniGlobalField::GetInstance().pathEffectNativeObj);
         if (aniPathEffect == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param pathEffect.");
             return;
@@ -550,7 +537,7 @@ void AniPen::SetPathEffect(ani_env* env, ani_object obj, ani_object aniPathEffec
 
 void AniPen::SetImageFilter(ani_env* env, ani_object obj, ani_object aniImageFilterObj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetImageFilter aniPen is nullptr.");
         return;
@@ -559,7 +546,8 @@ void AniPen::SetImageFilter(ani_env* env, ani_object obj, ani_object aniImageFil
     env->Reference_IsNull(aniImageFilterObj, &isNull);
     AniImageFilter* aniImageFilter = nullptr;
     if (!isNull) {
-        aniImageFilter = GetNativeFromObj<AniImageFilter>(env, aniImageFilterObj);
+        aniImageFilter = GetNativeFromObj<AniImageFilter>(env, aniImageFilterObj,
+            AniGlobalField::GetInstance().imageFilterNativeObj);
         if (aniImageFilter == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param imageFilter.");
             return;
@@ -572,7 +560,7 @@ void AniPen::SetImageFilter(ani_env* env, ani_object obj, ani_object aniImageFil
 
 void AniPen::SetMaskFilter(ani_env* env, ani_object obj, ani_object aniMaskFilterObj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetMaskFilter aniPen is nullptr.");
         return;
@@ -581,7 +569,8 @@ void AniPen::SetMaskFilter(ani_env* env, ani_object obj, ani_object aniMaskFilte
     env->Reference_IsNull(aniMaskFilterObj, &isNull);
     AniMaskFilter* aniMaskFilter = nullptr;
     if (!isNull) {
-        aniMaskFilter = GetNativeFromObj<AniMaskFilter>(env, aniMaskFilterObj);
+        aniMaskFilter = GetNativeFromObj<AniMaskFilter>(env, aniMaskFilterObj,
+            AniGlobalField::GetInstance().maskFilterNativeObj);
         if (aniMaskFilter == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param maskFilter.");
             return;
@@ -594,7 +583,7 @@ void AniPen::SetMaskFilter(ani_env* env, ani_object obj, ani_object aniMaskFilte
 
 void AniPen::SetShadowLayer(ani_env* env, ani_object obj, ani_object aniShadowLayerObj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetShadowLayer aniPen is nullptr.");
         return;
@@ -603,7 +592,8 @@ void AniPen::SetShadowLayer(ani_env* env, ani_object obj, ani_object aniShadowLa
     env->Reference_IsNull(aniShadowLayerObj, &isNull);
     AniShadowLayer* aniShadowLayer = nullptr;
     if (!isNull) {
-        aniShadowLayer = GetNativeFromObj<AniShadowLayer>(env, aniShadowLayerObj);
+        aniShadowLayer = GetNativeFromObj<AniShadowLayer>(env, aniShadowLayerObj,
+            AniGlobalField::GetInstance().shadowLayerNativeObj);
         if (aniShadowLayer == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param shadowLayer.");
             return;
@@ -614,7 +604,7 @@ void AniPen::SetShadowLayer(ani_env* env, ani_object obj, ani_object aniShadowLa
 
 void AniPen::SetShaderEffect(ani_env* env, ani_object obj, ani_object aniShaderEffectObj)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, obj);
+    auto aniPen = GetNativeFromObj<AniPen>(env, obj, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniPen::SetShaderEffect aniPen is nullptr.");
         return;
@@ -623,7 +613,8 @@ void AniPen::SetShaderEffect(ani_env* env, ani_object obj, ani_object aniShaderE
     env->Reference_IsNull(aniShaderEffectObj, &isNull);
     AniShaderEffect* aniShaderEffect = nullptr;
     if (!isNull) {
-        aniShaderEffect = GetNativeFromObj<AniShaderEffect>(env, aniShaderEffectObj);
+        aniShaderEffect = GetNativeFromObj<AniShaderEffect>(env, aniShaderEffectObj,
+            AniGlobalField::GetInstance().shaderEffectNativeObj);
         if (aniShaderEffect == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid param shaderEffect.");
             return;
@@ -661,7 +652,7 @@ ani_object AniPen::PenTransferStatic(ani_env* env, [[maybe_unused]]ani_object ob
 
 ani_long AniPen::GetPenAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniPen = GetNativeFromObj<AniPen>(env, input);
+    auto aniPen = GetNativeFromObj<AniPen>(env, input, AniGlobalField::GetInstance().penNativeObj);
     if (aniPen == nullptr || aniPen->GetPen() == nullptr) {
         ROSEN_LOGE("AniPen::GetPenAddr aniPen is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/rect_utils_ani/ani_rect_utils.cpp b/interfaces/kits/ani/drawing/rect_utils_ani/ani_rect_utils.cpp
index 1a495abb4d..ddd883e033 100644
--- a/interfaces/kits/ani/drawing/rect_utils_ani/ani_rect_utils.cpp
+++ b/interfaces/kits/ani/drawing/rect_utils_ani/ani_rect_utils.cpp
@@ -17,13 +17,11 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_RECT_UTILS_NAME = "@ohos.graphics.drawing.drawing.RectUtils";
 
 ani_status AniRectUtils::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_RECT_UTILS_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().rectUtils;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_RECT_UTILS_NAME);
         return ANI_NOT_FOUND;
     }
@@ -40,7 +38,7 @@ ani_status AniRectUtils::AniInit(ani_env *env)
         ani_native_function { "offset", nullptr, reinterpret_cast<void*>(Offset) },
     };
 
-    ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_RECT_UTILS_NAME);
         return ANI_NOT_FOUND;
diff --git a/interfaces/kits/ani/drawing/region_ani/ani_region.cpp b/interfaces/kits/ani/drawing/region_ani/ani_region.cpp
index 6288df2051..5e47e395c7 100644
--- a/interfaces/kits/ani/drawing/region_ani/ani_region.cpp
+++ b/interfaces/kits/ani/drawing/region_ani/ani_region.cpp
@@ -23,13 +23,11 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_REGION_NAME = "@ohos.graphics.drawing.drawing.Region";
 
 ani_status AniRegion::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_REGION_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().region;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_REGION_NAME);
         return ANI_NOT_FOUND;
     }
@@ -54,7 +52,7 @@ ani_status AniRegion::AniInit(ani_env *env)
         ani_native_function { "offset", "ii:", reinterpret_cast<void*>(Offset) },
     };
 
-    ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_REGION_NAME);
         return ANI_NOT_FOUND;
@@ -87,7 +85,7 @@ void AniRegion::Constructor(ani_env* env, ani_object obj)
 
 void AniRegion::ConstructorWithRegion(ani_env* env, ani_object obj, ani_object aniRegionObj)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, aniRegionObj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, aniRegionObj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr) {
         AniThrowError(env, "Invalid params. "); // message length must be a multiple of 4, for example 16, 20, etc
         return;
@@ -118,7 +116,7 @@ void AniRegion::ConstructorWithRect(ani_env* env, ani_object obj, ani_int left,
 
 void AniRegion::SetEmpty(ani_env* env, ani_object obj)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniRegion::SetEmpty invalid params: obj. ");
@@ -131,7 +129,7 @@ void AniRegion::SetEmpty(ani_env* env, ani_object obj)
 ani_boolean AniRegion::QuickReject(ani_env* env, ani_object obj, ani_int left, ani_int top, ani_int right,
     ani_int bottom)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniRegion::QuickReject aniRegion is nullptr.");
         return false;
@@ -143,7 +141,7 @@ ani_boolean AniRegion::QuickReject(ani_env* env, ani_object obj, ani_int left, a
 ani_boolean AniRegion::SetRect(ani_env* env, ani_object obj, ani_int left, ani_int top, ani_int right,
     ani_int bottom)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniRegion::SetRect aniRegion is nullptr.");
         return false;
@@ -154,13 +152,13 @@ ani_boolean AniRegion::SetRect(ani_env* env, ani_object obj, ani_int left, ani_i
 
 ani_boolean AniRegion::IsRegionContained(ani_env* env, ani_object obj, ani_object aniRegionObj)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniRegion::IsRegionContained aniRegion is nullptr.");
         return false;
     }
-    auto otherAniRegion = GetNativeFromObj<AniRegion>(env, aniRegionObj);
+    auto otherAniRegion = GetNativeFromObj<AniRegion>(env, aniRegionObj, AniGlobalField::GetInstance().regionNativeObj);
     if (otherAniRegion == nullptr || otherAniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniRegion::IsRegionContained other aniRegion is nullptr.");
@@ -172,12 +170,12 @@ ani_boolean AniRegion::IsRegionContained(ani_env* env, ani_object obj, ani_objec
 
 ani_boolean AniRegion::Op(ani_env* env, ani_object obj, ani_object aniRegionObj, ani_enum_item aniRegionOp)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniRegion::Op aniRegion is nullptr.");
         return false;
     }
-    auto otherAniRegion = GetNativeFromObj<AniRegion>(env, aniRegionObj);
+    auto otherAniRegion = GetNativeFromObj<AniRegion>(env, aniRegionObj, AniGlobalField::GetInstance().regionNativeObj);
     if (otherAniRegion == nullptr || otherAniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniRegion::Op other aniRegion is nullptr.");
         return false;
@@ -200,12 +198,12 @@ ani_boolean AniRegion::Op(ani_env* env, ani_object obj, ani_object aniRegionObj,
 
 ani_boolean AniRegion::SetPath(ani_env* env, ani_object obj, ani_object aniPathObj, ani_enum_item aniClipRegion)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniRegion::SetPath aniRegion is nullptr.");
         return false;
     }
-    auto aniPath = GetNativeFromObj<AniPath>(env, aniPathObj);
+    auto aniPath = GetNativeFromObj<AniPath>(env, aniPathObj, AniGlobalField::GetInstance().pathNativeObj);
     if (aniPath == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniRegion::SetPath incorrect param0.");
         return false;
@@ -215,7 +213,7 @@ ani_boolean AniRegion::SetPath(ani_env* env, ani_object obj, ani_object aniPathO
         return false;
     }
 
-    auto clip = GetNativeFromObj<AniRegion>(env, aniClipRegion);
+    auto clip = GetNativeFromObj<AniRegion>(env, aniClipRegion, AniGlobalField::GetInstance().regionNativeObj);
     if (clip == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniRegion::SetPath incorrect param1.");
         return false;
@@ -229,7 +227,7 @@ ani_boolean AniRegion::SetPath(ani_env* env, ani_object obj, ani_object aniPathO
 
 ani_boolean AniRegion::IsPointContained(ani_env* env, ani_object obj, ani_int dx, ani_int dy)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniRegion::IsPointContained aniRegion is nullptr.");
@@ -240,7 +238,7 @@ ani_boolean AniRegion::IsPointContained(ani_env* env, ani_object obj, ani_int dx
 
 ani_boolean AniRegion::IsRect(ani_env* env, ani_object obj)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniRegion::IsRect aniRegion is nullptr.");
@@ -252,7 +250,7 @@ ani_boolean AniRegion::IsRect(ani_env* env, ani_object obj)
 ani_boolean AniRegion::QuickContains(ani_env* env, ani_object obj, ani_int left, ani_int top, ani_int right,
     ani_int bottom)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniRegion::QuickContains aniRegion is nullptr.");
@@ -264,7 +262,7 @@ ani_boolean AniRegion::QuickContains(ani_env* env, ani_object obj, ani_int left,
 
 void AniRegion::Offset(ani_env* env, ani_object obj, ani_int dx, ani_int dy)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, obj, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniRegion::Offset aniRegion is nullptr.");
@@ -303,7 +301,7 @@ ani_object AniRegion::RegionTransferStatic(
 
 ani_long AniRegion::GetRegionAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniRegion = GetNativeFromObj<AniRegion>(env, input);
+    auto aniRegion = GetNativeFromObj<AniRegion>(env, input, AniGlobalField::GetInstance().regionNativeObj);
     if (aniRegion == nullptr || aniRegion->GetRegion() == nullptr) {
         ROSEN_LOGE("AniRegion::GetRegionAddr aniRegion is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/round_rect_ani/ani_round_rect.cpp b/interfaces/kits/ani/drawing/round_rect_ani/ani_round_rect.cpp
index 43e259ff78..64363b7c86 100644
--- a/interfaces/kits/ani/drawing/round_rect_ani/ani_round_rect.cpp
+++ b/interfaces/kits/ani/drawing/round_rect_ani/ani_round_rect.cpp
@@ -22,13 +22,11 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_ROUND_RECT_NAME = "@ohos.graphics.drawing.drawing.RoundRect";
 
 ani_status AniRoundRect::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_ROUND_RECT_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().roundRect;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_ROUND_RECT_NAME);
         return ANI_NOT_FOUND;
     }
@@ -45,7 +43,7 @@ ani_status AniRoundRect::AniInit(ani_env *env)
         ani_native_function { "offset", "dd:", reinterpret_cast<void*>(Offset) },
     };
 
-    ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_ROUND_RECT_NAME);
         return ANI_NOT_FOUND;
@@ -84,7 +82,8 @@ void AniRoundRect::ConstructorWithRect(ani_env* env, ani_object obj, ani_object
 
 void AniRoundRect::ConstructorWithRoundRect(ani_env* env, ani_object obj, ani_object aniRoundRectObj)
 {
-    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, aniRoundRectObj);
+    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, aniRoundRectObj,
+        AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniRoundRect == nullptr) {
         AniThrowError(env, "Invalid params. "); // message length must be a multiple of 4, for example 16, 20, etc
         return;
@@ -102,7 +101,7 @@ void AniRoundRect::ConstructorWithRoundRect(ani_env* env, ani_object obj, ani_ob
 
 void AniRoundRect::SetCorner(ani_env* env, ani_object obj, ani_enum_item aniPos, ani_double x, ani_double y)
 {
-    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, obj);
+    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, obj, AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniRoundRect == nullptr || aniRoundRect->GetRoundRect() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniRoundRect::SetCorner aniRoundRect is nullptr.");
@@ -119,7 +118,7 @@ void AniRoundRect::SetCorner(ani_env* env, ani_object obj, ani_enum_item aniPos,
 
 ani_object AniRoundRect::GetCorner(ani_env* env, ani_object obj, ani_enum_item aniPos)
 {
-    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, obj);
+    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, obj, AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniRoundRect == nullptr || aniRoundRect->GetRoundRect() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "AniRoundRect::GetCorner aniRoundRect is nullptr.");
@@ -141,7 +140,7 @@ ani_object AniRoundRect::GetCorner(ani_env* env, ani_object obj, ani_enum_item a
 
 void AniRoundRect::Offset(ani_env* env, ani_object obj, ani_double x, ani_double y)
 {
-    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, obj);
+    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, obj, AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniRoundRect == nullptr || aniRoundRect->GetRoundRect() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniRoundRect::Offset aniRoundRect is nullptr.");
         return;
@@ -168,7 +167,8 @@ ani_object AniRoundRect::RoundRectTransferStatic(ani_env* env, [[maybe_unused]]a
     }
 
     auto aniRoundRect = new AniRoundRect(jsRoundRect->GetRoundRectPtr());
-    ani_object aniRoundRectObj = CreateAniObject(env, ANI_CLASS_ROUND_RECT_NAME, ":");
+    ani_object aniRoundRectObj = CreateAniObject(env, AniGlobalClass::GetInstance().roundRect,
+        AniGlobalMethod::GetInstance().roundRectCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniRoundRectObj,
         NATIVE_OBJ, reinterpret_cast<ani_long>(aniRoundRect))) {
         ROSEN_LOGE("AniRoundRect::RoundRectTransferStatic failed create aniRoundRect");
@@ -180,7 +180,7 @@ ani_object AniRoundRect::RoundRectTransferStatic(ani_env* env, [[maybe_unused]]a
 
 ani_long AniRoundRect::GetRoundRectAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, input);
+    auto aniRoundRect = GetNativeFromObj<AniRoundRect>(env, input, AniGlobalField::GetInstance().roundRectNativeObj);
     if (aniRoundRect == nullptr || aniRoundRect->GetRoundRect() == nullptr) {
         ROSEN_LOGE("AniRoundRect::GetRoundRectAddr aniRoundRect is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/sampling_options_ani/ani_sampling_options.cpp b/interfaces/kits/ani/drawing/sampling_options_ani/ani_sampling_options.cpp
index 2c18cea973..7eea49a047 100644
--- a/interfaces/kits/ani/drawing/sampling_options_ani/ani_sampling_options.cpp
+++ b/interfaces/kits/ani/drawing/sampling_options_ani/ani_sampling_options.cpp
@@ -23,13 +23,10 @@
 namespace OHOS::Rosen {
 namespace Drawing {
 
-const char* ANI_CLASS_SAMPLING_OPTIONS_NAME = "@ohos.graphics.drawing.drawing.SamplingOptions";
-
 ani_status AniSamplingOptions::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_SAMPLING_OPTIONS_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().samplingOptions;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_SAMPLING_OPTIONS_NAME);
         return ANI_NOT_FOUND;
     }
@@ -40,7 +37,7 @@ ani_status AniSamplingOptions::AniInit(ani_env *env)
             reinterpret_cast<void*>(ConstructorWithFilterMode) },
     };
 
-    ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_SAMPLING_OPTIONS_NAME);
         return ANI_NOT_FOUND;
@@ -120,7 +117,8 @@ ani_object AniSamplingOptions::SamplingOptionsTransferStatic(
 
 ani_long AniSamplingOptions::GetSamplingOptionsAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniSamplingOptions = GetNativeFromObj<AniSamplingOptions>(env, input);
+    auto aniSamplingOptions = GetNativeFromObj<AniSamplingOptions>(env, input,
+        AniGlobalField::GetInstance().samplingOptionsNativeObj);
     if (aniSamplingOptions == nullptr || aniSamplingOptions->GetSamplingOptions() == nullptr) {
         ROSEN_LOGE("AniSamplingOptions::GetSamplingOptionsAddr aniSamplingOptions is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/shader_effect_ani/ani_shader_effect.cpp b/interfaces/kits/ani/drawing/shader_effect_ani/ani_shader_effect.cpp
index 170b3c2b1c..0c99fdda44 100644
--- a/interfaces/kits/ani/drawing/shader_effect_ani/ani_shader_effect.cpp
+++ b/interfaces/kits/ani/drawing/shader_effect_ani/ani_shader_effect.cpp
@@ -18,13 +18,11 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_SHADER_EFFECT_NAME = "@ohos.graphics.drawing.drawing.ShaderEffect";
 
 ani_status AniShaderEffect::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_SHADER_EFFECT_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().shaderEffect;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_SHADER_EFFECT_NAME);
         return ANI_NOT_FOUND;
     }
@@ -39,7 +37,7 @@ ani_status AniShaderEffect::AniInit(ani_env *env)
         ani_native_function { "createRadialGradient", nullptr, reinterpret_cast<void*>(CreateRadialGradient) },
     };
 
-    ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_SHADER_EFFECT_NAME);
         return ANI_NOT_FOUND;
@@ -48,10 +46,10 @@ ani_status AniShaderEffect::AniInit(ani_env *env)
     return ANI_OK;
 }
 
-bool GetColorsArray(ani_env* env, ani_object corlorsArray, std::vector<ColorQuad>& colors)
+bool GetColorsArray(ani_env* env, ani_array corlorsArray, std::vector<ColorQuad>& colors)
 {
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(corlorsArray, "length", &aniLength)) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(corlorsArray, &aniLength)) {
         ROSEN_LOGE("colors are invalid");
         return false;
     }
@@ -60,9 +58,9 @@ bool GetColorsArray(ani_env* env, ani_object corlorsArray, std::vector<ColorQuad
     for (uint32_t i = 0; i < colorsSize; i++) {
         ani_int color;
         ani_ref colorRef;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(corlorsArray,
-            "$_get", "i:Y", &colorRef, (ani_int)i) ||
-            ANI_OK != env->Object_CallMethodByName_Int(static_cast<ani_object>(colorRef), "toInt", ":i", &color)) {
+        if (ANI_OK != env->Array_Get(corlorsArray, (ani_int)i, &colorRef) ||
+            ANI_OK != env->Object_CallMethod_Int(
+                static_cast<ani_object>(colorRef), AniGlobalMethod::GetInstance().intGet, &color)) {
             ROSEN_LOGE("get color ref failed.");
             return false;
         }
@@ -71,10 +69,10 @@ bool GetColorsArray(ani_env* env, ani_object corlorsArray, std::vector<ColorQuad
     return true;
 }
 
-bool GetPosArray(ani_env* env, ani_object posArray, std::vector<float>& pos)
+bool GetPosArray(ani_env* env, ani_array posArray, std::vector<float>& pos)
 {
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(posArray, "length", &aniLength)) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(posArray, &aniLength)) {
         ROSEN_LOGE("pos are invalid");
         return false;
     }
@@ -83,9 +81,9 @@ bool GetPosArray(ani_env* env, ani_object posArray, std::vector<float>& pos)
     for (uint32_t i = 0; i < size; i++) {
         ani_double value;
         ani_ref posRef;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(
-            posArray, "$_get", "i:Y", &posRef, (ani_int)i) ||
-            ANI_OK != env->Object_CallMethodByName_Double(static_cast<ani_object>(posRef), "toDouble", ":d", &value)) {
+        if (ANI_OK != env->Array_Get(posArray, (ani_int)i, &posRef) ||
+            ANI_OK != env->Object_CallMethod_Double(
+                static_cast<ani_object>(posRef), AniGlobalMethod::GetInstance().doubleGet, &value)) {
             ROSEN_LOGE("get pos ref failed.");
             return false;
         }
@@ -137,7 +135,7 @@ ani_object AniShaderEffect::CreateColorShader(ani_env* env, ani_object obj, ani_
 }
 
 ani_object AniShaderEffect::CreateLinearGradient(ani_env* env, ani_object obj, ani_object startPt, ani_object endPt,
-    ani_object colorsArray, ani_enum_item aniTileMode, ani_object aniPos, ani_object aniMatrix)
+    ani_array colorsArray, ani_enum_item aniTileMode, ani_object aniPos, ani_object aniMatrix)
 {
     Drawing::Point startPoint;
     if (GetPointFromPointObj(env, startPt, startPoint) != ANI_OK) {
@@ -167,7 +165,7 @@ ani_object AniShaderEffect::CreateLinearGradient(ani_env* env, ani_object obj, a
 
     std::vector<scalar> pos;
     if (IsReferenceValid(env, aniPos)) {
-        if (!GetPosArray(env, aniPos, pos)) {
+        if (!GetPosArray(env, reinterpret_cast<ani_array>(aniPos), pos)) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniShaderEffect::CreateLinearGradient get posArray failed.");
             return CreateAniUndefined(env);
@@ -176,7 +174,7 @@ ani_object AniShaderEffect::CreateLinearGradient(ani_env* env, ani_object obj, a
 
     Drawing::Matrix* drawingMatrixPtr = nullptr;
     if (IsReferenceValid(env, aniMatrix)) {
-        auto aniMatrixObj = GetNativeFromObj<AniMatrix>(env, aniMatrix);
+        auto aniMatrixObj = GetNativeFromObj<AniMatrix>(env, aniMatrix, AniGlobalField::GetInstance().matrixNativeObj);
         if (aniMatrixObj == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniShaderEffect::CreateLinearGradient get matrix failed.");
@@ -190,7 +188,7 @@ ani_object AniShaderEffect::CreateLinearGradient(ani_env* env, ani_object obj, a
 }
 
 ani_object AniShaderEffect::CreateConicalGradient(ani_env* env, ani_object obj, ani_object startPt,
-    ani_double startRadius, ani_object endPt, ani_double endRadius, ani_object colorsArray,
+    ani_double startRadius, ani_object endPt, ani_double endRadius, ani_array colorsArray,
     ani_enum_item aniTileMode, ani_object aniPos, ani_object aniMatrix)
 {
     Drawing::Point startPoint;
@@ -221,7 +219,7 @@ ani_object AniShaderEffect::CreateConicalGradient(ani_env* env, ani_object obj,
 
     std::vector<scalar> pos;
     if (IsReferenceValid(env, aniPos)) {
-        if (!GetPosArray(env, aniPos, pos)) {
+        if (!GetPosArray(env, reinterpret_cast<ani_array>(aniPos), pos)) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniShaderEffect::CreateConicalGradient get posArray failed.");
             return CreateAniUndefined(env);
@@ -230,7 +228,7 @@ ani_object AniShaderEffect::CreateConicalGradient(ani_env* env, ani_object obj,
 
     Drawing::Matrix* drawingMatrixPtr = nullptr;
     if (IsReferenceValid(env, aniMatrix)) {
-        auto aniMatrixObj = GetNativeFromObj<AniMatrix>(env, aniMatrix);
+        auto aniMatrixObj = GetNativeFromObj<AniMatrix>(env, aniMatrix, AniGlobalField::GetInstance().matrixNativeObj);
         if (aniMatrixObj == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniShaderEffect::CreateConicalGradient get matrix failed.");
@@ -244,7 +242,7 @@ ani_object AniShaderEffect::CreateConicalGradient(ani_env* env, ani_object obj,
 }
 
 ani_object AniShaderEffect::CreateSweepGradient(
-    ani_env* env, ani_object obj, ani_object centerPt, ani_object colorsArray, ani_enum_item aniTileMode,
+    ani_env* env, ani_object obj, ani_object centerPt, ani_array colorsArray, ani_enum_item aniTileMode,
     ani_double startAngle, ani_double endAngle, ani_object aniPos, ani_object aniMatrix)
 {
     Drawing::Point centerPoint;
@@ -270,7 +268,7 @@ ani_object AniShaderEffect::CreateSweepGradient(
 
     std::vector<scalar> pos;
     if (IsReferenceValid(env, aniPos)) {
-        if (!GetPosArray(env, aniPos, pos)) {
+        if (!GetPosArray(env, reinterpret_cast<ani_array>(aniPos), pos)) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniShaderEffect::CreateSweepGradient get posArray failed.");
             return CreateAniUndefined(env);
@@ -279,7 +277,7 @@ ani_object AniShaderEffect::CreateSweepGradient(
 
     Drawing::Matrix* drawingMatrixPtr = nullptr;
     if (IsReferenceValid(env, aniMatrix)) {
-        auto aniMatrixObj = GetNativeFromObj<AniMatrix>(env, aniMatrix);
+        auto aniMatrixObj = GetNativeFromObj<AniMatrix>(env, aniMatrix, AniGlobalField::GetInstance().matrixNativeObj);
         if (aniMatrixObj == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniShaderEffect::CreateSweepGradient get matrix failed.");
@@ -293,7 +291,7 @@ ani_object AniShaderEffect::CreateSweepGradient(
 }
 
 ani_object AniShaderEffect::CreateRadialGradient(ani_env* env, ani_object obj, ani_object centerPt, ani_double radius,
-    ani_object colorsArray, ani_enum_item aniTileMode, ani_object aniPos, ani_object aniMatrix)
+    ani_array colorsArray, ani_enum_item aniTileMode, ani_object aniPos, ani_object aniMatrix)
 {
     Drawing::Point centerPoint;
     if (GetPointFromPointObj(env, centerPt, centerPoint) != ANI_OK) {
@@ -318,7 +316,7 @@ ani_object AniShaderEffect::CreateRadialGradient(ani_env* env, ani_object obj, a
 
     std::vector<scalar> pos;
     if (IsReferenceValid(env, aniPos)) {
-        if (!GetPosArray(env, aniPos, pos)) {
+        if (!GetPosArray(env, reinterpret_cast<ani_array>(aniPos), pos)) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniShaderEffect::CreateRadialGradient get posArray failed.");
             return CreateAniUndefined(env);
@@ -327,7 +325,7 @@ ani_object AniShaderEffect::CreateRadialGradient(ani_env* env, ani_object obj, a
 
     Drawing::Matrix* drawingMatrixPtr = nullptr;
     if (IsReferenceValid(env, aniMatrix)) {
-        auto aniMatrixObj = GetNativeFromObj<AniMatrix>(env, aniMatrix);
+        auto aniMatrixObj = GetNativeFromObj<AniMatrix>(env, aniMatrix, AniGlobalField::GetInstance().matrixNativeObj);
         if (aniMatrixObj == nullptr) {
             ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
                 "AniShaderEffect::CreateRadialGradient get matrix failed.");
diff --git a/interfaces/kits/ani/drawing/shader_effect_ani/ani_shader_effect.h b/interfaces/kits/ani/drawing/shader_effect_ani/ani_shader_effect.h
index 7d88891f03..070f68a249 100644
--- a/interfaces/kits/ani/drawing/shader_effect_ani/ani_shader_effect.h
+++ b/interfaces/kits/ani/drawing/shader_effect_ani/ani_shader_effect.h
@@ -30,14 +30,14 @@ public:
 
     static ani_object CreateColorShader(ani_env* env, ani_object obj, ani_int color);
     static ani_object CreateLinearGradient(ani_env* env, ani_object obj, ani_object startPt, ani_object endPt,
-        ani_object colorsArray, ani_enum_item aniTileMode, ani_object aniPos, ani_object aniMatrix);
+        ani_array colorsArray, ani_enum_item aniTileMode, ani_object aniPos, ani_object aniMatrix);
     static ani_object CreateConicalGradient(ani_env* env, ani_object obj, ani_object startPt, ani_double startRadius,
-        ani_object endPt, ani_double endRadius, ani_object colorsArray, ani_enum_item aniTileMode, ani_object aniPos,
+        ani_object endPt, ani_double endRadius, ani_array colorsArray, ani_enum_item aniTileMode, ani_object aniPos,
         ani_object aniMatrix);
-    static ani_object CreateSweepGradient(ani_env* env, ani_object obj, ani_object centerPt, ani_object colorsArray,
+    static ani_object CreateSweepGradient(ani_env* env, ani_object obj, ani_object centerPt, ani_array colorsArray,
         ani_enum_item aniTileMode, ani_double startAngle, ani_double endAngle, ani_object aniPos, ani_object aniMatrix);
     static ani_object CreateRadialGradient(ani_env* env, ani_object obj, ani_object centerPt, ani_double radius,
-        ani_object colorsArray, ani_enum_item aniTileMode, ani_object aniPos, ani_object aniMatrix);
+        ani_array colorsArray, ani_enum_item aniTileMode, ani_object aniPos, ani_object aniMatrix);
     std::shared_ptr<ShaderEffect> GetShaderEffect();
 private:
     static ani_boolean IsReferenceValid(ani_env* env, ani_object obj);
diff --git a/interfaces/kits/ani/drawing/shadow_layer_ani/ani_shadow_layer.cpp b/interfaces/kits/ani/drawing/shadow_layer_ani/ani_shadow_layer.cpp
index d25af86a30..de09db1817 100644
--- a/interfaces/kits/ani/drawing/shadow_layer_ani/ani_shadow_layer.cpp
+++ b/interfaces/kits/ani/drawing/shadow_layer_ani/ani_shadow_layer.cpp
@@ -17,13 +17,11 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_SHADOW_LAYER_NAME = "@ohos.graphics.drawing.drawing.ShadowLayer";
 
 ani_status AniShadowLayer::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_SHADOW_LAYER_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().shadowLayer;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_SHADOW_LAYER_NAME);
         return ANI_NOT_FOUND;
     }
@@ -35,7 +33,7 @@ ani_status AniShadowLayer::AniInit(ani_env *env)
             "C{@ohos.graphics.drawing.drawing.ShadowLayer}", reinterpret_cast<void*>(Create) },
     };
 
-    ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind static methods fail: %{public}s", ANI_CLASS_SHADOW_LAYER_NAME);
         return ANI_NOT_FOUND;
diff --git a/interfaces/kits/ani/drawing/text_blob_ani/ani_text_blob.cpp b/interfaces/kits/ani/drawing/text_blob_ani/ani_text_blob.cpp
index 6cbf01abdd..7a97dad4c2 100644
--- a/interfaces/kits/ani/drawing/text_blob_ani/ani_text_blob.cpp
+++ b/interfaces/kits/ani/drawing/text_blob_ani/ani_text_blob.cpp
@@ -18,15 +18,12 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_TEXT_BLOB_NAME = "@ohos.graphics.drawing.drawing.TextBlob";
-const char* ANI_CLASS_TEXT_BLOB_RUN_BUFFER_NAME = "@ohos.graphics.drawing.drawing.TextBlobRunBuffer";
 static constexpr size_t CHAR16_SIZE = 2;
 
 ani_status AniTextBlob::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_TEXT_BLOB_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().textBlob;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_TEXT_BLOB_NAME);
         return ANI_NOT_FOUND;
     }
@@ -37,7 +34,7 @@ ani_status AniTextBlob::AniInit(ani_env *env)
         ani_native_function { "uniqueID", ":l", reinterpret_cast<void*>(UniqueID) },
     };
 
-    ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s", ANI_CLASS_TEXT_BLOB_NAME);
         return ANI_NOT_FOUND;
@@ -65,7 +62,7 @@ ani_status AniTextBlob::AniInit(ani_env *env)
 
 ani_object AniTextBlob::Bounds(ani_env* env, ani_object obj, ani_object aniRectObj)
 {
-    auto aniTextBlob = GetNativeFromObj<AniTextBlob>(env, obj);
+    auto aniTextBlob = GetNativeFromObj<AniTextBlob>(env, obj, AniGlobalField::GetInstance().textBlobNativeObj);
     if (aniTextBlob == nullptr || aniTextBlob->GetTextBlob() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniTextBlob::Bounds textBlob is nullptr.");
         return CreateAniUndefined(env);
@@ -86,7 +83,7 @@ ani_object AniTextBlob::Bounds(ani_env* env, ani_object obj, ani_object aniRectO
 
 ani_long AniTextBlob::UniqueID(ani_env* env, ani_object obj)
 {
-    auto aniTextBlob = GetNativeFromObj<AniTextBlob>(env, obj);
+    auto aniTextBlob = GetNativeFromObj<AniTextBlob>(env, obj, AniGlobalField::GetInstance().textBlobNativeObj);
     if (aniTextBlob == nullptr || aniTextBlob->GetTextBlob() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniTextBlob::UniqueID textBlob is nullptr.");
         return -1;
@@ -105,11 +102,11 @@ std::shared_ptr<Font> AniTextBlob::GetValidFont(const std::shared_ptr<Font>& fon
 }
 
 ani_object AniTextBlob::MakeFromPosText(ani_env* env, ani_object obj, ani_string aniText, ani_int len,
-    ani_object pointArray, ani_object aniFontObj)
+    ani_array pointArray, ani_object aniFontObj)
 {
     std::string textStr = CreateStdString(env, aniText);
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(pointArray, "length", &aniLength)) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(pointArray, &aniLength)) {
         ROSEN_LOGE("AniTextBlob::MakeFromPosText points is invalid");
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Incorrect Argv[2].");
         return CreateAniUndefined(env);
@@ -118,13 +115,13 @@ ani_object AniTextBlob::MakeFromPosText(ani_env* env, ani_object obj, ani_string
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Argv[0] is empty.");
         return CreateAniUndefined(env);
     }
-    if (len != aniLength) {
+    if (len != (ani_int)aniLength) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM,
             "string length does not match points array length.");
         return CreateAniUndefined(env);
     }
 
-    auto aniFont = GetNativeFromObj<AniFont>(env, aniFontObj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, aniFontObj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Incorrect Argv[3] type.");
         return CreateAniUndefined(env);
@@ -138,7 +135,7 @@ ani_object AniTextBlob::MakeFromPosText(ani_env* env, ani_object obj, ani_string
 
     uint32_t pointsSize = static_cast<uint32_t>(aniLength);
     std::unique_ptr<Point[]> points = std::make_unique<Point[]>(pointsSize);
-    if (!MakePoints(env, points.get(), pointsSize, static_cast<ani_array>(pointArray))) {
+    if (!MakePoints(env, points.get(), pointsSize, pointArray)) {
         ROSEN_LOGE("AniTextBlob::MakeFromPosText: Argv[2] is invalid");
         return CreateAniUndefined(env);
     }
@@ -165,7 +162,7 @@ bool AniTextBlob::MakePoints(ani_env* env, Point* points, uint32_t size, ani_arr
 ani_object AniTextBlob::MakeFromString(ani_env* env, ani_object obj, ani_string aniText, ani_object aniFontObj,
     ani_enum_item aniEncoding)
 {
-    auto aniFont = GetNativeFromObj<AniFont>(env, aniFontObj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, aniFontObj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr || aniFont->GetFont() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "AniTextBlob::MakeFromString font is nullptr.");
         return CreateAniUndefined(env);
@@ -193,11 +190,11 @@ ani_object AniTextBlob::MakeFromString(ani_env* env, ani_object obj, ani_string
     return CreateTextBlobObj(env, textBlob);
 }
 
-ani_object AniTextBlob::MakeFromRunBuffer(ani_env* env, ani_object obj, ani_object posArray, ani_object aniFontObj,
+ani_object AniTextBlob::MakeFromRunBuffer(ani_env* env, ani_object obj, ani_array posArray, ani_object aniFontObj,
     ani_object aniRectObj)
 {
-    ani_int aniLength;
-    if (ANI_OK != env->Object_GetPropertyByName_Int(posArray, "length", &aniLength)) {
+    ani_size aniLength;
+    if (ANI_OK != env->Array_GetLength(posArray, &aniLength)) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Incorrect parameter0 type.");
         return CreateAniUndefined(env);
     }
@@ -206,7 +203,7 @@ ani_object AniTextBlob::MakeFromRunBuffer(ani_env* env, ani_object obj, ani_obje
         return CreateAniUndefined(env);
     }
     uint32_t size = static_cast<uint32_t>(aniLength);
-    auto aniFont = GetNativeFromObj<AniFont>(env, aniFontObj);
+    auto aniFont = GetNativeFromObj<AniFont>(env, aniFontObj, AniGlobalField::GetInstance().fontNativeObj);
     if (aniFont == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Incorrect parameter1 type.");
         return CreateAniUndefined(env);
@@ -271,23 +268,22 @@ ani_object AniTextBlob::CreateTextBlobObj(ani_env* env, const std::shared_ptr<Te
     return aniObj;
 }
 
-bool AniTextBlob::MakeRunBuffer(ani_env* env, TextBlobBuilder::RunBuffer& runBuffer, uint32_t size, ani_object posArray)
+bool AniTextBlob::MakeRunBuffer(ani_env* env, TextBlobBuilder::RunBuffer& runBuffer, uint32_t size, ani_array posArray)
 {
     if (size > MAX_ELEMENTSIZE) {
         ROSEN_LOGE("AniTextBlob::MakeRunBuffer failed. size exceeds the upper limit.");
         return false;
     }
-    ani_class runBufferClass;
-    if (ANI_OK != env->FindClass(ANI_CLASS_TEXT_BLOB_RUN_BUFFER_NAME, &runBufferClass)) {
+    ani_class runBufferClass = AniGlobalClass::GetInstance().runBufferInterface;
+    if (runBufferClass == nullptr) {
         ROSEN_LOGE("AniTextBlob::MakeRunBuffer failed. Can't find class %{public}s.",
-            ANI_CLASS_TEXT_BLOB_RUN_BUFFER_NAME);
+            ANI_INTERFACE_TEXT_BLOB_RUN_BUFFER_NAME);
         return false;
     }
     for (uint32_t i = 0; i < size; i++) {
         Drawing::Point point;
         ani_ref runBufferRef;
-        if (ANI_OK != env->Object_CallMethodByName_Ref(
-            posArray, "$_get", "i:Y", &runBufferRef, (ani_int)i)) {
+        if (ANI_OK != env->Array_Get(posArray, (ani_int)i, &runBufferRef)) {
             ROSEN_LOGE("AniTextBlob::MakeRunBuffer Object_CallMethodByName_Ref failed");
             return false;
         }
@@ -298,13 +294,20 @@ bool AniTextBlob::MakeRunBuffer(ani_env* env, TextBlobBuilder::RunBuffer& runBuf
             return false;
         }
 
+        ani_method runBufferGetGlyph = AniGlobalMethod::GetInstance().runBufferGetGlyph;
+        ani_method runBufferGetPositionX = AniGlobalMethod::GetInstance().runBufferGetPositionX;
+        ani_method runBufferGetPositionY = AniGlobalMethod::GetInstance().runBufferGetPositionY;
+        if (runBufferGetGlyph == nullptr || runBufferGetPositionX == nullptr || runBufferGetPositionY == nullptr) {
+            ROSEN_LOGE("AniTextBlob::MakeRunBuffer failed by cls method is null");
+            return false;
+        }
         ani_int glyph;
         ani_double positionX;
         ani_double positionY;
-        if ((env->Object_GetPropertyByName_Int(aniRunBuffer, "glyph", &glyph) != ANI_OK) ||
-            (env->Object_GetPropertyByName_Double(aniRunBuffer, "positionX", &positionX) != ANI_OK) ||
-            (env->Object_GetPropertyByName_Double(aniRunBuffer, "positionY", &positionY) != ANI_OK)) {
-            ROSEN_LOGE("AniTextBlob::MakeRunBuffer Object_GetPropertyByName failed");
+        if ((env->Object_CallMethod_Int(aniRunBuffer, runBufferGetGlyph, &glyph) != ANI_OK) ||
+            (env->Object_CallMethod_Double(aniRunBuffer, runBufferGetPositionX, &positionX) != ANI_OK) ||
+            (env->Object_CallMethod_Double(aniRunBuffer, runBufferGetPositionY, &positionY) != ANI_OK)) {
+            ROSEN_LOGE("AniTextBlob::MakeRunBuffer Object_CallMethod failed");
             return false;
         }
         
diff --git a/interfaces/kits/ani/drawing/text_blob_ani/ani_text_blob.h b/interfaces/kits/ani/drawing/text_blob_ani/ani_text_blob.h
index a459b94435..3c1f59695c 100644
--- a/interfaces/kits/ani/drawing/text_blob_ani/ani_text_blob.h
+++ b/interfaces/kits/ani/drawing/text_blob_ani/ani_text_blob.h
@@ -32,10 +32,10 @@ public:
     static ani_object Bounds(ani_env* env, ani_object obj, ani_object aniRectObj);
     static ani_long UniqueID(ani_env* env, ani_object obj);
     static ani_object MakeFromPosText(ani_env* env, ani_object obj, ani_string aniText, ani_int len,
-        ani_object aniPoints, ani_object aniFontObj);
+        ani_array pointArray, ani_object aniFontObj);
     static ani_object MakeFromString(ani_env* env, ani_object obj, ani_string aniText, ani_object aniFontObj,
         ani_enum_item aniEncoding);
-    static ani_object MakeFromRunBuffer(ani_env* env, ani_object obj, ani_object posArray, ani_object aniFontObj,
+    static ani_object MakeFromRunBuffer(ani_env* env, ani_object obj, ani_array posArray, ani_object aniFontObj,
         ani_object aniRectObj);
 
     std::shared_ptr<TextBlob> GetTextBlob();
@@ -45,7 +45,7 @@ private:
     static ani_object GetTextBlobObj(ani_env* env, const char* buffer, size_t bufferLen, const Point points[],
         const std::shared_ptr<Font>& font);
     static ani_object CreateTextBlobObj(ani_env* env, const std::shared_ptr<TextBlob> textBlob);
-    static bool MakeRunBuffer(ani_env* env, TextBlobBuilder::RunBuffer& runBuffer, uint32_t size, ani_object posArray);
+    static bool MakeRunBuffer(ani_env* env, TextBlobBuilder::RunBuffer& runBuffer, uint32_t size, ani_array posArray);
     std::shared_ptr<TextBlob> textBlob_ = nullptr;
 };
 } // namespace Drawing
diff --git a/interfaces/kits/ani/drawing/tool_ani/ani_tool.cpp b/interfaces/kits/ani/drawing/tool_ani/ani_tool.cpp
index b57c91bf10..c51bbd6c58 100644
--- a/interfaces/kits/ani/drawing/tool_ani/ani_tool.cpp
+++ b/interfaces/kits/ani/drawing/tool_ani/ani_tool.cpp
@@ -21,7 +21,6 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_TOOL_NAME = "@ohos.graphics.drawing.drawing.Tool";
 #ifdef ROSEN_OHOS
 const int32_t GLOBAL_ERROR = 10000;
 // The expectLength of regex match of "rgb(255,0,0)". The elements:0 is the string, 1 is r, 2 is g, 3 is b.
@@ -45,9 +44,8 @@ const std::regex HEX_PATTERN("^[0-9a-fA-F]+$");
 
 ani_status AniTool::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_TOOL_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().tool;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_TOOL_NAME);
         return ANI_NOT_FOUND;
     }
@@ -57,7 +55,7 @@ ani_status AniTool::AniInit(ani_env *env)
             reinterpret_cast<void*>(MakeColorFromResourceColor) },
     };
 
-    ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindStaticNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind static methods fail: %{public}s", ANI_CLASS_TOOL_NAME);
         return ANI_NOT_FOUND;
@@ -139,17 +137,17 @@ bool AniTool::IsUndefinedObject(ani_env* env, ani_ref objectRef)
     return (bool)isUndefined;
 }
 
-bool AniTool::GetTypeParam(ani_env* env, ani_object obj, const char* name, int32_t& result)
+bool AniTool::GetTypeParam(ani_env* env, ani_object obj, int32_t& result)
 {
     ani_ref resultRef;
-    if (env->Object_GetPropertyByName_Ref(obj, name, &resultRef) != ANI_OK) {
+    if (env->Object_CallMethod_Ref(obj, AniGlobalMethod::GetInstance().resourceGetType, &resultRef) != ANI_OK) {
         return false;
     }
     if (IsUndefinedObject(env, resultRef)) {
         return false;
     }
-    ani_class typeClass;
-    if (env->FindClass("std.core.Int", &typeClass) != ANI_OK) {
+    ani_class typeClass = AniGlobalClass::GetInstance().intCls;
+    if (typeClass == nullptr) {
         return false;
     }
     ani_boolean isInt = ANI_TRUE;
@@ -158,24 +156,24 @@ bool AniTool::GetTypeParam(ani_env* env, ani_object obj, const char* name, int32
         return false;
     }
     ani_int resultValue;
-    if (env->Object_CallMethodByName_Int(typeObj, "toInt", nullptr, &resultValue) != ANI_OK) {
+    if (env->Object_CallMethod_Int(typeObj, AniGlobalMethod::GetInstance().intGet, &resultValue) != ANI_OK) {
         return false;
     }
     result = static_cast<int32_t>(resultValue);
     return true;
 }
 
-bool AniTool::GetParamsArray(ani_env* env, ani_object obj, const char* name, std::vector<std::string>& result)
+bool AniTool::GetParamsArray(ani_env* env, ani_object obj, std::vector<std::string>& result)
 {
     ani_ref paramsRef;
-    if (env->Object_GetPropertyByName_Ref(obj, name, &paramsRef) != ANI_OK) {
+    if (env->Object_CallMethod_Ref(obj, AniGlobalMethod::GetInstance().resourceGetParams, &paramsRef) != ANI_OK) {
         return false;
     }
     if (IsUndefinedObject(env, paramsRef)) {
         return false;
     }
-    ani_class paramsClass;
-    if (env->FindClass("escompat.Array", &paramsClass) != ANI_OK) {
+    ani_class paramsClass = AniGlobalClass::GetInstance().arrayCls;
+    if (paramsClass == nullptr) {
         return false;
     }
     ani_object paramsObj = static_cast<ani_object>(paramsRef);
@@ -204,15 +202,15 @@ bool AniTool::GetParamsArray(ani_env* env, ani_object obj, const char* name, std
 bool AniTool::GetResourceInfo(ani_env* env, ani_object obj, ResourceInfo& result)
 {
     ani_long aniId;
-    if (env->Object_GetPropertyByName_Long(obj, "id", &aniId) != ANI_OK) {
+    if (env->Object_CallMethod_Long(obj, AniGlobalMethod::GetInstance().resourceGetId, &aniId) != ANI_OK) {
         return false;
     }
     result.resId = static_cast<int32_t>(aniId);
 
-    if (!GetTypeParam(env, obj, "type", result.type)) {
+    if (!GetTypeParam(env, obj, result.type)) {
         return false;
     }
-    if (!GetParamsArray(env, obj, "params", result.params)) {
+    if (!GetParamsArray(env, obj, result.params)) {
         return false;
     }
     return true;
@@ -479,8 +477,8 @@ bool AniTool::GetColorObjectResult(ani_env* env, ani_object value, uint32_t& res
 
 bool AniTool::IsStringObject(ani_env* env, ani_object obj)
 {
-    ani_class stringClass;
-    if (env->FindClass("std.core.String", &stringClass) != ANI_OK) {
+    ani_class stringClass = AniGlobalClass::GetInstance().strCls;
+    if (stringClass == nullptr) {
         return false;
     }
     ani_boolean isString;
@@ -492,8 +490,8 @@ bool AniTool::IsStringObject(ani_env* env, ani_object obj)
 
 bool AniTool::IsColorEnum(ani_env* env, ani_object obj)
 {
-    ani_enum colorEnum;
-    if (env->FindEnum("arkui.component.enums.Color", &colorEnum) != ANI_OK) {
+    ani_enum colorEnum = AniGlobalEnum::GetInstance().colorEnum;
+    if (colorEnum == nullptr) {
         return false;
     }
 
@@ -507,8 +505,8 @@ bool AniTool::IsColorEnum(ani_env* env, ani_object obj)
 
 bool AniTool::IsIntObject(ani_env* env, ani_object obj)
 {
-    ani_class intClass;
-    if (env->FindClass("std.core.Int", &intClass) != ANI_OK) {
+    ani_class intClass = AniGlobalClass::GetInstance().intCls;
+    if (intClass == nullptr) {
         return false;
     }
     ani_boolean isInt;
@@ -520,8 +518,8 @@ bool AniTool::IsIntObject(ani_env* env, ani_object obj)
 
 bool AniTool::IsResourceObject(ani_env* env, ani_object obj)
 {
-    ani_class resourceClass;
-    if (env->FindClass("global.resource.Resource", &resourceClass) != ANI_OK) {
+    ani_class resourceClass = AniGlobalClass::GetInstance().resourceCls;
+    if (resourceClass == nullptr) {
         return false;
     }
     ani_boolean isResource;
@@ -558,7 +556,7 @@ bool AniTool::GetResourceColor(ani_env* env, ani_object obj, uint32_t& result)
 
     if (IsIntObject(env, obj)) {
         ani_int aniColor;
-        if (ANI_OK != env->Object_CallMethodByName_Int(obj, "toInt", ":i", &aniColor)) {
+        if (ANI_OK != env->Object_CallMethod_Int(obj, AniGlobalMethod::GetInstance().intGet, &aniColor)) {
             ROSEN_LOGE("AniTool::GetResourceColor failed by Object_CallMethodByName_Double");
             return false;
         }
diff --git a/interfaces/kits/ani/drawing/tool_ani/ani_tool.h b/interfaces/kits/ani/drawing/tool_ani/ani_tool.h
index a9b4c73a3f..5fc209738f 100644
--- a/interfaces/kits/ani/drawing/tool_ani/ani_tool.h
+++ b/interfaces/kits/ani/drawing/tool_ani/ani_tool.h
@@ -70,8 +70,8 @@ private:
     static bool IsColorEnum(ani_env* env, ani_object obj);
     static bool IsIntObject(ani_env* env, ani_object obj);
     static bool IsResourceObject(ani_env *env, ani_object object);
-    static bool GetTypeParam(ani_env* env, ani_object obj, const char* name, int32_t& result);
-    static bool GetParamsArray(ani_env* env, ani_object obj, const char* name, std::vector<std::string>& result);
+    static bool GetTypeParam(ani_env* env, ani_object obj, int32_t& result);
+    static bool GetParamsArray(ani_env* env, ani_object obj, std::vector<std::string>& result);
     static std::vector<std::string> AniToStdVectorString(ani_env* env, ani_array array);
     static bool IsUndefinedObject(ani_env* env, ani_ref objectRef);
 };
diff --git a/interfaces/kits/ani/drawing/typeface_ani/ani_typeface.cpp b/interfaces/kits/ani/drawing/typeface_ani/ani_typeface.cpp
index 66feca0494..d30b68da81 100644
--- a/interfaces/kits/ani/drawing/typeface_ani/ani_typeface.cpp
+++ b/interfaces/kits/ani/drawing/typeface_ani/ani_typeface.cpp
@@ -24,14 +24,12 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_TYPEFACE_NAME = "@ohos.graphics.drawing.drawing.Typeface";
 const std::string G_SYSTEM_FONT_DIR = "/system/fonts";
 
 ani_status AniTypeface::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_TYPEFACE_NAME, &cls);
-    if (ret != ANI_OK) {
+    ani_class cls = AniGlobalClass::GetInstance().typeface;
+    if (cls == nullptr) {
         ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_TYPEFACE_NAME);
         return ANI_NOT_FOUND;
     }
@@ -57,7 +55,7 @@ ani_status AniTypeface::AniInit(ani_env *env)
         ani_native_function { "getTypefaceAddr", nullptr, reinterpret_cast<void*>(GetTypefaceAddr) },
     };
 
-    ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s ret: %{public}d", ANI_CLASS_TYPEFACE_NAME, ret);
         return ANI_NOT_FOUND;
@@ -84,7 +82,7 @@ void AniTypeface::Constructor(ani_env* env, ani_object obj)
 
 ani_string AniTypeface::GetFamilyName(ani_env* env, ani_object obj)
 {
-    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, obj);
+    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, obj, AniGlobalField::GetInstance().typefaceNativeObj);
     if (aniTypeface == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return ani_string{};
@@ -101,7 +99,8 @@ ani_string AniTypeface::GetFamilyName(ani_env* env, ani_object obj)
 ani_object AniTypeface::CreateAniTypeface(ani_env* env, std::shared_ptr<Typeface> typeface)
 {
     AniTypeface* aniTypeface = new AniTypeface(typeface);
-    ani_object aniObj = CreateAniObject(env, ANI_CLASS_TYPEFACE_NAME, nullptr);
+    ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().typeface,
+        AniGlobalMethod::GetInstance().typefaceCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj, NATIVE_OBJ, reinterpret_cast<ani_long>(aniTypeface))) {
         delete aniTypeface;
         ROSEN_LOGE("AniTypeface::CreateAniTypeface failed create aniTypeface");
@@ -141,7 +140,8 @@ ani_object AniTypeface::MakeFromFileWithArguments(ani_env* env, ani_object obj,
     ani_object argumentsObj)
 {
     std::string filePath = CreateStdString(env, aniFilePath);
-    auto aniTypefaceArguments = GetNativeFromObj<AniTypefaceArguments>(env, argumentsObj);
+    auto aniTypefaceArguments = GetNativeFromObj<AniTypefaceArguments>(env, argumentsObj,
+        AniGlobalField::GetInstance().typefaceArgumentsNativeObj);
     if (aniTypefaceArguments == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params. ");
         return CreateAniUndefined(env);
@@ -203,7 +203,8 @@ ani_object AniTypeface::MakeFromRawFile(ani_env* env, ani_object obj, ani_object
             return CreateAniUndefined(env);
         }
     }
-    ani_object aniObj = CreateAniObject(env, ANI_CLASS_TYPEFACE_NAME, nullptr);
+    ani_object aniObj = CreateAniObject(env, AniGlobalClass::GetInstance().typeface,
+        AniGlobalMethod::GetInstance().typefaceCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniObj, NATIVE_OBJ, reinterpret_cast<ani_long>(aniTypeface))) {
         delete aniTypeface;
         ROSEN_LOGE("AniTypeface::MakeFromRawFile failed create aniTypeface");
@@ -234,7 +235,8 @@ ani_object AniTypeface::TypefaceTransferStatic(ani_env* env, [[maybe_unused]]ani
     }
 
     auto aniTypeface = new AniTypeface(jsTypeface->GetTypeface());
-    ani_object aniTypefaceObj = CreateAniObject(env, ANI_CLASS_TYPEFACE_NAME, nullptr);
+    ani_object aniTypefaceObj = CreateAniObject(env, AniGlobalClass::GetInstance().typeface,
+        AniGlobalMethod::GetInstance().typefaceCtor);
     if (ANI_OK != env->Object_SetFieldByName_Long(aniTypefaceObj,
         NATIVE_OBJ, reinterpret_cast<ani_long>(aniTypeface))) {
         ROSEN_LOGE("AniTypeface::TypefaceTransferStatic failed create aniTypeface");
@@ -246,7 +248,7 @@ ani_object AniTypeface::TypefaceTransferStatic(ani_env* env, [[maybe_unused]]ani
 
 ani_boolean AniTypeface::IsBold(ani_env* env, ani_object obj)
 {
-    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, obj);
+    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, obj, AniGlobalField::GetInstance().typefaceNativeObj);
     if (aniTypeface == nullptr || aniTypeface->GetTypeface() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return false;
@@ -256,7 +258,7 @@ ani_boolean AniTypeface::IsBold(ani_env* env, ani_object obj)
 
 ani_boolean AniTypeface::IsItalic(ani_env* env, ani_object obj)
 {
-    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, obj);
+    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, obj, AniGlobalField::GetInstance().typefaceNativeObj);
     if (aniTypeface == nullptr || aniTypeface->GetTypeface() == nullptr) {
         ThrowBusinessError(env, DrawingErrorCode::ERROR_INVALID_PARAM, "Invalid params.");
         return false;
@@ -266,7 +268,7 @@ ani_boolean AniTypeface::IsItalic(ani_env* env, ani_object obj)
 
 ani_long AniTypeface::GetTypefaceAddr(ani_env* env, [[maybe_unused]]ani_object obj, ani_object input)
 {
-    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, input);
+    auto aniTypeface = GetNativeFromObj<AniTypeface>(env, input, AniGlobalField::GetInstance().typefaceNativeObj);
     if (aniTypeface == nullptr || aniTypeface->GetTypeface() == nullptr) {
         ROSEN_LOGE("AniTypeface::GetTypefaceAddr aniTypeface is null");
         return 0;
diff --git a/interfaces/kits/ani/drawing/typeface_arguments_ani/ani_typeface_arguments.cpp b/interfaces/kits/ani/drawing/typeface_arguments_ani/ani_typeface_arguments.cpp
index f87cb4a17f..b385c9208e 100644
--- a/interfaces/kits/ani/drawing/typeface_arguments_ani/ani_typeface_arguments.cpp
+++ b/interfaces/kits/ani/drawing/typeface_arguments_ani/ani_typeface_arguments.cpp
@@ -17,7 +17,6 @@
 
 namespace OHOS::Rosen {
 namespace Drawing {
-const char* ANI_CLASS_TYPEFACE_ARGUMENTS_NAME = "@ohos.graphics.drawing.drawing.TypefaceArguments";
 constexpr uint32_t VARIATION_AXIS_LENGTH = 4;
 constexpr uint32_t AXIS_OFFSET_ZERO = 24;
 constexpr uint32_t AXIS_OFFSET_ONE = 16;
@@ -25,10 +24,9 @@ constexpr uint32_t AXIS_OFFSET_TWO = 8;
 
 ani_status AniTypefaceArguments::AniInit(ani_env *env)
 {
-    ani_class cls = nullptr;
-    ani_status ret = env->FindClass(ANI_CLASS_TYPEFACE_ARGUMENTS_NAME, &cls);
-    if (ret != ANI_OK) {
-        ROSEN_LOGE("[ANI] can't find class: %{public}s ret: %{public}d", ANI_CLASS_TYPEFACE_ARGUMENTS_NAME, ret);
+    ani_class cls = AniGlobalClass::GetInstance().typefaceArguments;
+    if (cls == nullptr) {
+        ROSEN_LOGE("[ANI] can't find class: %{public}s", ANI_CLASS_TYPEFACE_ARGUMENTS_NAME);
         return ANI_NOT_FOUND;
     }
 
@@ -37,7 +35,7 @@ ani_status AniTypefaceArguments::AniInit(ani_env *env)
         ani_native_function { "addVariation", nullptr, reinterpret_cast<void*>(AddVariation) },
     };
 
-    ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
+    ani_status ret = env->Class_BindNativeMethods(cls, methods.data(), methods.size());
     if (ret != ANI_OK) {
         ROSEN_LOGE("[ANI] bind methods fail: %{public}s ret: %{public}d", ANI_CLASS_TYPEFACE_ARGUMENTS_NAME, ret);
         return ANI_NOT_FOUND;
@@ -73,7 +71,8 @@ void AniTypefaceArguments::AddVariation(ani_env* env, ani_object obj, ani_string
             "Incorrect parameter0 length, the length must be four");
         return;
     }
-    auto aniTypefaceArguments = GetNativeFromObj<AniTypefaceArguments>(env, obj);
+    auto aniTypefaceArguments = GetNativeFromObj<AniTypefaceArguments>(env, obj,
+        AniGlobalField::GetInstance().typefaceArgumentsNativeObj);
     if (aniTypefaceArguments == nullptr) {
         ROSEN_LOGE("AniTypefaceArguments::AddVariation aniTypefaceArguments invalid.");
         return;
